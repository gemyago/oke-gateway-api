
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>controller: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/gemyago/oke-gateway-api/cmd/controller/main.go (57.1%)</option>
				
				<option value="file1">github.com/gemyago/oke-gateway-api/cmd/controller/root.go (100.0%)</option>
				
				<option value="file2">github.com/gemyago/oke-gateway-api/cmd/controller/start.go (91.4%)</option>
				
				<option value="file3">github.com/gemyago/oke-gateway-api/cmd/server/main.go (57.1%)</option>
				
				<option value="file4">github.com/gemyago/oke-gateway-api/cmd/server/root.go (100.0%)</option>
				
				<option value="file5">github.com/gemyago/oke-gateway-api/cmd/server/start.go (91.7%)</option>
				
				<option value="file6">github.com/gemyago/oke-gateway-api/internal/api/http/handler.go (100.0%)</option>
				
				<option value="file7">github.com/gemyago/oke-gateway-api/internal/api/http/middleware/chain.go (100.0%)</option>
				
				<option value="file8">github.com/gemyago/oke-gateway-api/internal/api/http/middleware/recover.go (100.0%)</option>
				
				<option value="file9">github.com/gemyago/oke-gateway-api/internal/api/http/middleware/tracing.go (100.0%)</option>
				
				<option value="file10">github.com/gemyago/oke-gateway-api/internal/api/http/register.go (100.0%)</option>
				
				<option value="file11">github.com/gemyago/oke-gateway-api/internal/api/http/server/register.go (100.0%)</option>
				
				<option value="file12">github.com/gemyago/oke-gateway-api/internal/api/http/server/server.go (100.0%)</option>
				
				<option value="file13">github.com/gemyago/oke-gateway-api/internal/app/errors.go (100.0%)</option>
				
				<option value="file14">github.com/gemyago/oke-gateway-api/internal/app/gateway_controller.go (96.3%)</option>
				
				<option value="file15">github.com/gemyago/oke-gateway-api/internal/app/gateway_model.go (100.0%)</option>
				
				<option value="file16">github.com/gemyago/oke-gateway-api/internal/app/gatewayclass_controller.go (100.0%)</option>
				
				<option value="file17">github.com/gemyago/oke-gateway-api/internal/app/httpbackend_model.go (91.9%)</option>
				
				<option value="file18">github.com/gemyago/oke-gateway-api/internal/app/httproute_controller.go (100.0%)</option>
				
				<option value="file19">github.com/gemyago/oke-gateway-api/internal/app/httproute_model.go (100.0%)</option>
				
				<option value="file20">github.com/gemyago/oke-gateway-api/internal/app/mock_gateway_model.go (70.5%)</option>
				
				<option value="file21">github.com/gemyago/oke-gateway-api/internal/app/mock_http_backend_model.go (63.2%)</option>
				
				<option value="file22">github.com/gemyago/oke-gateway-api/internal/app/mock_http_route_model.go (63.3%)</option>
				
				<option value="file23">github.com/gemyago/oke-gateway-api/internal/app/mock_k_8_s_client.go (50.5%)</option>
				
				<option value="file24">github.com/gemyago/oke-gateway-api/internal/app/mock_oci_load_balancer_client.go (39.0%)</option>
				
				<option value="file25">github.com/gemyago/oke-gateway-api/internal/app/mock_oci_load_balancer_model.go (62.5%)</option>
				
				<option value="file26">github.com/gemyago/oke-gateway-api/internal/app/mock_resources_model.go (63.2%)</option>
				
				<option value="file27">github.com/gemyago/oke-gateway-api/internal/app/mock_work_requests_watcher.go (68.2%)</option>
				
				<option value="file28">github.com/gemyago/oke-gateway-api/internal/app/oci_load_balancer_model.go (98.0%)</option>
				
				<option value="file29">github.com/gemyago/oke-gateway-api/internal/app/register.go (100.0%)</option>
				
				<option value="file30">github.com/gemyago/oke-gateway-api/internal/app/resources_model.go (100.0%)</option>
				
				<option value="file31">github.com/gemyago/oke-gateway-api/internal/app/watches_model.go (97.7%)</option>
				
				<option value="file32">github.com/gemyago/oke-gateway-api/internal/config/load.go (95.8%)</option>
				
				<option value="file33">github.com/gemyago/oke-gateway-api/internal/config/provide.go (100.0%)</option>
				
				<option value="file34">github.com/gemyago/oke-gateway-api/internal/di/dig.go (100.0%)</option>
				
				<option value="file35">github.com/gemyago/oke-gateway-api/internal/diag/attributes.go (100.0%)</option>
				
				<option value="file36">github.com/gemyago/oke-gateway-api/internal/diag/mock_slog_handler.go (34.7%)</option>
				
				<option value="file37">github.com/gemyago/oke-gateway-api/internal/diag/slog.go (96.6%)</option>
				
				<option value="file38">github.com/gemyago/oke-gateway-api/internal/diag/testing.go (75.0%)</option>
				
				<option value="file39">github.com/gemyago/oke-gateway-api/internal/k8s/middleware.go (100.0%)</option>
				
				<option value="file40">github.com/gemyago/oke-gateway-api/internal/k8s/start_manager.go (0.0%)</option>
				
				<option value="file41">github.com/gemyago/oke-gateway-api/internal/services/k8sapi/client.go (52.9%)</option>
				
				<option value="file42">github.com/gemyago/oke-gateway-api/internal/services/k8sapi/mock_field_indexer.go (68.2%)</option>
				
				<option value="file43">github.com/gemyago/oke-gateway-api/internal/services/k8sapi/mock_sub_resource_writer.go (27.4%)</option>
				
				<option value="file44">github.com/gemyago/oke-gateway-api/internal/services/k8sapi/register.go (100.0%)</option>
				
				<option value="file45">github.com/gemyago/oke-gateway-api/internal/services/ociapi/clients.go (42.9%)</option>
				
				<option value="file46">github.com/gemyago/oke-gateway-api/internal/services/ociapi/config.go (100.0%)</option>
				
				<option value="file47">github.com/gemyago/oke-gateway-api/internal/services/ociapi/mock_work_requests_client.go (78.6%)</option>
				
				<option value="file48">github.com/gemyago/oke-gateway-api/internal/services/ociapi/register.go (100.0%)</option>
				
				<option value="file49">github.com/gemyago/oke-gateway-api/internal/services/ociapi/testing.go (63.6%)</option>
				
				<option value="file50">github.com/gemyago/oke-gateway-api/internal/services/ociapi/work_requests_watcher.go (95.5%)</option>
				
				<option value="file51">github.com/gemyago/oke-gateway-api/internal/services/register.go (100.0%)</option>
				
				<option value="file52">github.com/gemyago/oke-gateway-api/internal/services/shutdown.go (95.8%)</option>
				
				<option value="file53">github.com/gemyago/oke-gateway-api/internal/services/testing.go (12.5%)</option>
				
				<option value="file54">github.com/gemyago/oke-gateway-api/internal/services/time.go (100.0%)</option>
				
				<option value="file55">github.com/gemyago/oke-gateway-api/internal/types/register.go (100.0%)</option>
				
				<option value="file56">github.com/gemyago/oke-gateway-api/internal/types/zz_generated.deepcopy.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "os"

        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

func setupCommands() *cobra.Command <span class="cov10" title="3">{
        container := dig.New()
        rootCmd := newRootCmd(container)
        rootCmd.AddCommand(
                newStartServerCmd(container),
        )
        return rootCmd
}</span>

func main() <span class="cov0" title="0">{ // coverage-ignore
        rootCmd := setupCommands()
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                // cobra will print error to stdout
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "errors"
        "fmt"
        "log/slog"

        "github.com/gemyago/oke-gateway-api/internal/app"
        "github.com/gemyago/oke-gateway-api/internal/config"
        "github.com/gemyago/oke-gateway-api/internal/di"
        "github.com/gemyago/oke-gateway-api/internal/diag"
        "github.com/gemyago/oke-gateway-api/internal/services"
        "github.com/samber/lo"
        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

func newRootCmd(container *dig.Container) *cobra.Command <span class="cov10" title="3">{
        logsOutputFile := ""

        cmd := &amp;cobra.Command{
                Use:   "server",
                Short: "Command to start the server",
        }
        cmd.SilenceUsage = true
        cmd.PersistentFlags().StringP("log-level", "l", "", "Produce logs with given level. Default is env specific.")
        cmd.PersistentFlags().StringVar(
                &amp;logsOutputFile,
                "logs-file",
                "",
                "Produce logs to file instead of stdout. Used for tests only.",
        )
        cmd.PersistentFlags().Bool(
                "json-logs",
                false,
                "Indicates if logs should be in JSON format or text (default)",
        )
        cmd.PersistentFlags().StringP(
                "env",
                "e",
                "",
                "Env that the process is running in.",
        )
        cfg := config.New()
        lo.Must0(cfg.BindPFlags(cmd.PersistentFlags()))
        cmd.PersistentPreRunE = func(_ *cobra.Command, _ []string) error </span><span class="cov10" title="3">{
                err := config.Load(cfg, config.NewLoadOpts().WithEnv(cfg.GetString("env")))
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov6" title="2">var logLevel slog.Level
                if err = logLevel.UnmarshalText([]byte(cfg.GetString("defaultLogLevel"))); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov1" title="1">rootLogger := diag.SetupRootLogger(
                        diag.NewRootLoggerOpts().
                                WithJSONLogs(cfg.GetBool("jsonLogs")).
                                WithLogLevel(logLevel).
                                WithOptionalOutputFile(logsOutputFile),
                )

                err = errors.Join(
                        config.Provide(container, cfg),

                        // app layer
                        app.Register(container),

                        // services
                        services.Register(container),

                        di.ProvideAll(container,
                                di.ProvideValue(rootLogger),
                        ),
                )

                return lo.
                        If(err != nil, fmt.Errorf("failed to inject dependencies: %w", err)).
                        Else(nil)</span>
        }
        <span class="cov10" title="3">return cmd</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "errors"
        "log/slog"
        "os/signal"
        "time"

        "github.com/gemyago/oke-gateway-api/internal/diag"
        "github.com/gemyago/oke-gateway-api/internal/k8s"
        "github.com/gemyago/oke-gateway-api/internal/services"
        "github.com/gemyago/oke-gateway-api/internal/services/k8sapi"
        "github.com/gemyago/oke-gateway-api/internal/services/ociapi"
        "github.com/spf13/cobra"
        "go.uber.org/dig"
        "golang.org/x/sys/unix"
)

type startServerParams struct {
        dig.In `ignore-unexported:"true"`

        RootLogger *slog.Logger

        *services.ShutdownHooks

        ManagerDeps k8s.StartManagerDeps

        noop bool
}

func startServer(params startServerParams) error <span class="cov1" title="1">{
        rootLogger := params.RootLogger
        rootCtx := context.Background()

        shutdown := func() error </span><span class="cov1" title="1">{
                rootLogger.InfoContext(rootCtx, "Trying to shut down gracefully")
                ts := time.Now()

                err := params.ShutdownHooks.PerformShutdown(rootCtx)
                if err != nil </span><span class="cov0" title="0">{
                        rootLogger.ErrorContext(rootCtx, "Failed to shut down gracefully", diag.ErrAttr(err))
                }</span>

                <span class="cov1" title="1">rootLogger.InfoContext(rootCtx, "Service stopped",
                        slog.Duration("duration", time.Since(ts)),
                )
                return err</span>
        }

        <span class="cov1" title="1">signalCtx, cancel := signal.NotifyContext(rootCtx, unix.SIGINT, unix.SIGTERM)
        defer cancel()

        const startedComponents = 1
        startupErrors := make(chan error, startedComponents)
        go func() </span><span class="cov1" title="1">{
                if params.noop </span><span class="cov1" title="1">{
                        rootLogger.InfoContext(signalCtx, "NOOP: Starting k8s controller manager")
                        startupErrors &lt;- nil
                        return
                }</span>
                <span class="cov0" title="0">startupErrors &lt;- k8s.StartManager(signalCtx, params.ManagerDeps)</span>
        }()

        <span class="cov1" title="1">var startupErr error
        select </span>{
        case startupErr = &lt;-startupErrors:<span class="cov1" title="1">
                if startupErr != nil </span><span class="cov0" title="0">{
                        rootLogger.ErrorContext(rootCtx, "Server startup failed", "err", startupErr)
                }</span>
        case &lt;-signalCtx.Done():<span class="cov0" title="0"></span> // coverage-ignore
                // We will attempt to shut down in both cases
                // so doing it once on a next line
        }
        <span class="cov1" title="1">return errors.Join(startupErr, shutdown())</span>
}

func newStartServerCmd(container *dig.Container) *cobra.Command <span class="cov10" title="3">{
        cmd := &amp;cobra.Command{
                Use:   "start",
                Short: "Command to start server",
        }
        noop := false
        cmd.Flags().BoolVar(
                &amp;noop,
                "noop",
                false,
                "Do not start. Just setup deps and exit. Useful for testing if setup is all working.",
        )
        cmd.PreRunE = func(_ *cobra.Command, _ []string) error </span><span class="cov1" title="1">{
                return errors.Join(
                        k8sapi.Register(container),
                        ociapi.Register(container),
                )
        }</span>
        <span class="cov10" title="3">cmd.RunE = func(_ *cobra.Command, _ []string) error </span><span class="cov1" title="1">{
                return container.Invoke(func(params startServerParams) error </span><span class="cov1" title="1">{
                        params.noop = noop
                        return startServer(params)
                }</span>)
        }
        <span class="cov10" title="3">return cmd</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "os"

        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

func setupCommands() *cobra.Command <span class="cov10" title="3">{
        container := dig.New()
        rootCmd := newRootCmd(container)
        rootCmd.AddCommand(
                newStartServerCmd(container),
        )
        return rootCmd
}</span>

func main() <span class="cov0" title="0">{ // coverage-ignore
        rootCmd := setupCommands()
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                // cobra will print error to stdout
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "errors"
        "fmt"
        "log/slog"

        "github.com/gemyago/oke-gateway-api/internal/config"
        "github.com/gemyago/oke-gateway-api/internal/di"
        "github.com/gemyago/oke-gateway-api/internal/diag"
        "github.com/gemyago/oke-gateway-api/internal/services"
        "github.com/samber/lo"
        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

func newRootCmd(container *dig.Container) *cobra.Command <span class="cov10" title="3">{
        logsOutputFile := ""

        cmd := &amp;cobra.Command{
                Use:   "server",
                Short: "Command to start the simple server",
        }
        cmd.SilenceUsage = true
        cmd.PersistentFlags().StringP("log-level", "l", "", "Produce logs with given level. Default is env specific.")
        cmd.PersistentFlags().StringVar(
                &amp;logsOutputFile,
                "logs-file",
                "",
                "Produce logs to file instead of stdout. Used for tests only.",
        )
        cmd.PersistentFlags().Bool(
                "json-logs",
                false,
                "Indicates if logs should be in JSON format or text (default)",
        )
        cmd.PersistentFlags().StringP(
                "env",
                "e",
                "",
                "Env that the process is running in.",
        )
        cfg := config.New()
        lo.Must0(cfg.BindPFlags(cmd.PersistentFlags()))
        cmd.PersistentPreRunE = func(_ *cobra.Command, _ []string) error </span><span class="cov10" title="3">{
                err := config.Load(cfg, config.NewLoadOpts().WithEnv(cfg.GetString("env")))
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov6" title="2">var logLevel slog.Level
                if err = logLevel.UnmarshalText([]byte(cfg.GetString("defaultLogLevel"))); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov1" title="1">rootLogger := diag.SetupRootLogger(
                        diag.NewRootLoggerOpts().
                                WithJSONLogs(cfg.GetBool("jsonLogs")).
                                WithLogLevel(logLevel).
                                WithOptionalOutputFile(logsOutputFile),
                )

                err = errors.Join(
                        config.Provide(container, cfg),

                        // services
                        services.Register(container),

                        di.ProvideAll(container,
                                di.ProvideValue(rootLogger),
                        ),
                )

                return lo.
                        If(err != nil, fmt.Errorf("failed to inject dependencies: %w", err)).
                        Else(nil)</span>
        }
        <span class="cov10" title="3">return cmd</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "context"
        "errors"
        "log/slog"
        "os/signal"
        "time"

        "github.com/gemyago/oke-gateway-api/internal/api/http"
        "github.com/gemyago/oke-gateway-api/internal/api/http/server"
        "github.com/gemyago/oke-gateway-api/internal/diag"
        "github.com/gemyago/oke-gateway-api/internal/services"
        "github.com/spf13/cobra"
        "go.uber.org/dig"
        "golang.org/x/sys/unix"
)

type startServerParams struct {
        dig.In `ignore-unexported:"true"`

        RootLogger *slog.Logger

        HTTPServer *server.HTTPServer

        *services.ShutdownHooks

        noop bool
}

func startServer(params startServerParams) error <span class="cov1" title="1">{
        rootLogger := params.RootLogger
        httpServer := params.HTTPServer
        rootCtx := context.Background()

        shutdown := func() error </span><span class="cov1" title="1">{
                rootLogger.InfoContext(rootCtx, "Trying to shut down gracefully")
                ts := time.Now()

                err := params.ShutdownHooks.PerformShutdown(rootCtx)
                if err != nil </span><span class="cov0" title="0">{
                        rootLogger.ErrorContext(rootCtx, "Failed to shut down gracefully", diag.ErrAttr(err))
                }</span>

                <span class="cov1" title="1">rootLogger.InfoContext(rootCtx, "Service stopped",
                        slog.Duration("duration", time.Since(ts)),
                )
                return err</span>
        }

        <span class="cov1" title="1">signalCtx, cancel := signal.NotifyContext(rootCtx, unix.SIGINT, unix.SIGTERM)
        defer cancel()

        const startedComponents = 2
        startupErrors := make(chan error, startedComponents)
        go func() </span><span class="cov1" title="1">{
                if params.noop </span><span class="cov1" title="1">{
                        rootLogger.InfoContext(signalCtx, "NOOP: Starting http server")
                        startupErrors &lt;- nil
                        return
                }</span>
                <span class="cov0" title="0">startupErrors &lt;- httpServer.Start(signalCtx)</span>
        }()

        <span class="cov1" title="1">var startupErr error
        select </span>{
        case startupErr = &lt;-startupErrors:<span class="cov1" title="1">
                if startupErr != nil </span><span class="cov0" title="0">{
                        rootLogger.ErrorContext(rootCtx, "Server startup failed", "err", startupErr)
                }</span>
        case &lt;-signalCtx.Done():<span class="cov0" title="0"></span> // coverage-ignore
                // We will attempt to shut down in both cases
                // so doing it once on a next line
        }
        <span class="cov1" title="1">return errors.Join(startupErr, shutdown())</span>
}

func newStartServerCmd(container *dig.Container) *cobra.Command <span class="cov10" title="3">{
        cmd := &amp;cobra.Command{
                Use:   "start",
                Short: "Start the server",
        }
        noop := false
        cmd.Flags().BoolVar(
                &amp;noop,
                "noop",
                false,
                "Pretend to start.",
        )
        cmd.PreRunE = func(_ *cobra.Command, _ []string) error </span><span class="cov1" title="1">{
                return errors.Join(
                        server.Register(container),
                        http.Register(container),
                )
        }</span>
        <span class="cov10" title="3">cmd.RunE = func(_ *cobra.Command, _ []string) error </span><span class="cov1" title="1">{
                return container.Invoke(func(params startServerParams) error </span><span class="cov1" title="1">{
                        params.noop = noop
                        return startServer(params)
                }</span>)
        }
        <span class="cov10" title="3">return cmd</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package http

import (
        "encoding/json"
        "io"
        "log/slog"
        "net/http"

        "github.com/gemyago/oke-gateway-api/internal/diag"
        "go.uber.org/dig"
)

type EchoResponse struct {
        RequestHeaders http.Header `json:"requestHeaders"`
        RequestBody    string      `json:"requestBody"`
        RequestMethod  string      `json:"requestMethod"`
        RequestURL     string      `json:"requestURL"`
        Host           string      `json:"host"`
}

type RootHandlerDeps struct {
        dig.In

        RootLogger *slog.Logger

        Mode string `name:"config.httpServer.mode"`
}

const (
        HandlerModeEcho    = "echo"
        HandlerModeStealth = "stealth"
)

func NewRootHandler(deps RootHandlerDeps) http.Handler <span class="cov10" title="5">{
        logger := deps.RootLogger.WithGroup("http-handler")

        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="4">{
                if deps.Mode == HandlerModeStealth </span><span class="cov1" title="1">{
                        w.WriteHeader(http.StatusNotFound)
                        return
                }</span>
                <span class="cov7" title="3">body, err := io.ReadAll(r.Body)
                if err != nil </span><span class="cov1" title="1">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov4" title="2">w.WriteHeader(http.StatusOK)
                err = json.NewEncoder(w).Encode(EchoResponse{
                        RequestHeaders: r.Header,
                        RequestBody:    string(body),
                        RequestMethod:  r.Method,
                        RequestURL:     r.URL.String(),
                        Host:           r.Host,
                })
                if err != nil </span><span class="cov1" title="1">{
                        // We can just log at this point, as we've already written a response
                        logger.Error("failed to encode response", diag.ErrAttr(err))
                        return
                }</span>
        })
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package middleware

import "net/http"

type Middleware func(http.Handler) http.Handler

func Chain(middlewares ...Middleware) func(http.Handler) http.Handler <span class="cov6" title="5">{
        return func(h http.Handler) http.Handler </span><span class="cov6" title="5">{
                for i := len(middlewares) - 1; i &gt;= 0; i-- </span><span class="cov10" title="15">{
                        h = middlewares[i](h)
                }</span>
                <span class="cov6" title="5">return h</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package middleware

import (
        "errors"
        "log/slog"
        "net/http"
        "runtime/debug"
)

// NewRecovererMiddleware creates a middleware that will handle panics
// log them and respond with 500 to client. This should be the last in a chain.
func NewRecovererMiddleware(rootLogger *slog.Logger) Middleware <span class="cov10" title="7">{
        return func(next http.Handler) http.Handler </span><span class="cov10" title="7">{
                fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov7" title="4">{
                        defer func() </span><span class="cov7" title="4">{
                                if rvr := recover(); rvr != nil </span><span class="cov4" title="2">{
                                        if err, ok := rvr.(error); ok &amp;&amp; errors.Is(err, http.ErrAbortHandler) </span><span class="cov1" title="1">{
                                                rootLogger.InfoContext(r.Context(), "Request aborted")
                                                return
                                        }</span>
                                        <span class="cov1" title="1">rootLogger.ErrorContext(
                                                r.Context(),
                                                "Unhandled panic",
                                                slog.Any("panic", rvr),
                                                slog.String("stack", string(debug.Stack())),
                                        )
                                        // TODO: Do not write header if already written
                                        w.WriteHeader(http.StatusInternalServerError)</span>
                                }
                        }()

                        <span class="cov7" title="4">next.ServeHTTP(w, r)</span>
                }

                <span class="cov10" title="7">return http.HandlerFunc(fn)</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package middleware

import (
        "log/slog"
        "net/http"

        "github.com/gemyago/oke-gateway-api/internal/diag"
        "github.com/gofrs/uuid/v5"
)

type TracingMiddlewareCfg struct {
        generateUUID func() string
}

func NewTracingMiddlewareCfg() *TracingMiddlewareCfg <span class="cov10" title="6">{
        return &amp;TracingMiddlewareCfg{
                generateUUID: func() string </span><span class="cov4" title="2">{
                        return uuid.Must(uuid.NewV4()).String()
                }</span>,
        }
}

func NewTracingMiddleware(cfg *TracingMiddlewareCfg) Middleware <span class="cov10" title="6">{
        generateUUID := cfg.generateUUID
        return func(next http.Handler) http.Handler </span><span class="cov10" title="6">{
                return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) </span><span class="cov6" title="3">{
                        correlationID := req.Header.Get("x-correlation-id")
                        if correlationID == "" </span><span class="cov4" title="2">{
                                correlationID = generateUUID()
                        }</span>
                        <span class="cov6" title="3">logAttributes := diag.GetLogAttributesFromContext(req.Context())
                        logAttributes.CorrelationID = slog.StringValue(correlationID)
                        nextCtx := diag.SetLogAttributesToContext(req.Context(), logAttributes)
                        next.ServeHTTP(w, req.WithContext(nextCtx))</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package http

import (
        "errors"

        "github.com/gemyago/oke-gateway-api/internal/di"
        "go.uber.org/dig"
)

func Register(container *dig.Container) error <span class="cov8" title="1">{
        return errors.Join(
                di.ProvideAll(container,
                        NewRootHandler,
                ),
        )
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package server

import (
        "github.com/gemyago/oke-gateway-api/internal/di"
        "go.uber.org/dig"
)

func Register(container *dig.Container) error <span class="cov8" title="1">{
        return di.ProvideAll(
                container,
                NewHTTPServer,
        )
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package server

import (
        "context"
        "fmt"
        "log/slog"
        "net/http"
        "time"

        "github.com/gemyago/oke-gateway-api/internal/api/http/middleware"
        "github.com/gemyago/oke-gateway-api/internal/services"
        sloghttp "github.com/samber/slog-http"
        "go.uber.org/dig"
)

type HTTPServerDeps struct {
        dig.In

        RootLogger *slog.Logger

        // config
        Host              string        `name:"config.httpServer.host"`
        Port              int           `name:"config.httpServer.port"`
        IdleTimeout       time.Duration `name:"config.httpServer.idleTimeout"`
        ReadHeaderTimeout time.Duration `name:"config.httpServer.readHeaderTimeout"`
        ReadTimeout       time.Duration `name:"config.httpServer.readTimeout"`
        WriteTimeout      time.Duration `name:"config.httpServer.writeTimeout"`
        AccessLogsLevel   string        `name:"config.httpServer.accessLogsLevel"`
        Mode              string        `name:"config.httpServer.mode"`

        // handler
        Handler http.Handler

        // services
        *services.ShutdownHooks
}

type HTTPServer struct {
        httpSrv *http.Server
        deps    HTTPServerDeps
        logger  *slog.Logger
}

func (srv *HTTPServer) Start(ctx context.Context) error <span class="cov1" title="1">{
        srv.logger.InfoContext(ctx, "Starting http listener",
                slog.String("addr", srv.httpSrv.Addr),
                slog.String("idleTimeout", srv.deps.IdleTimeout.String()),
                slog.String("readHeaderTimeout", srv.deps.ReadHeaderTimeout.String()),
                slog.String("readTimeout", srv.deps.ReadTimeout.String()),
                slog.String("writeTimeout", srv.deps.WriteTimeout.String()),
                slog.String("accessLogsLevel", srv.deps.AccessLogsLevel),
                slog.String("mode", srv.deps.Mode),
        )
        return srv.httpSrv.ListenAndServe()
}</span>

func buildMiddlewareChain(deps HTTPServerDeps) http.Handler <span class="cov10" title="5">{
        defaultLogLevel := slog.LevelInfo
        clientErrorLevel := slog.LevelWarn
        serverErrorLevel := slog.LevelError

        if deps.AccessLogsLevel != "" </span><span class="cov4" title="2">{
                if err := defaultLogLevel.UnmarshalText([]byte(deps.AccessLogsLevel)); err != nil </span><span class="cov1" title="1">{
                        panic(fmt.Errorf("failed to unmarshal access logs level: %w", err))</span>
                }
                <span class="cov1" title="1">clientErrorLevel = defaultLogLevel
                serverErrorLevel = defaultLogLevel</span>
        }

        // Router wire-up
        <span class="cov8" title="4">chain := middleware.Chain(
                middleware.NewTracingMiddleware(middleware.NewTracingMiddlewareCfg()),
                sloghttp.NewWithConfig(deps.RootLogger, sloghttp.Config{
                        DefaultLevel:     defaultLogLevel,
                        ClientErrorLevel: clientErrorLevel,
                        ServerErrorLevel: serverErrorLevel,

                        WithUserAgent:      true,
                        WithRequestID:      false, // We handle it ourselves (tracing middleware)
                        WithRequestHeader:  true,
                        WithResponseHeader: true,
                        WithSpanID:         true,
                        WithTraceID:        true,
                }),
                middleware.NewRecovererMiddleware(deps.RootLogger),
        )
        return chain(deps.Handler)</span>
}

// NewHTTPServer constructor factory for general use *http.Server.
func NewHTTPServer(deps HTTPServerDeps) *HTTPServer <span class="cov4" title="2">{
        address := fmt.Sprintf("%s:%d", deps.Host, deps.Port)
        srv := &amp;http.Server{
                Addr:              address,
                IdleTimeout:       deps.IdleTimeout,
                ReadHeaderTimeout: deps.ReadHeaderTimeout,
                ReadTimeout:       deps.ReadTimeout,
                WriteTimeout:      deps.WriteTimeout,
                Handler:           buildMiddlewareChain(deps),
                ErrorLog:          slog.NewLogLogger(deps.RootLogger.Handler(), slog.LevelError),
        }

        deps.ShutdownHooks.Register("http-server", srv.Shutdown)

        return &amp;HTTPServer{
                deps:    deps,
                httpSrv: srv,
                logger:  deps.RootLogger.WithGroup("http-server"),
        }
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package app

import "fmt"

type resourceStatusError struct {
        conditionType string
        reason        string
        message       string
        cause         error
}

func (e resourceStatusError) Error() string <span class="cov10" title="5">{
        if e.cause != nil </span><span class="cov1" title="1">{
                return fmt.Sprintf(
                        "resourceStatusError: type=%s, reason=%s, message=%s, cause=%s",
                        e.conditionType, e.reason, e.message, e.cause)
        }</span>
        <span class="cov8" title="4">return fmt.Sprintf("resourceStatusError: type=%s, reason=%s, message=%s", e.conditionType, e.reason, e.message)</span>
}

type ReconcileError struct {
        message   string
        retriable bool
        cause     error
}

func (e ReconcileError) Error() string <span class="cov7" title="3">{
        if e.cause != nil </span><span class="cov1" title="1">{
                return fmt.Sprintf("reconcileError: retriable=%t, message=%s, cause=%s", e.retriable, e.message, e.cause)
        }</span>
        <span class="cov4" title="2">return fmt.Sprintf("reconcileError: retriable=%t, message=%s", e.retriable, e.message)</span>
}

func (e ReconcileError) IsRetriable() bool <span class="cov10" title="5">{
        return e.retriable
}</span>

func NewReconcileError(message string, retriable bool) *ReconcileError <span class="cov8" title="4">{
        return &amp;ReconcileError{
                retriable: retriable,
                message:   message,
        }
}</span>

func NewReconcileErrorWithCause(message string, retriable bool, cause error) *ReconcileError <span class="cov7" title="3">{
        return &amp;ReconcileError{
                retriable: retriable,
                message:   message,
                cause:     cause,
        }
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package app

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "strconv"

        "go.uber.org/dig"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
)

// GatewayController is a simple controller that watches Gateway resources.
type GatewayController struct {
        client         k8sClient // Reusing the k8sClient interface defined in gatewayclass_controller.go
        logger         *slog.Logger
        resourcesModel resourcesModel // Add resourcesModel field
        gatewayModel   gatewayModel
}

// GatewayControllerDeps contains the dependencies for the GatewayController.
type GatewayControllerDeps struct {
        dig.In

        RootLogger     *slog.Logger
        K8sClient      k8sClient
        ResourcesModel resourcesModel // Add ResourcesModel dependency
        GatewayModel   gatewayModel
}

// NewGatewayController creates a new GatewayController.
func NewGatewayController(deps GatewayControllerDeps) *GatewayController <span class="cov10" title="10">{
        return &amp;GatewayController{
                client:         deps.K8sClient,
                logger:         deps.RootLogger.WithGroup("gateway-controller"),
                resourcesModel: deps.ResourcesModel, // Initialize resourcesModel
                gatewayModel:   deps.GatewayModel,
        }
}</span>

// processResourceError handles errors from resource programming operations.
// It checks if the error is a resourceStatusError and updates the condition accordingly.
// Returns a reconcile result and error to be returned from the Reconcile method.
func (r *GatewayController) processResourceError(
        ctx context.Context,
        err error,
        gateway *gatewayv1.Gateway,
) (reconcile.Result, error) <span class="cov7" title="5">{
        var reasonErr *resourceStatusError
        if errors.As(err, &amp;reasonErr) </span><span class="cov5" title="3">{
                if err = r.resourcesModel.setCondition(ctx, setConditionParams{
                        resource:      gateway,
                        conditions:    &amp;gateway.Status.Conditions,
                        conditionType: reasonErr.conditionType,
                        status:        v1.ConditionFalse,
                        reason:        reasonErr.reason,
                        message:       reasonErr.message,
                }); err != nil </span><span class="cov1" title="1">{
                        return reconcile.Result{}, fmt.Errorf("failed to set condition for Gateway %s: %w", gateway.Name, err)
                }</span>
                <span class="cov3" title="2">r.logger.WarnContext(ctx, "Failed to program gateway",
                        slog.String("gateway", gateway.GetName()),
                        slog.String("reason", reasonErr.Error()),
                )
                return reconcile.Result{}, nil</span>
        }
        <span class="cov3" title="2">return reconcile.Result{}, fmt.Errorf("failed to program Gateway %s: %w", gateway.Name, err)</span>
}

// Reconcile implements the reconcile.Reconciler interface for Gateway resources.
func (r *GatewayController) Reconcile(ctx context.Context, req reconcile.Request) (reconcile.Result, error) <span class="cov9" title="9">{
        r.logger.InfoContext(ctx, fmt.Sprintf("Processing reconciliation for Gateway %s", req.NamespacedName))
        var data resolvedGatewayDetails
        relevant, err := r.gatewayModel.resolveReconcileRequest(ctx, req, &amp;data)
        if err != nil </span><span class="cov5" title="3">{
                return r.processResourceError(ctx, err, &amp;data.gateway)
        }</span>
        <span class="cov8" title="6">if !relevant </span><span class="cov1" title="1">{
                return reconcile.Result{}, nil
        }</span>

        <span class="cov7" title="5">if !r.resourcesModel.isConditionSet(
                &amp;data.gateway,
                data.gateway.Status.Conditions,
                string(gatewayv1.GatewayConditionAccepted),
        ) </span><span class="cov1" title="1">{
                if err = r.resourcesModel.setCondition(ctx, setConditionParams{
                        resource:      &amp;data.gateway,
                        conditions:    &amp;data.gateway.Status.Conditions,
                        conditionType: string(gatewayv1.GatewayConditionAccepted),
                        status:        v1.ConditionTrue,
                        reason:        string(gatewayv1.GatewayReasonAccepted),
                        message:       fmt.Sprintf("Gateway %s accepted by %s", data.gateway.Name, ControllerClassName),
                }); err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, fmt.Errorf("failed to set accepted condition for Gateway %s: %w", req.NamespacedName, err)
                }</span>
        }

        <span class="cov7" title="5">if !r.resourcesModel.isConditionSet(
                &amp;data.gateway,
                data.gateway.Status.Conditions,
                string(gatewayv1.GatewayConditionProgrammed),
        ) </span><span class="cov6" title="4">{
                r.logger.DebugContext(ctx, "Programming gateway",
                        slog.Any("req", req),
                        slog.Any("gateway", data.gateway),
                        slog.Any("gatewayClass", data.gatewayClass),
                        slog.Any("config", data.config),
                )

                if err = r.gatewayModel.programGateway(ctx, &amp;data); err != nil </span><span class="cov3" title="2">{
                        return r.processResourceError(ctx, err, &amp;data.gateway)
                }</span>

                <span class="cov3" title="2">if err = r.resourcesModel.setCondition(ctx, setConditionParams{
                        resource:      &amp;data.gateway,
                        conditions:    &amp;data.gateway.Status.Conditions,
                        conditionType: string(gatewayv1.GatewayConditionProgrammed),
                        status:        v1.ConditionTrue,
                        reason:        string(gatewayv1.GatewayConditionProgrammed),
                        message:       fmt.Sprintf("Gateway %s programmed by %s", data.gateway.Name, ControllerClassName),
                }); err != nil </span><span class="cov1" title="1">{
                        return reconcile.Result{}, fmt.Errorf("failed to set accepted condition for Gateway %s: %w", req.NamespacedName, err)
                }</span>

                <span class="cov1" title="1">r.logger.InfoContext(ctx,
                        "Successfully set Programmed condition for Gateway",
                        slog.String("gateway", req.NamespacedName.String()),
                )</span>
        } else<span class="cov1" title="1"> {
                r.logger.DebugContext(ctx,
                        "Programmed condition already set for this Gateway generation",
                        slog.String("gateway", req.NamespacedName.String()),
                        slog.String("generation", strconv.FormatInt(data.gateway.Generation, 10)),
                )
        }</span>

        <span class="cov3" title="2">return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package app

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/gemyago/oke-gateway-api/internal/types"
        "github.com/oracle/oci-go-sdk/v65/loadbalancer"
        "go.uber.org/dig"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        apitypes "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
)

type resolvedGatewayDetails struct {
        gateway      gatewayv1.Gateway
        gatewayClass gatewayv1.GatewayClass
        config       types.GatewayConfig
}

type gatewayModel interface {
        // resolveReconcileRequest will resolve related resources for the reconcile request.
        // If returns false if the request is not relevant for this controller.
        // It returns true if the request is relevant for this controller.
        // It may return an error if there was error resolving the request.
        // If error happens, it may not be always known if the request is relevant.
        resolveReconcileRequest(
                ctx context.Context,
                req reconcile.Request,
                receiver *resolvedGatewayDetails,
        ) (bool, error)

        programGateway(ctx context.Context, data *resolvedGatewayDetails) error
}

type gatewayModelImpl struct {
        client               k8sClient
        logger               *slog.Logger
        ociClient            ociLoadBalancerClient
        ociLoadBalancerModel ociLoadBalancerModel
}

func (m *gatewayModelImpl) resolveReconcileRequest(
        ctx context.Context,
        req reconcile.Request,
        receiver *resolvedGatewayDetails,
) (bool, error) <span class="cov8" title="9">{
        if err := m.client.Get(ctx, req.NamespacedName, &amp;receiver.gateway); err != nil </span><span class="cov3" title="2">{
                if apierrors.IsNotFound(err) </span><span class="cov1" title="1">{
                        m.logger.InfoContext(ctx, fmt.Sprintf("Gateway %s not found", req.NamespacedName))
                        // TODO: We may need to handle deprovisioning, maybe via finalizer?
                        return false, nil
                }</span>
                <span class="cov1" title="1">return false, fmt.Errorf("failed to get Gateway %s: %w", req.NamespacedName, err)</span>
        }

        <span class="cov7" title="7">if err := m.client.Get(ctx, apitypes.NamespacedName{
                Name: string(receiver.gateway.Spec.GatewayClassName),
        }, &amp;receiver.gatewayClass); err != nil </span><span class="cov3" title="2">{
                if apierrors.IsNotFound(err) </span><span class="cov1" title="1">{
                        m.logger.InfoContext(ctx, fmt.Sprintf("GatewayClass %s not found", receiver.gateway.Spec.GatewayClassName))
                        return false, nil
                }</span>
                <span class="cov1" title="1">return false, fmt.Errorf("failed to get GatewayClass %s: %w", receiver.gateway.Spec.GatewayClassName, err)</span>
        }

        <span class="cov6" title="5">if receiver.gatewayClass.Spec.ControllerName != gatewayv1.GatewayController(ControllerClassName) </span><span class="cov1" title="1">{
                m.logger.InfoContext(
                        ctx,
                        fmt.Sprintf("GatewayClass %s is not managed by this controller", receiver.gateway.Spec.GatewayClassName),
                )
                return false, nil
        }</span>

        <span class="cov5" title="4">if receiver.gateway.Spec.Infrastructure == nil || receiver.gateway.Spec.Infrastructure.ParametersRef == nil </span><span class="cov1" title="1">{
                return false, &amp;resourceStatusError{
                        conditionType: string(gatewayv1.GatewayConditionAccepted),
                        reason:        string(gatewayv1.GatewayReasonInvalidParameters),
                        message:       "spec.infrastructure is missing parametersRef",
                }
        }</span>

        <span class="cov4" title="3">configName := apitypes.NamespacedName{
                Namespace: receiver.gateway.Namespace,
                Name:      receiver.gateway.Spec.Infrastructure.ParametersRef.Name,
        }

        if err := m.client.Get(ctx, configName, &amp;receiver.config); err != nil </span><span class="cov3" title="2">{
                if apierrors.IsNotFound(err) </span><span class="cov1" title="1">{
                        return false, &amp;resourceStatusError{
                                conditionType: string(gatewayv1.GatewayConditionAccepted),
                                reason:        string(gatewayv1.GatewayReasonInvalidParameters),
                                message:       "spec.infrastructure is pointing to a non-existent GatewayConfig",
                        }
                }</span>
                <span class="cov1" title="1">return false, fmt.Errorf("failed to get GatewayConfig %s: %w", configName, err)</span>
        }

        // TODO: Make sure config is complete

        <span class="cov1" title="1">return true, nil</span>
}

func (m *gatewayModelImpl) programGateway(ctx context.Context, data *resolvedGatewayDetails) error <span class="cov5" title="4">{
        loadBalancerID := data.config.Spec.LoadBalancerID
        m.logger.DebugContext(ctx, "Fetching OCI Load Balancer details",
                slog.String("loadBalancerId", loadBalancerID),
        )

        request := loadbalancer.GetLoadBalancerRequest{
                LoadBalancerId: &amp;loadBalancerID,
        }

        response, err := m.ociClient.GetLoadBalancer(ctx, request)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to get OCI Load Balancer %s: %w", loadBalancerID, err)
        }</span>

        <span class="cov4" title="3">m.logger.DebugContext(ctx, "Successfully retrieved OCI Load Balancer details",
                slog.Any("loadBalancer", response.LoadBalancer),
        )

        defaultBackendSet, err := m.ociLoadBalancerModel.reconcileDefaultBackendSet(ctx, reconcileDefaultBackendParams{
                loadBalancerID:   loadBalancerID,
                knownBackendSets: response.LoadBalancer.BackendSets,
                gateway:          &amp;data.gateway,
        })
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to program default backend set: %w", err)
        }</span>

        <span class="cov3" title="2">for _, listenerSpec := range data.gateway.Spec.Listeners </span><span class="cov4" title="3">{
                // TODO: Support listener with hostname

                _, err = m.ociLoadBalancerModel.reconcileHTTPListener(ctx, reconcileHTTPListenerParams{
                        loadBalancerID:        loadBalancerID,
                        defaultBackendSetName: *defaultBackendSet.Name,
                        knownListeners:        response.LoadBalancer.Listeners,
                        listenerSpec:          &amp;listenerSpec,
                })
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("failed to program listener %s: %w", listenerSpec.Name, err)
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

type gatewayModelDeps struct {
        dig.In

        K8sClient            k8sClient
        RootLogger           *slog.Logger
        OciClient            ociLoadBalancerClient
        OciLoadBalancerModel ociLoadBalancerModel
}

func newGatewayModel(deps gatewayModelDeps) gatewayModel <span class="cov10" title="14">{
        return &amp;gatewayModelImpl{
                client:               deps.K8sClient,
                logger:               deps.RootLogger.WithGroup("gateway-model"),
                ociClient:            deps.OciClient,
                ociLoadBalancerModel: deps.OciLoadBalancerModel,
        }
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package app

import (
        "context"
        "fmt"
        "log/slog"

        "go.uber.org/dig"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
)

// GatewayClassController is a simple controller that watches GatewayClass resources.
type GatewayClassController struct {
        client         k8sClient
        logger         *slog.Logger
        resourcesModel resourcesModel
}

// GatewayClassControllerDeps contains the dependencies for the GatewayClassController.
type GatewayClassControllerDeps struct {
        dig.In

        RootLogger     *slog.Logger
        K8sClient      k8sClient
        ResourcesModel resourcesModel
}

// NewGatewayClassController creates a new GatewayClassController.
func NewGatewayClassController(deps GatewayClassControllerDeps) *GatewayClassController <span class="cov10" title="7">{
        return &amp;GatewayClassController{
                client:         deps.K8sClient,
                logger:         deps.RootLogger.WithGroup("gateway-class-controller"),
                resourcesModel: deps.ResourcesModel,
        }
}</span>

// Reconcile implements the reconcile.Reconciler interface.
func (r *GatewayClassController) Reconcile(ctx context.Context, req reconcile.Request) (reconcile.Result, error) <span class="cov9" title="6">{
        var gatewayClass gatewayv1.GatewayClass
        if err := r.client.Get(ctx, req.NamespacedName, &amp;gatewayClass); err != nil </span><span class="cov4" title="2">{
                if errors.IsNotFound(err) </span><span class="cov1" title="1">{
                        r.logger.DebugContext(ctx, fmt.Sprintf("GatewayClass not present: %s", req.NamespacedName))
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov1" title="1">return reconcile.Result{}, fmt.Errorf("failed to get GatewayClass %s: %w", req.NamespacedName, err)</span>
        }

        // Check if the ControllerName matches the one we are responsible for
        <span class="cov7" title="4">if gatewayClass.Spec.ControllerName != ControllerClassName </span><span class="cov1" title="1">{
                r.logger.InfoContext(ctx,
                        "Ignoring GatewayClass because controllerName does not match",
                        slog.String("gatewayClass", req.NamespacedName.String()),
                        slog.String("expectedControllerName", ControllerClassName),
                        slog.String("actualControllerName", string(gatewayClass.Spec.ControllerName)),
                )
                return reconcile.Result{}, nil // Ignore this GatewayClass
        }</span>

        <span class="cov6" title="3">r.logger.InfoContext(ctx, fmt.Sprintf("Processing reconciliation for GatewayClass %s", req.NamespacedName))

        // Check if the GatewayClass is already in the desired state
        if r.resourcesModel.isConditionSet(
                &amp;gatewayClass,
                gatewayClass.Status.Conditions,
                string(gatewayv1.GatewayClassConditionStatusAccepted),
        ) </span><span class="cov1" title="1">{
                r.logger.DebugContext(ctx, "GatewayClass is already accepted",
                        slog.String("gatewayClass", req.NamespacedName.String()),
                )
                return reconcile.Result{}, nil // Already in desired state
        }</span>

        <span class="cov4" title="2">r.logger.DebugContext(ctx, "GatewayClass reconciliation details",
                slog.Any("req", req),
                slog.Any("gatewayClass", gatewayClass),
        )

        if err := r.resourcesModel.setCondition(ctx, setConditionParams{
                resource:      &amp;gatewayClass,
                conditions:    &amp;gatewayClass.Status.Conditions,
                conditionType: string(gatewayv1.GatewayClassConditionStatusAccepted),
                status:        metav1.ConditionTrue,
                reason:        string(gatewayv1.GatewayClassReasonAccepted),
                message:       fmt.Sprintf("GatewayClass %s is accepted by %s", gatewayClass.Name, ControllerClassName),
        }); err != nil </span><span class="cov1" title="1">{
                return reconcile.Result{},
                        fmt.Errorf("failed to set accepted condition for GatewayClass %s: %w",
                                req.NamespacedName,
                                err)
        }</span>

        <span class="cov1" title="1">r.logger.InfoContext(ctx,
                "Successfully reconciled and accepted GatewayClass",
                slog.Any("gatewayClass", req.NamespacedName),
        )
        return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package app

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/gemyago/oke-gateway-api/internal/types"
        "github.com/oracle/oci-go-sdk/v65/loadbalancer"
        "github.com/samber/lo"
        "go.uber.org/dig"
        discoveryv1 "k8s.io/api/discovery/v1"
        client "sigs.k8s.io/controller-runtime/pkg/client"
        gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
)

type syncRouteBackendEndpointsParams struct {
        httpRoute gatewayv1.HTTPRoute
        config    types.GatewayConfig
}

type syncRouteBackendRuleEndpointsParams struct {
        httpRoute gatewayv1.HTTPRoute
        config    types.GatewayConfig
        ruleIndex int
}

// httpBackendModel defines the interface for managing OCI backend sets based on HTTPRoute definitions.
type httpBackendModel interface {
        // syncRouteBackendEndpoints synchronizes the OCI Load Balancer Backend Sets associated with the
        // provided HTTPRoute, ensuring they contain the correct set of ready endpoints
        // derived from the referenced Kubernetes Services' EndpointSlices.
        syncRouteBackendEndpoints(ctx context.Context, params syncRouteBackendEndpointsParams) error

        // syncRouteBackendRuleEndpoints synchronizes the OCI Load Balancer Backend Sets associated with the
        // single rule of the provided HTTPRoute.
        syncRouteBackendRuleEndpoints(ctx context.Context, params syncRouteBackendRuleEndpointsParams) error
}

type httpBackendModelImpl struct {
        logger              *slog.Logger
        k8sClient           k8sClient
        ociClient           ociLoadBalancerClient
        workRequestsWatcher workRequestsWatcher

        // Used to allow mocking own methods in tests
        self httpBackendModel
}

func (m *httpBackendModelImpl) syncRouteBackendEndpoints(
        ctx context.Context,
        params syncRouteBackendEndpointsParams,
) error <span class="cov3" title="2">{
        m.logger.InfoContext(ctx, "Syncing backend endpoints",
                slog.String("httpRoute", params.httpRoute.Name),
                slog.String("config", params.config.Name),
        )

        for index := range params.httpRoute.Spec.Rules </span><span class="cov5" title="4">{
                if err := m.self.syncRouteBackendRuleEndpoints(ctx, syncRouteBackendRuleEndpointsParams{
                        httpRoute: params.httpRoute,
                        config:    params.config,
                        ruleIndex: index,
                }); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("failed to sync route backend endpoints for rule %d: %w", index, err)
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

func (m *httpBackendModelImpl) syncRouteBackendRuleEndpoints(
        ctx context.Context,
        params syncRouteBackendRuleEndpointsParams,
) error <span class="cov3" title="2">{
        rule := params.httpRoute.Spec.Rules[params.ruleIndex]

        backendSetName := backendSetName(params.httpRoute, rule, params.ruleIndex)
        var ruleBackends []loadbalancer.BackendDetails
        firstRefPort := int32(*rule.BackendRefs[0].BackendObjectReference.Port)

        drainingCount := 0
        for _, backendRef := range rule.BackendRefs </span><span class="cov4" title="3">{
                var endpointSlices discoveryv1.EndpointSliceList

                // TODO: Paginate?
                if err := m.k8sClient.List(ctx, &amp;endpointSlices, client.MatchingLabels{
                        discoveryv1.LabelServiceName: string(backendRef.BackendObjectReference.Name),
                }); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to list endpoint slices for backend %s: %w", backendRef.BackendObjectReference.Name, err)
                }</span>

                <span class="cov4" title="3">refPort := int32(*backendRef.BackendObjectReference.Port)

                refBackends := make([]loadbalancer.BackendDetails, 0, len(endpointSlices.Items))
                for _, endpointSlice := range endpointSlices.Items </span><span class="cov4" title="3">{
                        for _, endpoint := range endpointSlice.Endpoints </span><span class="cov10" title="17">{
                                // Skip endpoint if it's explicitly marked as not ready
                                if endpoint.Conditions.Ready != nil &amp;&amp; !*endpoint.Conditions.Ready </span><span class="cov3" title="2">{
                                        continue</span>
                                }

                                // Determine if the backend should be marked for draining
                                <span class="cov9" title="15">isDraining := endpoint.Conditions.Terminating != nil &amp;&amp; *endpoint.Conditions.Terminating

                                if isDraining </span><span class="cov3" title="2">{
                                        m.logger.DebugContext(ctx, "Draining endpoint",
                                                slog.String("endpoint", endpoint.Addresses[0]),
                                        )
                                        drainingCount++
                                }</span>

                                <span class="cov9" title="15">refBackends = append(refBackends, loadbalancer.BackendDetails{
                                        Port:      lo.ToPtr(int(refPort)),
                                        IpAddress: &amp;endpoint.Addresses[0],
                                        Drain:     lo.ToPtr(isDraining),
                                })</span>
                        }
                }

                <span class="cov4" title="3">ruleBackends = append(ruleBackends, refBackends...)</span>
        }

        <span class="cov3" title="2">m.logger.InfoContext(ctx, "Syncing backend endpoints for rule",
                slog.Int("ruleIndex", params.ruleIndex),
                slog.String("httpRoute", params.httpRoute.Name),
                slog.String("backendSetName", backendSetName),
                slog.Int("ruleBackends", len(ruleBackends)),
                slog.Int("drainingBackends", drainingCount),
        )

        ociBackendSet, err := m.ociClient.UpdateBackendSet(ctx, loadbalancer.UpdateBackendSetRequest{
                LoadBalancerId: &amp;params.config.Spec.LoadBalancerID,
                BackendSetName: &amp;backendSetName,
                UpdateBackendSetDetails: loadbalancer.UpdateBackendSetDetails{
                        Backends: ruleBackends,

                        // TODO: Better fetch the HC from existing backend set
                        // route reconciliation is managing it
                        Policy: lo.ToPtr("ROUND_ROBIN"),
                        HealthChecker: &amp;loadbalancer.HealthCheckerDetails{
                                Protocol: lo.ToPtr("TCP"),
                                Port:     lo.ToPtr(int(firstRefPort)),
                        },
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update backend set %s: %w", backendSetName, err)
        }</span>

        <span class="cov3" title="2">err = m.workRequestsWatcher.WaitFor(ctx, *ociBackendSet.OpcWorkRequestId)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to wait for backend set %s to be updated: %w", backendSetName, err)
        }</span>
        <span class="cov3" title="2">return nil</span>
}

// httpBackendModelDeps contains the dependencies for the HTTPBackendModel.
type httpBackendModelDeps struct {
        dig.In `ignore-unexported:"true"`

        RootLogger            *slog.Logger
        K8sClient             k8sClient
        OciLoadBalancerClient ociLoadBalancerClient
        WorkRequestsWatcher   workRequestsWatcher

        // Used to allow mocking own methods in tests
        self httpBackendModel
}

// newHTTPBackendModel creates a new HTTPBackendModel.
func newHTTPBackendModel(deps httpBackendModelDeps) httpBackendModel <span class="cov6" title="5">{
        model := &amp;httpBackendModelImpl{
                logger:              deps.RootLogger.WithGroup("http-backend-model"),
                k8sClient:           deps.K8sClient,
                ociClient:           deps.OciLoadBalancerClient,
                workRequestsWatcher: deps.WorkRequestsWatcher,
                self:                deps.self,
        }
        model.self = lo.Ternary[httpBackendModel](model.self != nil, model.self, model)
        return model
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package app

import (
        "context"
        "fmt"
        "log/slog"

        "go.uber.org/dig"
        v1 "k8s.io/api/core/v1"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
)

// HTTPRouteController is a simple controller that watches HTTPRoute resources.
type HTTPRouteController struct {
        logger           *slog.Logger
        httpRouteModel   httpRouteModel
        httpBackendModel httpBackendModel
}

// HTTPRouteControllerDeps contains the dependencies for the HTTPRouteController.
type HTTPRouteControllerDeps struct {
        dig.In

        RootLogger       *slog.Logger
        HTTPRouteModel   httpRouteModel
        HTTPBackendModel httpBackendModel
}

// NewHTTPRouteController creates a new HTTPRouteController.
func NewHTTPRouteController(deps HTTPRouteControllerDeps) *HTTPRouteController <span class="cov10" title="11">{
        return &amp;HTTPRouteController{
                logger:           deps.RootLogger.WithGroup("httproute-controller"),
                httpRouteModel:   deps.HTTPRouteModel,
                httpBackendModel: deps.HTTPBackendModel,
        }
}</span>

func (r *HTTPRouteController) performProgramming(
        ctx context.Context,
        resolvedData resolvedRouteDetails,
) error <span class="cov7" title="5">{
        var acceptedRoute *gatewayv1.HTTPRoute
        acceptedRoute, err := r.httpRouteModel.acceptRoute(ctx, resolvedData)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to accept route: %w", err)
        }</span>

        <span class="cov6" title="4">var backendRefs map[string]v1.Service
        backendRefs, err = r.httpRouteModel.resolveBackendRefs(ctx, resolveBackendRefsParams{
                httpRoute: *acceptedRoute,
        })
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to resolve backend refs: %w", err)
        }</span>

        <span class="cov5" title="3">err = r.httpRouteModel.programRoute(ctx, programRouteParams{
                gateway:             resolvedData.gatewayDetails.gateway,
                config:              resolvedData.gatewayDetails.config,
                httpRoute:           *acceptedRoute,
                resolvedBackendRefs: backendRefs,
        })
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to program route: %w", err)
        }</span>

        // Mark the route as programmed by setting the ResolvedRefs condition
        <span class="cov3" title="2">if err = r.httpRouteModel.setProgrammed(ctx, setProgrammedParams{
                gatewayClass: resolvedData.gatewayDetails.gatewayClass,
                gateway:      resolvedData.gatewayDetails.gateway,
                httpRoute:    *acceptedRoute,
                matchedRef:   resolvedData.matchedRef,
        }); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to set programmed status: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Reconcile implements the reconcile.Reconciler interface.
// For now, it just returns a "not implemented" error.
func (r *HTTPRouteController) Reconcile(ctx context.Context, req reconcile.Request) (reconcile.Result, error) <span class="cov9" title="10">{
        r.logger.InfoContext(ctx, fmt.Sprintf("Processing reconciliation for HTTProute %s", req.NamespacedName))

        var resolvedData resolvedRouteDetails
        resolved, err := r.httpRouteModel.resolveRequest(ctx, req, &amp;resolvedData)
        if err != nil </span><span class="cov1" title="1">{
                return reconcile.Result{}, fmt.Errorf("failed to resolve request parent: %w", err)
        }</span>
        <span class="cov9" title="9">if !resolved </span><span class="cov1" title="1">{
                r.logger.InfoContext(ctx, "Ignoring irrelevant HTTPRoute route",
                        slog.String("httpRoute", req.NamespacedName.String()),
                )
                return reconcile.Result{}, nil
        }</span>

        // Check if programming is required based on status
        <span class="cov8" title="8">programmingRequired, err := r.httpRouteModel.isProgrammingRequired(resolvedData)
        if err != nil </span><span class="cov1" title="1">{
                r.logger.ErrorContext(ctx, "Failed to check if programming is required",
                        slog.String("httpRoute", req.NamespacedName.String()),
                )
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="7">if programmingRequired </span><span class="cov7" title="5">{
                err = r.performProgramming(ctx, resolvedData)
                if err != nil </span><span class="cov6" title="4">{
                        return reconcile.Result{}, fmt.Errorf("failed to perform programming: %w", err)
                }</span>
        } else<span class="cov3" title="2"> {
                r.logger.DebugContext(ctx, "HTTPRoute programming not required",
                        slog.String("httpRoute", req.NamespacedName.String()),
                )
        }</span>

        <span class="cov5" title="3">err = r.httpBackendModel.syncRouteBackendEndpoints(ctx, syncRouteBackendEndpointsParams{
                httpRoute: resolvedData.httpRoute,
                config:    resolvedData.gatewayDetails.config,
        })
        if err != nil </span><span class="cov1" title="1">{
                return reconcile.Result{}, fmt.Errorf("failed to sync backend endpoints: %w", err)
        }</span>

        <span class="cov3" title="2">r.logger.InfoContext(ctx, fmt.Sprintf("Reconciled HTTProute %s", req.NamespacedName))

        return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package app

import (
        "context"
        "fmt"
        "log/slog"
        "strconv"

        "github.com/gemyago/oke-gateway-api/internal/types"
        "github.com/oracle/oci-go-sdk/v65/loadbalancer"
        "github.com/samber/lo"
        "go.uber.org/dig"
        v1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/api/meta"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        apitypes "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
)

type resolvedRouteDetails struct {
        gatewayDetails resolvedGatewayDetails
        matchedRef     gatewayv1.ParentReference
        httpRoute      gatewayv1.HTTPRoute
}

type resolveBackendRefsParams struct {
        httpRoute gatewayv1.HTTPRoute
}

type programRouteParams struct {
        gateway             gatewayv1.Gateway
        config              types.GatewayConfig
        httpRoute           gatewayv1.HTTPRoute
        resolvedBackendRefs map[string]v1.Service
}

type setProgrammedParams struct {
        httpRoute    gatewayv1.HTTPRoute
        gatewayClass gatewayv1.GatewayClass
        gateway      gatewayv1.Gateway
        matchedRef   gatewayv1.ParentReference
}

// httpRouteModel defines the interface for managing HTTPRoute resources.
type httpRouteModel interface {
        // resolveRequest resolves the parent details for a given HTTPRoute.
        // It returns true if the request is relevant for this controller and
        // the parent has been resolved.
        resolveRequest(
                ctx context.Context,
                req reconcile.Request,
                receiver *resolvedRouteDetails,
        ) (bool, error)

        // acceptRoute accepts a reconcile request for a given HTTPRoute.
        // It returns updated HTTPRoute with status parents updated.
        acceptRoute(
                ctx context.Context,
                routeDetails resolvedRouteDetails,
        ) (*gatewayv1.HTTPRoute, error)

        // resolveBackendRefs resolves the backend references for a given HTTPRoute.
        // It returns a map of service name to service port. It may update the route status
        // with the ResolvedRefs condition.
        resolveBackendRefs(
                ctx context.Context,
                params resolveBackendRefsParams,
        ) (map[string]v1.Service, error)

        // isProgrammingRequired checks if the route programming is required based on the current state.
        isProgrammingRequired(
                details resolvedRouteDetails,
        ) (bool, error)

        // programRoute programs a given HTTPRoute.
        programRoute(
                ctx context.Context,
                params programRouteParams,
        ) error

        // setProgrammed marks the route as successfully programmed by updating its status.
        setProgrammed(
                ctx context.Context,
                params setProgrammedParams,
        ) error
}

func parentRefEqual(a, b gatewayv1.ParentReference) bool <span class="cov7" title="12">{
        return a.Name == b.Name &amp;&amp;
                lo.FromPtr(a.Namespace) == lo.FromPtr(b.Namespace) &amp;&amp;
                lo.FromPtr(a.Kind) == lo.FromPtr(b.Kind) &amp;&amp;
                lo.FromPtr(a.Group) == lo.FromPtr(b.Group)
}</span>

func backendRefName(
        backendRef gatewayv1.HTTPBackendRef,
        defaultNamespace string,
) apitypes.NamespacedName <span class="cov8" title="14">{
        return apitypes.NamespacedName{
                Name: string(backendRef.BackendObjectReference.Name),
                Namespace: lo.IfF(
                        backendRef.BackendObjectReference.Namespace != nil,
                        func() string </span><span class="cov7" title="11">{ return string(*backendRef.BackendObjectReference.Namespace) }</span>,
                ).Else(defaultNamespace),
        }
}

func backendSetName(httpRoute gatewayv1.HTTPRoute, rule gatewayv1.HTTPRouteRule, ruleIndex int) string <span class="cov5" title="6">{
        ruleName := lo.TernaryF(
                rule.Name != nil,
                func() gatewayv1.SectionName </span><span class="cov2" title="2">{ return *rule.Name }</span>,
                func() gatewayv1.SectionName <span class="cov4" title="4">{ return gatewayv1.SectionName("rt-" + strconv.Itoa(ruleIndex)) }</span>,
        )
        <span class="cov5" title="6">return httpRoute.Name + "-" + string(ruleName)</span>
}

type httpRouteModelImpl struct {
        client       k8sClient
        logger       *slog.Logger
        gatewayModel gatewayModel
        ociLoadBalancerModel
}

func (m *httpRouteModelImpl) resolveRequest(
        ctx context.Context,
        req reconcile.Request,
        receiver *resolvedRouteDetails,
) (bool, error) <span class="cov5" title="6">{
        var httpRoute gatewayv1.HTTPRoute
        if err := m.client.Get(ctx, req.NamespacedName, &amp;httpRoute); err != nil </span><span class="cov2" title="2">{
                if apierrors.IsNotFound(err) </span><span class="cov1" title="1">{
                        m.logger.DebugContext(ctx, "HTTProute not found",
                                slog.String("route", req.NamespacedName.String()),
                        )
                        return false, nil
                }</span>
                <span class="cov1" title="1">return false, err</span>
        }

        <span class="cov4" title="4">var resolvedGatewayData resolvedGatewayDetails
        var matchedRef gatewayv1.ParentReference
        gatewayAccepted := false
        for _, parentRef := range httpRoute.Spec.ParentRefs </span><span class="cov6" title="7">{
                gatewayNamespace := req.NamespacedName.Namespace
                if parentRef.Namespace != nil </span><span class="cov5" title="6">{
                        gatewayNamespace = string(lo.FromPtr(parentRef.Namespace))
                }</span>
                <span class="cov6" title="7">parentName := apitypes.NamespacedName{
                        Namespace: gatewayNamespace,
                        Name:      string(parentRef.Name),
                }
                m.logger.DebugContext(ctx, "Resolving parent for HTTProute",
                        slog.String("parentName", parentName.String()),
                        slog.Any("parentRef", parentRef),
                )
                accepted, err := m.gatewayModel.resolveReconcileRequest(ctx, reconcile.Request{
                        NamespacedName: parentName,
                }, &amp;resolvedGatewayData)
                if err != nil </span><span class="cov1" title="1">{
                        return false, fmt.Errorf("failed to accept reconcile request for gateway %s: %w", parentRef.Name, err)
                }</span>
                <span class="cov5" title="6">if accepted </span><span class="cov2" title="2">{
                        gatewayAccepted = true
                        matchedRef = parentRef
                        break</span>
                }
        }

        <span class="cov3" title="3">if !gatewayAccepted </span><span class="cov1" title="1">{
                m.logger.InfoContext(ctx, "No relevant gateway found for HTTProute",
                        slog.String("route", req.NamespacedName.String()),
                        slog.Int("triedParentRefs", len(httpRoute.Spec.ParentRefs)),
                )
                return false, nil
        }</span>

        <span class="cov2" title="2">m.logger.InfoContext(ctx, "Resolved relevant HTTProute parent",
                slog.String("route", req.NamespacedName.String()),
                slog.String("gateway", resolvedGatewayData.gateway.Name),
        )

        receiver.httpRoute = httpRoute
        receiver.matchedRef = matchedRef
        receiver.gatewayDetails = resolvedGatewayData

        return true, nil</span>
}

// TODO: Some mechanism to check if all parents are accepted
// also if listeners are present

func (m *httpRouteModelImpl) acceptRoute(
        ctx context.Context,
        routeDetails resolvedRouteDetails,
) (*gatewayv1.HTTPRoute, error) <span class="cov5" title="5">{
        parentStatus, parentStatusIndex, found := lo.FindIndexOf(
                routeDetails.httpRoute.Status.Parents,
                func(s gatewayv1.RouteParentStatus) bool </span><span class="cov6" title="9">{
                        return s.ControllerName == routeDetails.gatewayDetails.gatewayClass.Spec.ControllerName
                }</span>)
        <span class="cov5" title="5">if found </span><span class="cov3" title="3">{
                existingCondition := meta.FindStatusCondition(
                        parentStatus.Conditions,
                        string(gatewayv1.RouteConditionAccepted),
                )
                if existingCondition != nil &amp;&amp;
                        existingCondition.ObservedGeneration == routeDetails.httpRoute.Generation &amp;&amp;
                        existingCondition.Status == metav1.ConditionTrue </span><span class="cov1" title="1">{
                        m.logger.DebugContext(ctx, "HTTProute is already accepted",
                                slog.String("route", routeDetails.httpRoute.Name),
                                slog.String("gateway", routeDetails.gatewayDetails.gateway.Name),
                                slog.Int64("generation", existingCondition.ObservedGeneration),
                        )
                        return &amp;routeDetails.httpRoute, nil
                }</span>
        } else<span class="cov2" title="2"> {
                parentStatus = gatewayv1.RouteParentStatus{
                        ParentRef:      routeDetails.matchedRef,
                        ControllerName: routeDetails.gatewayDetails.gatewayClass.Spec.ControllerName,
                }
        }</span>

        <span class="cov4" title="4">httpRoute := routeDetails.httpRoute.DeepCopy()
        meta.SetStatusCondition(&amp;parentStatus.Conditions, metav1.Condition{
                Type:               string(gatewayv1.RouteConditionAccepted),
                Status:             metav1.ConditionTrue,
                Reason:             string(gatewayv1.RouteReasonAccepted),
                ObservedGeneration: httpRoute.Generation,
                LastTransitionTime: metav1.Now(),
                Message:            fmt.Sprintf("Route accepted by %s", routeDetails.gatewayDetails.gateway.Name),
        })

        if found </span><span class="cov2" title="2">{
                m.logger.InfoContext(ctx, "Updating HTTProute status as Accepted",
                        slog.String("route", httpRoute.Name),
                        slog.String("gateway", routeDetails.gatewayDetails.gateway.Name),
                )
                httpRoute.Status.Parents[parentStatusIndex] = parentStatus
        }</span> else<span class="cov2" title="2"> {
                m.logger.InfoContext(ctx, "Accepting new HTTProute",
                        slog.String("route", httpRoute.Name),
                        slog.String("gateway", routeDetails.gatewayDetails.gateway.Name),
                )
                httpRoute.Status.Parents = append(httpRoute.Status.Parents, parentStatus)
        }</span>

        <span class="cov4" title="4">if err := m.client.Status().Update(ctx, httpRoute); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to update status for HTTProute %s: %w", httpRoute.Name, err)
        }</span>

        <span class="cov3" title="3">return httpRoute, nil</span>
}

// TODO: The only reason to have this is to check that all backend refs are valid services.
// Need to investigate if we really need to do this.
func (m *httpRouteModelImpl) resolveBackendRefs(
        ctx context.Context,
        params resolveBackendRefsParams,
) (map[string]v1.Service, error) <span class="cov2" title="2">{
        resolvedBackendRefs := make(map[string]v1.Service)
        for _, rule := range params.httpRoute.Spec.Rules </span><span class="cov3" title="3">{
                for _, backendRef := range rule.BackendRefs </span><span class="cov5" title="5">{
                        fullName := backendRefName(backendRef, params.httpRoute.Namespace)

                        var service v1.Service
                        if err := m.client.Get(ctx, fullName, &amp;service); err != nil </span><span class="cov1" title="1">{
                                return nil, fmt.Errorf("failed to get service %s: %w", fullName.String(), err)
                        }</span>

                        <span class="cov4" title="4">m.logger.DebugContext(ctx, "Backend ref resolved",
                                slog.String("fullName", fullName.String()),
                                slog.String("uuid", string(service.UID)),
                        )
                        resolvedBackendRefs[fullName.String()] = service</span>

                        // TODO: Maybe check port and other stuff here
                }
        }

        // TODO: This should handle unresolved refs and update the status
        // as per spec

        <span class="cov1" title="1">return resolvedBackendRefs, nil</span>
}

func (m *httpRouteModelImpl) programRoute(
        ctx context.Context,
        params programRouteParams,
) error <span class="cov2" title="2">{
        // backend set is created per rule with services as backends
        // for the future: services must have same port to make health check work
        // backend set name must be derived from the http route name + rule name (or index if name is empty)

        for i, rule := range params.httpRoute.Spec.Rules </span><span class="cov3" title="3">{
                bsName := backendSetName(params.httpRoute, rule, i)

                // TODO: Some check is required (on accept level) to check that refs within the same rule have same port
                // as well as liveliness probes. OCI load balancer does not support per backend HC
                // Also make sure there is at least one backend ref

                firstBackendRef := rule.BackendRefs[0]
                port := int32(*firstBackendRef.BackendRef.Port)

                _, err := m.ociLoadBalancerModel.reconcileBackendSet(ctx, reconcileBackendSetParams{
                        loadBalancerID: params.config.Spec.LoadBalancerID,
                        name:           bsName,

                        // TODO: Consider using HTTP health check
                        // Need some investigation to prove that it makes sense. We may potentially be
                        // duplicating health checks. There should be pod level liveliness probes
                        healthChecker: &amp;loadbalancer.HealthCheckerDetails{
                                Protocol: lo.ToPtr("TCP"),
                                Port:     lo.ToPtr(int(port)),
                        },
                })
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("failed to reconcile backend set %s: %w", bsName, err)
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

func (m *httpRouteModelImpl) isProgrammingRequired(
        details resolvedRouteDetails,
) (bool, error) <span class="cov6" title="8">{
        parentStatus, found := lo.Find(details.httpRoute.Status.Parents, func(s gatewayv1.RouteParentStatus) bool </span><span class="cov6" title="9">{
                return s.ControllerName == details.gatewayDetails.gatewayClass.Spec.ControllerName &amp;&amp;
                        parentRefEqual(s.ParentRef, details.matchedRef)
        }</span>)

        <span class="cov6" title="8">if !found </span><span class="cov2" title="2">{
                return true, nil
        }</span>

        <span class="cov5" title="6">resolvedRefsCondition := meta.FindStatusCondition(
                parentStatus.Conditions,
                string(gatewayv1.RouteConditionResolvedRefs),
        )
        if resolvedRefsCondition == nil </span><span class="cov1" title="1">{
                return true, nil
        }</span>

        <span class="cov5" title="5">if resolvedRefsCondition.Status == metav1.ConditionTrue &amp;&amp;
                resolvedRefsCondition.ObservedGeneration == details.httpRoute.Generation </span><span class="cov2" title="2">{
                return false, nil
        }</span>

        <span class="cov3" title="3">return true, nil</span>
}

func (m *httpRouteModelImpl) setProgrammed(
        ctx context.Context,
        params setProgrammedParams,
) error <span class="cov4" title="4">{
        httpRoute := params.httpRoute.DeepCopy()

        parentStatus, parentStatusIndex, found := lo.FindIndexOf(
                httpRoute.Status.Parents,
                func(s gatewayv1.RouteParentStatus) bool </span><span class="cov5" title="5">{
                        return s.ControllerName == params.gatewayClass.Spec.ControllerName &amp;&amp;
                                parentRefEqual(s.ParentRef, params.matchedRef)
                }</span>,
        )

        <span class="cov4" title="4">if !found </span><span class="cov2" title="2">{
                return fmt.Errorf("parent status not found for controller %s and parentRef %s",
                        params.gatewayClass.Spec.ControllerName,
                        params.matchedRef.Name,
                )
        }</span>

        // Update the condition for the specific parent status
        <span class="cov2" title="2">meta.SetStatusCondition(&amp;parentStatus.Conditions, metav1.Condition{
                Type:               string(gatewayv1.RouteConditionResolvedRefs),
                Status:             metav1.ConditionTrue,
                Reason:             string(gatewayv1.RouteReasonResolvedRefs),
                ObservedGeneration: httpRoute.Generation,
                LastTransitionTime: metav1.Now(),
                Message:            fmt.Sprintf("Route programmed by %s", params.gateway.Name),
        })

        httpRoute.Status.Parents[parentStatusIndex] = parentStatus

        m.logger.DebugContext(ctx, "Updating HTTProute status as Programmed (ResolvedRefs=True)",
                slog.String("route", httpRoute.Name),
                slog.String("gateway", params.gateway.Name),
        )
        if err := m.client.Status().Update(ctx, httpRoute); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to update programmed status for HTTProute %s: %w", httpRoute.Name, err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// httpRouteModelDeps defines the dependencies required for the httpRouteModel.
type httpRouteModelDeps struct {
        dig.In

        K8sClient    k8sClient
        RootLogger   *slog.Logger
        GatewayModel gatewayModel
        OciLBModel   ociLoadBalancerModel
}

// newHTTPRouteModel creates a new instance of httpRouteModel.
func newHTTPRouteModel(deps httpRouteModelDeps) httpRouteModel <span class="cov10" title="28">{
        return &amp;httpRouteModelImpl{
                client:               deps.K8sClient,
                logger:               deps.RootLogger.WithGroup("httproute-model"),
                gatewayModel:         deps.GatewayModel,
                ociLoadBalancerModel: deps.OciLBModel,
        }
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package app

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
        reconcile "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// MockgatewayModel is an autogenerated mock type for the gatewayModel type
type MockgatewayModel struct {
        mock.Mock
}

type MockgatewayModel_Expecter struct {
        mock *mock.Mock
}

func (_m *MockgatewayModel) EXPECT() *MockgatewayModel_Expecter <span class="cov8" title="20">{
        return &amp;MockgatewayModel_Expecter{mock: &amp;_m.Mock}
}</span>

// programGateway provides a mock function with given fields: ctx, data
func (_m *MockgatewayModel) programGateway(ctx context.Context, data *resolvedGatewayDetails) error <span class="cov4" title="4">{
        ret := _m.Called(ctx, data)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for programGateway")</span>
        }

        <span class="cov4" title="4">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *resolvedGatewayDetails) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, data)
        }</span> else<span class="cov4" title="4"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov4" title="4">return r0</span>
}

// MockgatewayModel_programGateway_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'programGateway'
type MockgatewayModel_programGateway_Call struct {
        *mock.Call
}

// programGateway is a helper method to define mock.On call
//   - ctx context.Context
//   - data *resolvedGatewayDetails
func (_e *MockgatewayModel_Expecter) programGateway(ctx interface{}, data interface{}) *MockgatewayModel_programGateway_Call <span class="cov4" title="4">{
        return &amp;MockgatewayModel_programGateway_Call{Call: _e.mock.On("programGateway", ctx, data)}
}</span>

func (_c *MockgatewayModel_programGateway_Call) Run(run func(ctx context.Context, data *resolvedGatewayDetails)) *MockgatewayModel_programGateway_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*resolvedGatewayDetails))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockgatewayModel_programGateway_Call) Return(_a0 error) *MockgatewayModel_programGateway_Call <span class="cov4" title="4">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockgatewayModel_programGateway_Call) RunAndReturn(run func(context.Context, *resolvedGatewayDetails) error) *MockgatewayModel_programGateway_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// resolveReconcileRequest provides a mock function with given fields: ctx, req, receiver
func (_m *MockgatewayModel) resolveReconcileRequest(ctx context.Context, req reconcile.Request, receiver *resolvedGatewayDetails) (bool, error) <span class="cov7" title="16">{
        ret := _m.Called(ctx, req, receiver)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for resolveReconcileRequest")</span>
        }

        <span class="cov7" title="16">var r0 bool
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, reconcile.Request, *resolvedGatewayDetails) (bool, error)); ok </span><span class="cov2" title="2">{
                return rf(ctx, req, receiver)
        }</span>
        <span class="cov7" title="14">if rf, ok := ret.Get(0).(func(context.Context, reconcile.Request, *resolvedGatewayDetails) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, req, receiver)
        }</span> else<span class="cov7" title="14"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov7" title="14">if rf, ok := ret.Get(1).(func(context.Context, reconcile.Request, *resolvedGatewayDetails) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, req, receiver)
        }</span> else<span class="cov7" title="14"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov7" title="14">return r0, r1</span>
}

// MockgatewayModel_resolveReconcileRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'resolveReconcileRequest'
type MockgatewayModel_resolveReconcileRequest_Call struct {
        *mock.Call
}

// resolveReconcileRequest is a helper method to define mock.On call
//   - ctx context.Context
//   - req reconcile.Request
//   - receiver *resolvedGatewayDetails
func (_e *MockgatewayModel_Expecter) resolveReconcileRequest(ctx interface{}, req interface{}, receiver interface{}) *MockgatewayModel_resolveReconcileRequest_Call <span class="cov7" title="16">{
        return &amp;MockgatewayModel_resolveReconcileRequest_Call{Call: _e.mock.On("resolveReconcileRequest", ctx, req, receiver)}
}</span>

func (_c *MockgatewayModel_resolveReconcileRequest_Call) Run(run func(ctx context.Context, req reconcile.Request, receiver *resolvedGatewayDetails)) *MockgatewayModel_resolveReconcileRequest_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(reconcile.Request), args[2].(*resolvedGatewayDetails))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockgatewayModel_resolveReconcileRequest_Call) Return(_a0 bool, _a1 error) *MockgatewayModel_resolveReconcileRequest_Call <span class="cov7" title="14">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockgatewayModel_resolveReconcileRequest_Call) RunAndReturn(run func(context.Context, reconcile.Request, *resolvedGatewayDetails) (bool, error)) *MockgatewayModel_resolveReconcileRequest_Call <span class="cov2" title="2">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockgatewayModel creates a new instance of MockgatewayModel. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockgatewayModel(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockgatewayModel <span class="cov10" title="36">{
        mock := &amp;MockgatewayModel{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="36">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="36">return mock</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package app

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
)

// MockhttpBackendModel is an autogenerated mock type for the httpBackendModel type
type MockhttpBackendModel struct {
        mock.Mock
}

type MockhttpBackendModel_Expecter struct {
        mock *mock.Mock
}

func (_m *MockhttpBackendModel) EXPECT() *MockhttpBackendModel_Expecter <span class="cov7" title="7">{
        return &amp;MockhttpBackendModel_Expecter{mock: &amp;_m.Mock}
}</span>

// syncRouteBackendEndpoints provides a mock function with given fields: ctx, params
func (_m *MockhttpBackendModel) syncRouteBackendEndpoints(ctx context.Context, params syncRouteBackendEndpointsParams) error <span class="cov4" title="3">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for syncRouteBackendEndpoints")</span>
        }

        <span class="cov4" title="3">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, syncRouteBackendEndpointsParams) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov4" title="3"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov4" title="3">return r0</span>
}

// MockhttpBackendModel_syncRouteBackendEndpoints_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'syncRouteBackendEndpoints'
type MockhttpBackendModel_syncRouteBackendEndpoints_Call struct {
        *mock.Call
}

// syncRouteBackendEndpoints is a helper method to define mock.On call
//   - ctx context.Context
//   - params syncRouteBackendEndpointsParams
func (_e *MockhttpBackendModel_Expecter) syncRouteBackendEndpoints(ctx interface{}, params interface{}) *MockhttpBackendModel_syncRouteBackendEndpoints_Call <span class="cov4" title="3">{
        return &amp;MockhttpBackendModel_syncRouteBackendEndpoints_Call{Call: _e.mock.On("syncRouteBackendEndpoints", ctx, params)}
}</span>

func (_c *MockhttpBackendModel_syncRouteBackendEndpoints_Call) Run(run func(ctx context.Context, params syncRouteBackendEndpointsParams)) *MockhttpBackendModel_syncRouteBackendEndpoints_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(syncRouteBackendEndpointsParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockhttpBackendModel_syncRouteBackendEndpoints_Call) Return(_a0 error) *MockhttpBackendModel_syncRouteBackendEndpoints_Call <span class="cov4" title="3">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockhttpBackendModel_syncRouteBackendEndpoints_Call) RunAndReturn(run func(context.Context, syncRouteBackendEndpointsParams) error) *MockhttpBackendModel_syncRouteBackendEndpoints_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// syncRouteBackendRuleEndpoints provides a mock function with given fields: ctx, params
func (_m *MockhttpBackendModel) syncRouteBackendRuleEndpoints(ctx context.Context, params syncRouteBackendRuleEndpointsParams) error <span class="cov5" title="4">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for syncRouteBackendRuleEndpoints")</span>
        }

        <span class="cov5" title="4">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, syncRouteBackendRuleEndpointsParams) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov5" title="4"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov5" title="4">return r0</span>
}

// MockhttpBackendModel_syncRouteBackendRuleEndpoints_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'syncRouteBackendRuleEndpoints'
type MockhttpBackendModel_syncRouteBackendRuleEndpoints_Call struct {
        *mock.Call
}

// syncRouteBackendRuleEndpoints is a helper method to define mock.On call
//   - ctx context.Context
//   - params syncRouteBackendRuleEndpointsParams
func (_e *MockhttpBackendModel_Expecter) syncRouteBackendRuleEndpoints(ctx interface{}, params interface{}) *MockhttpBackendModel_syncRouteBackendRuleEndpoints_Call <span class="cov5" title="4">{
        return &amp;MockhttpBackendModel_syncRouteBackendRuleEndpoints_Call{Call: _e.mock.On("syncRouteBackendRuleEndpoints", ctx, params)}
}</span>

func (_c *MockhttpBackendModel_syncRouteBackendRuleEndpoints_Call) Run(run func(ctx context.Context, params syncRouteBackendRuleEndpointsParams)) *MockhttpBackendModel_syncRouteBackendRuleEndpoints_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(syncRouteBackendRuleEndpointsParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockhttpBackendModel_syncRouteBackendRuleEndpoints_Call) Return(_a0 error) *MockhttpBackendModel_syncRouteBackendRuleEndpoints_Call <span class="cov5" title="4">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockhttpBackendModel_syncRouteBackendRuleEndpoints_Call) RunAndReturn(run func(context.Context, syncRouteBackendRuleEndpointsParams) error) *MockhttpBackendModel_syncRouteBackendRuleEndpoints_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockhttpBackendModel creates a new instance of MockhttpBackendModel. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockhttpBackendModel(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockhttpBackendModel <span class="cov10" title="14">{
        mock := &amp;MockhttpBackendModel{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="14">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="14">return mock</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package app

import (
        context "context"

        corev1 "k8s.io/api/core/v1"

        mock "github.com/stretchr/testify/mock"

        reconcile "sigs.k8s.io/controller-runtime/pkg/reconcile"

        v1 "sigs.k8s.io/gateway-api/apis/v1"
)

// MockhttpRouteModel is an autogenerated mock type for the httpRouteModel type
type MockhttpRouteModel struct {
        mock.Mock
}

type MockhttpRouteModel_Expecter struct {
        mock *mock.Mock
}

func (_m *MockhttpRouteModel) EXPECT() *MockhttpRouteModel_Expecter <span class="cov10" title="32">{
        return &amp;MockhttpRouteModel_Expecter{mock: &amp;_m.Mock}
}</span>

// acceptRoute provides a mock function with given fields: ctx, routeDetails
func (_m *MockhttpRouteModel) acceptRoute(ctx context.Context, routeDetails resolvedRouteDetails) (*v1.HTTPRoute, error) <span class="cov5" title="5">{
        ret := _m.Called(ctx, routeDetails)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for acceptRoute")</span>
        }

        <span class="cov5" title="5">var r0 *v1.HTTPRoute
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, resolvedRouteDetails) (*v1.HTTPRoute, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, routeDetails)
        }</span>
        <span class="cov5" title="5">if rf, ok := ret.Get(0).(func(context.Context, resolvedRouteDetails) *v1.HTTPRoute); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, routeDetails)
        }</span> else<span class="cov5" title="5"> {
                if ret.Get(0) != nil </span><span class="cov5" title="5">{
                        r0 = ret.Get(0).(*v1.HTTPRoute)
                }</span>
        }

        <span class="cov5" title="5">if rf, ok := ret.Get(1).(func(context.Context, resolvedRouteDetails) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, routeDetails)
        }</span> else<span class="cov5" title="5"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov5" title="5">return r0, r1</span>
}

// MockhttpRouteModel_acceptRoute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'acceptRoute'
type MockhttpRouteModel_acceptRoute_Call struct {
        *mock.Call
}

// acceptRoute is a helper method to define mock.On call
//   - ctx context.Context
//   - routeDetails resolvedRouteDetails
func (_e *MockhttpRouteModel_Expecter) acceptRoute(ctx interface{}, routeDetails interface{}) *MockhttpRouteModel_acceptRoute_Call <span class="cov5" title="5">{
        return &amp;MockhttpRouteModel_acceptRoute_Call{Call: _e.mock.On("acceptRoute", ctx, routeDetails)}
}</span>

func (_c *MockhttpRouteModel_acceptRoute_Call) Run(run func(ctx context.Context, routeDetails resolvedRouteDetails)) *MockhttpRouteModel_acceptRoute_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(resolvedRouteDetails))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockhttpRouteModel_acceptRoute_Call) Return(_a0 *v1.HTTPRoute, _a1 error) *MockhttpRouteModel_acceptRoute_Call <span class="cov5" title="5">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockhttpRouteModel_acceptRoute_Call) RunAndReturn(run func(context.Context, resolvedRouteDetails) (*v1.HTTPRoute, error)) *MockhttpRouteModel_acceptRoute_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// isProgrammingRequired provides a mock function with given fields: details
func (_m *MockhttpRouteModel) isProgrammingRequired(details resolvedRouteDetails) (bool, error) <span class="cov6" title="8">{
        ret := _m.Called(details)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for isProgrammingRequired")</span>
        }

        <span class="cov6" title="8">var r0 bool
        var r1 error
        if rf, ok := ret.Get(0).(func(resolvedRouteDetails) (bool, error)); ok </span><span class="cov0" title="0">{
                return rf(details)
        }</span>
        <span class="cov6" title="8">if rf, ok := ret.Get(0).(func(resolvedRouteDetails) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(details)
        }</span> else<span class="cov6" title="8"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov6" title="8">if rf, ok := ret.Get(1).(func(resolvedRouteDetails) error); ok </span><span class="cov0" title="0">{
                r1 = rf(details)
        }</span> else<span class="cov6" title="8"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov6" title="8">return r0, r1</span>
}

// MockhttpRouteModel_isProgrammingRequired_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'isProgrammingRequired'
type MockhttpRouteModel_isProgrammingRequired_Call struct {
        *mock.Call
}

// isProgrammingRequired is a helper method to define mock.On call
//   - details resolvedRouteDetails
func (_e *MockhttpRouteModel_Expecter) isProgrammingRequired(details interface{}) *MockhttpRouteModel_isProgrammingRequired_Call <span class="cov6" title="8">{
        return &amp;MockhttpRouteModel_isProgrammingRequired_Call{Call: _e.mock.On("isProgrammingRequired", details)}
}</span>

func (_c *MockhttpRouteModel_isProgrammingRequired_Call) Run(run func(details resolvedRouteDetails)) *MockhttpRouteModel_isProgrammingRequired_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(resolvedRouteDetails))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockhttpRouteModel_isProgrammingRequired_Call) Return(_a0 bool, _a1 error) *MockhttpRouteModel_isProgrammingRequired_Call <span class="cov6" title="8">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockhttpRouteModel_isProgrammingRequired_Call) RunAndReturn(run func(resolvedRouteDetails) (bool, error)) *MockhttpRouteModel_isProgrammingRequired_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// programRoute provides a mock function with given fields: ctx, params
func (_m *MockhttpRouteModel) programRoute(ctx context.Context, params programRouteParams) error <span class="cov3" title="3">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for programRoute")</span>
        }

        <span class="cov3" title="3">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, programRouteParams) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov3" title="3">return r0</span>
}

// MockhttpRouteModel_programRoute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'programRoute'
type MockhttpRouteModel_programRoute_Call struct {
        *mock.Call
}

// programRoute is a helper method to define mock.On call
//   - ctx context.Context
//   - params programRouteParams
func (_e *MockhttpRouteModel_Expecter) programRoute(ctx interface{}, params interface{}) *MockhttpRouteModel_programRoute_Call <span class="cov3" title="3">{
        return &amp;MockhttpRouteModel_programRoute_Call{Call: _e.mock.On("programRoute", ctx, params)}
}</span>

func (_c *MockhttpRouteModel_programRoute_Call) Run(run func(ctx context.Context, params programRouteParams)) *MockhttpRouteModel_programRoute_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(programRouteParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockhttpRouteModel_programRoute_Call) Return(_a0 error) *MockhttpRouteModel_programRoute_Call <span class="cov3" title="3">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockhttpRouteModel_programRoute_Call) RunAndReturn(run func(context.Context, programRouteParams) error) *MockhttpRouteModel_programRoute_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// resolveBackendRefs provides a mock function with given fields: ctx, params
func (_m *MockhttpRouteModel) resolveBackendRefs(ctx context.Context, params resolveBackendRefsParams) (map[string]corev1.Service, error) <span class="cov4" title="4">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for resolveBackendRefs")</span>
        }

        <span class="cov4" title="4">var r0 map[string]corev1.Service
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, resolveBackendRefsParams) (map[string]corev1.Service, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov4" title="4">if rf, ok := ret.Get(0).(func(context.Context, resolveBackendRefsParams) map[string]corev1.Service); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov4" title="4"> {
                if ret.Get(0) != nil </span><span class="cov4" title="4">{
                        r0 = ret.Get(0).(map[string]corev1.Service)
                }</span>
        }

        <span class="cov4" title="4">if rf, ok := ret.Get(1).(func(context.Context, resolveBackendRefsParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov4" title="4"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="4">return r0, r1</span>
}

// MockhttpRouteModel_resolveBackendRefs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'resolveBackendRefs'
type MockhttpRouteModel_resolveBackendRefs_Call struct {
        *mock.Call
}

// resolveBackendRefs is a helper method to define mock.On call
//   - ctx context.Context
//   - params resolveBackendRefsParams
func (_e *MockhttpRouteModel_Expecter) resolveBackendRefs(ctx interface{}, params interface{}) *MockhttpRouteModel_resolveBackendRefs_Call <span class="cov4" title="4">{
        return &amp;MockhttpRouteModel_resolveBackendRefs_Call{Call: _e.mock.On("resolveBackendRefs", ctx, params)}
}</span>

func (_c *MockhttpRouteModel_resolveBackendRefs_Call) Run(run func(ctx context.Context, params resolveBackendRefsParams)) *MockhttpRouteModel_resolveBackendRefs_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(resolveBackendRefsParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockhttpRouteModel_resolveBackendRefs_Call) Return(_a0 map[string]corev1.Service, _a1 error) *MockhttpRouteModel_resolveBackendRefs_Call <span class="cov4" title="4">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockhttpRouteModel_resolveBackendRefs_Call) RunAndReturn(run func(context.Context, resolveBackendRefsParams) (map[string]corev1.Service, error)) *MockhttpRouteModel_resolveBackendRefs_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// resolveRequest provides a mock function with given fields: ctx, req, receiver
func (_m *MockhttpRouteModel) resolveRequest(ctx context.Context, req reconcile.Request, receiver *resolvedRouteDetails) (bool, error) <span class="cov6" title="10">{
        ret := _m.Called(ctx, req, receiver)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for resolveRequest")</span>
        }

        <span class="cov6" title="10">var r0 bool
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, reconcile.Request, *resolvedRouteDetails) (bool, error)); ok </span><span class="cov6" title="8">{
                return rf(ctx, req, receiver)
        }</span>
        <span class="cov2" title="2">if rf, ok := ret.Get(0).(func(context.Context, reconcile.Request, *resolvedRouteDetails) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, req, receiver)
        }</span> else<span class="cov2" title="2"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov2" title="2">if rf, ok := ret.Get(1).(func(context.Context, reconcile.Request, *resolvedRouteDetails) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, req, receiver)
        }</span> else<span class="cov2" title="2"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov2" title="2">return r0, r1</span>
}

// MockhttpRouteModel_resolveRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'resolveRequest'
type MockhttpRouteModel_resolveRequest_Call struct {
        *mock.Call
}

// resolveRequest is a helper method to define mock.On call
//   - ctx context.Context
//   - req reconcile.Request
//   - receiver *resolvedRouteDetails
func (_e *MockhttpRouteModel_Expecter) resolveRequest(ctx interface{}, req interface{}, receiver interface{}) *MockhttpRouteModel_resolveRequest_Call <span class="cov6" title="10">{
        return &amp;MockhttpRouteModel_resolveRequest_Call{Call: _e.mock.On("resolveRequest", ctx, req, receiver)}
}</span>

func (_c *MockhttpRouteModel_resolveRequest_Call) Run(run func(ctx context.Context, req reconcile.Request, receiver *resolvedRouteDetails)) *MockhttpRouteModel_resolveRequest_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(reconcile.Request), args[2].(*resolvedRouteDetails))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockhttpRouteModel_resolveRequest_Call) Return(_a0 bool, _a1 error) *MockhttpRouteModel_resolveRequest_Call <span class="cov2" title="2">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockhttpRouteModel_resolveRequest_Call) RunAndReturn(run func(context.Context, reconcile.Request, *resolvedRouteDetails) (bool, error)) *MockhttpRouteModel_resolveRequest_Call <span class="cov6" title="8">{
        _c.Call.Return(run)
        return _c
}</span>

// setProgrammed provides a mock function with given fields: ctx, params
func (_m *MockhttpRouteModel) setProgrammed(ctx context.Context, params setProgrammedParams) error <span class="cov2" title="2">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for setProgrammed")</span>
        }

        <span class="cov2" title="2">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, setProgrammedParams) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov2" title="2"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov2" title="2">return r0</span>
}

// MockhttpRouteModel_setProgrammed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'setProgrammed'
type MockhttpRouteModel_setProgrammed_Call struct {
        *mock.Call
}

// setProgrammed is a helper method to define mock.On call
//   - ctx context.Context
//   - params setProgrammedParams
func (_e *MockhttpRouteModel_Expecter) setProgrammed(ctx interface{}, params interface{}) *MockhttpRouteModel_setProgrammed_Call <span class="cov2" title="2">{
        return &amp;MockhttpRouteModel_setProgrammed_Call{Call: _e.mock.On("setProgrammed", ctx, params)}
}</span>

func (_c *MockhttpRouteModel_setProgrammed_Call) Run(run func(ctx context.Context, params setProgrammedParams)) *MockhttpRouteModel_setProgrammed_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(setProgrammedParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockhttpRouteModel_setProgrammed_Call) Return(_a0 error) *MockhttpRouteModel_setProgrammed_Call <span class="cov2" title="2">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockhttpRouteModel_setProgrammed_Call) RunAndReturn(run func(context.Context, setProgrammedParams) error) *MockhttpRouteModel_setProgrammed_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockhttpRouteModel creates a new instance of MockhttpRouteModel. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockhttpRouteModel(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockhttpRouteModel <span class="cov6" title="10">{
        mock := &amp;MockhttpRouteModel{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov6" title="10">{ mock.AssertExpectations(t) }</span>)

        <span class="cov6" title="10">return mock</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package app

import (
        context "context"

        client "sigs.k8s.io/controller-runtime/pkg/client"

        mock "github.com/stretchr/testify/mock"

        types "k8s.io/apimachinery/pkg/types"
)

// Mockk8sClient is an autogenerated mock type for the k8sClient type
type Mockk8sClient struct {
        mock.Mock
}

type Mockk8sClient_Expecter struct {
        mock *mock.Mock
}

func (_m *Mockk8sClient) EXPECT() *Mockk8sClient_Expecter <span class="cov9" title="51">{
        return &amp;Mockk8sClient_Expecter{mock: &amp;_m.Mock}
}</span>

// Get provides a mock function with given fields: ctx, key, obj, opts
func (_m *Mockk8sClient) Get(ctx context.Context, key types.NamespacedName, obj client.Object, opts ...client.GetOption) error <span class="cov8" title="36">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov8" title="36">var _ca []interface{}
        _ca = append(_ca, ctx, key, obj)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Get")</span>
        }

        <span class="cov8" title="36">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, types.NamespacedName, client.Object, ...client.GetOption) error); ok </span><span class="cov8" title="29">{
                r0 = rf(ctx, key, obj, opts...)
        }</span> else<span class="cov5" title="7"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="36">return r0</span>
}

// Mockk8sClient_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type Mockk8sClient_Get_Call struct {
        *mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - key types.NamespacedName
//   - obj client.Object
//   - opts ...client.GetOption
func (_e *Mockk8sClient_Expecter) Get(ctx interface{}, key interface{}, obj interface{}, opts ...interface{}) *Mockk8sClient_Get_Call <span class="cov8" title="36">{
        return &amp;Mockk8sClient_Get_Call{Call: _e.mock.On("Get",
                append([]interface{}{ctx, key, obj}, opts...)...)}
}</span>

func (_c *Mockk8sClient_Get_Call) Run(run func(ctx context.Context, key types.NamespacedName, obj client.Object, opts ...client.GetOption)) *Mockk8sClient_Get_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]client.GetOption, len(args)-3)
                for i, a := range args[3:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(client.GetOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(types.NamespacedName), args[2].(client.Object), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *Mockk8sClient_Get_Call) Return(_a0 error) *Mockk8sClient_Get_Call <span class="cov5" title="7">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *Mockk8sClient_Get_Call) RunAndReturn(run func(context.Context, types.NamespacedName, client.Object, ...client.GetOption) error) *Mockk8sClient_Get_Call <span class="cov8" title="29">{
        _c.Call.Return(run)
        return _c
}</span>

// List provides a mock function with given fields: ctx, list, opts
func (_m *Mockk8sClient) List(ctx context.Context, list client.ObjectList, opts ...client.ListOption) error <span class="cov4" title="6">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov4" title="6">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov4" title="6">var _ca []interface{}
        _ca = append(_ca, ctx, list)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for List")</span>
        }

        <span class="cov4" title="6">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, client.ObjectList, ...client.ListOption) error); ok </span><span class="cov4" title="5">{
                r0 = rf(ctx, list, opts...)
        }</span> else<span class="cov1" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov4" title="6">return r0</span>
}

// Mockk8sClient_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type Mockk8sClient_List_Call struct {
        *mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - list client.ObjectList
//   - opts ...client.ListOption
func (_e *Mockk8sClient_Expecter) List(ctx interface{}, list interface{}, opts ...interface{}) *Mockk8sClient_List_Call <span class="cov4" title="6">{
        return &amp;Mockk8sClient_List_Call{Call: _e.mock.On("List",
                append([]interface{}{ctx, list}, opts...)...)}
}</span>

func (_c *Mockk8sClient_List_Call) Run(run func(ctx context.Context, list client.ObjectList, opts ...client.ListOption)) *Mockk8sClient_List_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]client.ListOption, len(args)-2)
                for i, a := range args[2:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(client.ListOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(client.ObjectList), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *Mockk8sClient_List_Call) Return(_a0 error) *Mockk8sClient_List_Call <span class="cov1" title="1">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *Mockk8sClient_List_Call) RunAndReturn(run func(context.Context, client.ObjectList, ...client.ListOption) error) *Mockk8sClient_List_Call <span class="cov4" title="5">{
        _c.Call.Return(run)
        return _c
}</span>

// Status provides a mock function with no fields
func (_m *Mockk8sClient) Status() client.SubResourceWriter <span class="cov5" title="8">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Status")</span>
        }

        <span class="cov5" title="8">var r0 client.SubResourceWriter
        if rf, ok := ret.Get(0).(func() client.SubResourceWriter); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov5" title="8"> {
                if ret.Get(0) != nil </span><span class="cov5" title="8">{
                        r0 = ret.Get(0).(client.SubResourceWriter)
                }</span>
        }

        <span class="cov5" title="8">return r0</span>
}

// Mockk8sClient_Status_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Status'
type Mockk8sClient_Status_Call struct {
        *mock.Call
}

// Status is a helper method to define mock.On call
func (_e *Mockk8sClient_Expecter) Status() *Mockk8sClient_Status_Call <span class="cov5" title="9">{
        return &amp;Mockk8sClient_Status_Call{Call: _e.mock.On("Status")}
}</span>

func (_c *Mockk8sClient_Status_Call) Run(run func()) *Mockk8sClient_Status_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *Mockk8sClient_Status_Call) Return(_a0 client.SubResourceWriter) *Mockk8sClient_Status_Call <span class="cov5" title="8">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *Mockk8sClient_Status_Call) RunAndReturn(run func() client.SubResourceWriter) *Mockk8sClient_Status_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Update provides a mock function with given fields: ctx, obj, opts
func (_m *Mockk8sClient) Update(ctx context.Context, obj client.Object, opts ...client.UpdateOption) error <span class="cov0" title="0">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, ctx, obj)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Update")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, client.Object, ...client.UpdateOption) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, obj, opts...)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// Mockk8sClient_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type Mockk8sClient_Update_Call struct {
        *mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - obj client.Object
//   - opts ...client.UpdateOption
func (_e *Mockk8sClient_Expecter) Update(ctx interface{}, obj interface{}, opts ...interface{}) *Mockk8sClient_Update_Call <span class="cov0" title="0">{
        return &amp;Mockk8sClient_Update_Call{Call: _e.mock.On("Update",
                append([]interface{}{ctx, obj}, opts...)...)}
}</span>

func (_c *Mockk8sClient_Update_Call) Run(run func(ctx context.Context, obj client.Object, opts ...client.UpdateOption)) *Mockk8sClient_Update_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]client.UpdateOption, len(args)-2)
                for i, a := range args[2:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(client.UpdateOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(client.Object), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *Mockk8sClient_Update_Call) Return(_a0 error) *Mockk8sClient_Update_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *Mockk8sClient_Update_Call) RunAndReturn(run func(context.Context, client.Object, ...client.UpdateOption) error) *Mockk8sClient_Update_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockk8sClient creates a new instance of Mockk8sClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockk8sClient(t interface {
        mock.TestingT
        Cleanup(func())
}) *Mockk8sClient <span class="cov10" title="73">{
        mock := &amp;Mockk8sClient{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="73">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="73">return mock</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package app

import (
        context "context"

        loadbalancer "github.com/oracle/oci-go-sdk/v65/loadbalancer"
        mock "github.com/stretchr/testify/mock"
)

// MockociLoadBalancerClient is an autogenerated mock type for the ociLoadBalancerClient type
type MockociLoadBalancerClient struct {
        mock.Mock
}

type MockociLoadBalancerClient_Expecter struct {
        mock *mock.Mock
}

func (_m *MockociLoadBalancerClient) EXPECT() *MockociLoadBalancerClient_Expecter <span class="cov9" title="29">{
        return &amp;MockociLoadBalancerClient_Expecter{mock: &amp;_m.Mock}
}</span>

// CreateBackend provides a mock function with given fields: ctx, request
func (_m *MockociLoadBalancerClient) CreateBackend(ctx context.Context, request loadbalancer.CreateBackendRequest) (loadbalancer.CreateBackendResponse, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, request)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateBackend")</span>
        }

        <span class="cov0" title="0">var r0 loadbalancer.CreateBackendResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.CreateBackendRequest) (loadbalancer.CreateBackendResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, request)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.CreateBackendRequest) loadbalancer.CreateBackendResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, request)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(loadbalancer.CreateBackendResponse)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, loadbalancer.CreateBackendRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, request)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockociLoadBalancerClient_CreateBackend_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBackend'
type MockociLoadBalancerClient_CreateBackend_Call struct {
        *mock.Call
}

// CreateBackend is a helper method to define mock.On call
//   - ctx context.Context
//   - request loadbalancer.CreateBackendRequest
func (_e *MockociLoadBalancerClient_Expecter) CreateBackend(ctx interface{}, request interface{}) *MockociLoadBalancerClient_CreateBackend_Call <span class="cov0" title="0">{
        return &amp;MockociLoadBalancerClient_CreateBackend_Call{Call: _e.mock.On("CreateBackend", ctx, request)}
}</span>

func (_c *MockociLoadBalancerClient_CreateBackend_Call) Run(run func(ctx context.Context, request loadbalancer.CreateBackendRequest)) *MockociLoadBalancerClient_CreateBackend_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(loadbalancer.CreateBackendRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerClient_CreateBackend_Call) Return(response loadbalancer.CreateBackendResponse, err error) *MockociLoadBalancerClient_CreateBackend_Call <span class="cov0" title="0">{
        _c.Call.Return(response, err)
        return _c
}</span>

func (_c *MockociLoadBalancerClient_CreateBackend_Call) RunAndReturn(run func(context.Context, loadbalancer.CreateBackendRequest) (loadbalancer.CreateBackendResponse, error)) *MockociLoadBalancerClient_CreateBackend_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// CreateBackendSet provides a mock function with given fields: ctx, request
func (_m *MockociLoadBalancerClient) CreateBackendSet(ctx context.Context, request loadbalancer.CreateBackendSetRequest) (loadbalancer.CreateBackendSetResponse, error) <span class="cov6" title="8">{
        ret := _m.Called(ctx, request)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateBackendSet")</span>
        }

        <span class="cov6" title="8">var r0 loadbalancer.CreateBackendSetResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.CreateBackendSetRequest) (loadbalancer.CreateBackendSetResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, request)
        }</span>
        <span class="cov6" title="8">if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.CreateBackendSetRequest) loadbalancer.CreateBackendSetResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, request)
        }</span> else<span class="cov6" title="8"> {
                r0 = ret.Get(0).(loadbalancer.CreateBackendSetResponse)
        }</span>

        <span class="cov6" title="8">if rf, ok := ret.Get(1).(func(context.Context, loadbalancer.CreateBackendSetRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, request)
        }</span> else<span class="cov6" title="8"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov6" title="8">return r0, r1</span>
}

// MockociLoadBalancerClient_CreateBackendSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBackendSet'
type MockociLoadBalancerClient_CreateBackendSet_Call struct {
        *mock.Call
}

// CreateBackendSet is a helper method to define mock.On call
//   - ctx context.Context
//   - request loadbalancer.CreateBackendSetRequest
func (_e *MockociLoadBalancerClient_Expecter) CreateBackendSet(ctx interface{}, request interface{}) *MockociLoadBalancerClient_CreateBackendSet_Call <span class="cov6" title="8">{
        return &amp;MockociLoadBalancerClient_CreateBackendSet_Call{Call: _e.mock.On("CreateBackendSet", ctx, request)}
}</span>

func (_c *MockociLoadBalancerClient_CreateBackendSet_Call) Run(run func(ctx context.Context, request loadbalancer.CreateBackendSetRequest)) *MockociLoadBalancerClient_CreateBackendSet_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(loadbalancer.CreateBackendSetRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerClient_CreateBackendSet_Call) Return(response loadbalancer.CreateBackendSetResponse, err error) *MockociLoadBalancerClient_CreateBackendSet_Call <span class="cov6" title="8">{
        _c.Call.Return(response, err)
        return _c
}</span>

func (_c *MockociLoadBalancerClient_CreateBackendSet_Call) RunAndReturn(run func(context.Context, loadbalancer.CreateBackendSetRequest) (loadbalancer.CreateBackendSetResponse, error)) *MockociLoadBalancerClient_CreateBackendSet_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// CreateHostname provides a mock function with given fields: ctx, request
func (_m *MockociLoadBalancerClient) CreateHostname(ctx context.Context, request loadbalancer.CreateHostnameRequest) (loadbalancer.CreateHostnameResponse, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, request)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateHostname")</span>
        }

        <span class="cov0" title="0">var r0 loadbalancer.CreateHostnameResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.CreateHostnameRequest) (loadbalancer.CreateHostnameResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, request)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.CreateHostnameRequest) loadbalancer.CreateHostnameResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, request)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(loadbalancer.CreateHostnameResponse)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, loadbalancer.CreateHostnameRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, request)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockociLoadBalancerClient_CreateHostname_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateHostname'
type MockociLoadBalancerClient_CreateHostname_Call struct {
        *mock.Call
}

// CreateHostname is a helper method to define mock.On call
//   - ctx context.Context
//   - request loadbalancer.CreateHostnameRequest
func (_e *MockociLoadBalancerClient_Expecter) CreateHostname(ctx interface{}, request interface{}) *MockociLoadBalancerClient_CreateHostname_Call <span class="cov0" title="0">{
        return &amp;MockociLoadBalancerClient_CreateHostname_Call{Call: _e.mock.On("CreateHostname", ctx, request)}
}</span>

func (_c *MockociLoadBalancerClient_CreateHostname_Call) Run(run func(ctx context.Context, request loadbalancer.CreateHostnameRequest)) *MockociLoadBalancerClient_CreateHostname_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(loadbalancer.CreateHostnameRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerClient_CreateHostname_Call) Return(response loadbalancer.CreateHostnameResponse, err error) *MockociLoadBalancerClient_CreateHostname_Call <span class="cov0" title="0">{
        _c.Call.Return(response, err)
        return _c
}</span>

func (_c *MockociLoadBalancerClient_CreateHostname_Call) RunAndReturn(run func(context.Context, loadbalancer.CreateHostnameRequest) (loadbalancer.CreateHostnameResponse, error)) *MockociLoadBalancerClient_CreateHostname_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// CreateListener provides a mock function with given fields: ctx, request
func (_m *MockociLoadBalancerClient) CreateListener(ctx context.Context, request loadbalancer.CreateListenerRequest) (loadbalancer.CreateListenerResponse, error) <span class="cov4" title="4">{
        ret := _m.Called(ctx, request)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateListener")</span>
        }

        <span class="cov4" title="4">var r0 loadbalancer.CreateListenerResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.CreateListenerRequest) (loadbalancer.CreateListenerResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, request)
        }</span>
        <span class="cov4" title="4">if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.CreateListenerRequest) loadbalancer.CreateListenerResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, request)
        }</span> else<span class="cov4" title="4"> {
                r0 = ret.Get(0).(loadbalancer.CreateListenerResponse)
        }</span>

        <span class="cov4" title="4">if rf, ok := ret.Get(1).(func(context.Context, loadbalancer.CreateListenerRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, request)
        }</span> else<span class="cov4" title="4"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="4">return r0, r1</span>
}

// MockociLoadBalancerClient_CreateListener_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateListener'
type MockociLoadBalancerClient_CreateListener_Call struct {
        *mock.Call
}

// CreateListener is a helper method to define mock.On call
//   - ctx context.Context
//   - request loadbalancer.CreateListenerRequest
func (_e *MockociLoadBalancerClient_Expecter) CreateListener(ctx interface{}, request interface{}) *MockociLoadBalancerClient_CreateListener_Call <span class="cov4" title="4">{
        return &amp;MockociLoadBalancerClient_CreateListener_Call{Call: _e.mock.On("CreateListener", ctx, request)}
}</span>

func (_c *MockociLoadBalancerClient_CreateListener_Call) Run(run func(ctx context.Context, request loadbalancer.CreateListenerRequest)) *MockociLoadBalancerClient_CreateListener_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(loadbalancer.CreateListenerRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerClient_CreateListener_Call) Return(response loadbalancer.CreateListenerResponse, err error) *MockociLoadBalancerClient_CreateListener_Call <span class="cov4" title="4">{
        _c.Call.Return(response, err)
        return _c
}</span>

func (_c *MockociLoadBalancerClient_CreateListener_Call) RunAndReturn(run func(context.Context, loadbalancer.CreateListenerRequest) (loadbalancer.CreateListenerResponse, error)) *MockociLoadBalancerClient_CreateListener_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetBackendSet provides a mock function with given fields: ctx, request
func (_m *MockociLoadBalancerClient) GetBackendSet(ctx context.Context, request loadbalancer.GetBackendSetRequest) (loadbalancer.GetBackendSetResponse, error) <span class="cov6" title="9">{
        ret := _m.Called(ctx, request)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetBackendSet")</span>
        }

        <span class="cov6" title="9">var r0 loadbalancer.GetBackendSetResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.GetBackendSetRequest) (loadbalancer.GetBackendSetResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, request)
        }</span>
        <span class="cov6" title="9">if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.GetBackendSetRequest) loadbalancer.GetBackendSetResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, request)
        }</span> else<span class="cov6" title="9"> {
                r0 = ret.Get(0).(loadbalancer.GetBackendSetResponse)
        }</span>

        <span class="cov6" title="9">if rf, ok := ret.Get(1).(func(context.Context, loadbalancer.GetBackendSetRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, request)
        }</span> else<span class="cov6" title="9"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov6" title="9">return r0, r1</span>
}

// MockociLoadBalancerClient_GetBackendSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBackendSet'
type MockociLoadBalancerClient_GetBackendSet_Call struct {
        *mock.Call
}

// GetBackendSet is a helper method to define mock.On call
//   - ctx context.Context
//   - request loadbalancer.GetBackendSetRequest
func (_e *MockociLoadBalancerClient_Expecter) GetBackendSet(ctx interface{}, request interface{}) *MockociLoadBalancerClient_GetBackendSet_Call <span class="cov6" title="9">{
        return &amp;MockociLoadBalancerClient_GetBackendSet_Call{Call: _e.mock.On("GetBackendSet", ctx, request)}
}</span>

func (_c *MockociLoadBalancerClient_GetBackendSet_Call) Run(run func(ctx context.Context, request loadbalancer.GetBackendSetRequest)) *MockociLoadBalancerClient_GetBackendSet_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(loadbalancer.GetBackendSetRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerClient_GetBackendSet_Call) Return(response loadbalancer.GetBackendSetResponse, err error) *MockociLoadBalancerClient_GetBackendSet_Call <span class="cov6" title="9">{
        _c.Call.Return(response, err)
        return _c
}</span>

func (_c *MockociLoadBalancerClient_GetBackendSet_Call) RunAndReturn(run func(context.Context, loadbalancer.GetBackendSetRequest) (loadbalancer.GetBackendSetResponse, error)) *MockociLoadBalancerClient_GetBackendSet_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetHostname provides a mock function with given fields: ctx, request
func (_m *MockociLoadBalancerClient) GetHostname(ctx context.Context, request loadbalancer.GetHostnameRequest) (loadbalancer.GetHostnameResponse, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, request)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetHostname")</span>
        }

        <span class="cov0" title="0">var r0 loadbalancer.GetHostnameResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.GetHostnameRequest) (loadbalancer.GetHostnameResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, request)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.GetHostnameRequest) loadbalancer.GetHostnameResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, request)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(loadbalancer.GetHostnameResponse)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, loadbalancer.GetHostnameRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, request)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockociLoadBalancerClient_GetHostname_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHostname'
type MockociLoadBalancerClient_GetHostname_Call struct {
        *mock.Call
}

// GetHostname is a helper method to define mock.On call
//   - ctx context.Context
//   - request loadbalancer.GetHostnameRequest
func (_e *MockociLoadBalancerClient_Expecter) GetHostname(ctx interface{}, request interface{}) *MockociLoadBalancerClient_GetHostname_Call <span class="cov0" title="0">{
        return &amp;MockociLoadBalancerClient_GetHostname_Call{Call: _e.mock.On("GetHostname", ctx, request)}
}</span>

func (_c *MockociLoadBalancerClient_GetHostname_Call) Run(run func(ctx context.Context, request loadbalancer.GetHostnameRequest)) *MockociLoadBalancerClient_GetHostname_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(loadbalancer.GetHostnameRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerClient_GetHostname_Call) Return(response loadbalancer.GetHostnameResponse, err error) *MockociLoadBalancerClient_GetHostname_Call <span class="cov0" title="0">{
        _c.Call.Return(response, err)
        return _c
}</span>

func (_c *MockociLoadBalancerClient_GetHostname_Call) RunAndReturn(run func(context.Context, loadbalancer.GetHostnameRequest) (loadbalancer.GetHostnameResponse, error)) *MockociLoadBalancerClient_GetHostname_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetLoadBalancer provides a mock function with given fields: ctx, request
func (_m *MockociLoadBalancerClient) GetLoadBalancer(ctx context.Context, request loadbalancer.GetLoadBalancerRequest) (loadbalancer.GetLoadBalancerResponse, error) <span class="cov5" title="6">{
        ret := _m.Called(ctx, request)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetLoadBalancer")</span>
        }

        <span class="cov5" title="6">var r0 loadbalancer.GetLoadBalancerResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.GetLoadBalancerRequest) (loadbalancer.GetLoadBalancerResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, request)
        }</span>
        <span class="cov5" title="6">if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.GetLoadBalancerRequest) loadbalancer.GetLoadBalancerResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, request)
        }</span> else<span class="cov5" title="6"> {
                r0 = ret.Get(0).(loadbalancer.GetLoadBalancerResponse)
        }</span>

        <span class="cov5" title="6">if rf, ok := ret.Get(1).(func(context.Context, loadbalancer.GetLoadBalancerRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, request)
        }</span> else<span class="cov5" title="6"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov5" title="6">return r0, r1</span>
}

// MockociLoadBalancerClient_GetLoadBalancer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLoadBalancer'
type MockociLoadBalancerClient_GetLoadBalancer_Call struct {
        *mock.Call
}

// GetLoadBalancer is a helper method to define mock.On call
//   - ctx context.Context
//   - request loadbalancer.GetLoadBalancerRequest
func (_e *MockociLoadBalancerClient_Expecter) GetLoadBalancer(ctx interface{}, request interface{}) *MockociLoadBalancerClient_GetLoadBalancer_Call <span class="cov5" title="6">{
        return &amp;MockociLoadBalancerClient_GetLoadBalancer_Call{Call: _e.mock.On("GetLoadBalancer", ctx, request)}
}</span>

func (_c *MockociLoadBalancerClient_GetLoadBalancer_Call) Run(run func(ctx context.Context, request loadbalancer.GetLoadBalancerRequest)) *MockociLoadBalancerClient_GetLoadBalancer_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(loadbalancer.GetLoadBalancerRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerClient_GetLoadBalancer_Call) Return(response loadbalancer.GetLoadBalancerResponse, err error) *MockociLoadBalancerClient_GetLoadBalancer_Call <span class="cov5" title="6">{
        _c.Call.Return(response, err)
        return _c
}</span>

func (_c *MockociLoadBalancerClient_GetLoadBalancer_Call) RunAndReturn(run func(context.Context, loadbalancer.GetLoadBalancerRequest) (loadbalancer.GetLoadBalancerResponse, error)) *MockociLoadBalancerClient_GetLoadBalancer_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// UpdateBackendSet provides a mock function with given fields: ctx, request
func (_m *MockociLoadBalancerClient) UpdateBackendSet(ctx context.Context, request loadbalancer.UpdateBackendSetRequest) (loadbalancer.UpdateBackendSetResponse, error) <span class="cov2" title="2">{
        ret := _m.Called(ctx, request)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateBackendSet")</span>
        }

        <span class="cov2" title="2">var r0 loadbalancer.UpdateBackendSetResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.UpdateBackendSetRequest) (loadbalancer.UpdateBackendSetResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, request)
        }</span>
        <span class="cov2" title="2">if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.UpdateBackendSetRequest) loadbalancer.UpdateBackendSetResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, request)
        }</span> else<span class="cov2" title="2"> {
                r0 = ret.Get(0).(loadbalancer.UpdateBackendSetResponse)
        }</span>

        <span class="cov2" title="2">if rf, ok := ret.Get(1).(func(context.Context, loadbalancer.UpdateBackendSetRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, request)
        }</span> else<span class="cov2" title="2"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov2" title="2">return r0, r1</span>
}

// MockociLoadBalancerClient_UpdateBackendSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateBackendSet'
type MockociLoadBalancerClient_UpdateBackendSet_Call struct {
        *mock.Call
}

// UpdateBackendSet is a helper method to define mock.On call
//   - ctx context.Context
//   - request loadbalancer.UpdateBackendSetRequest
func (_e *MockociLoadBalancerClient_Expecter) UpdateBackendSet(ctx interface{}, request interface{}) *MockociLoadBalancerClient_UpdateBackendSet_Call <span class="cov2" title="2">{
        return &amp;MockociLoadBalancerClient_UpdateBackendSet_Call{Call: _e.mock.On("UpdateBackendSet", ctx, request)}
}</span>

func (_c *MockociLoadBalancerClient_UpdateBackendSet_Call) Run(run func(ctx context.Context, request loadbalancer.UpdateBackendSetRequest)) *MockociLoadBalancerClient_UpdateBackendSet_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(loadbalancer.UpdateBackendSetRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerClient_UpdateBackendSet_Call) Return(response loadbalancer.UpdateBackendSetResponse, err error) *MockociLoadBalancerClient_UpdateBackendSet_Call <span class="cov2" title="2">{
        _c.Call.Return(response, err)
        return _c
}</span>

func (_c *MockociLoadBalancerClient_UpdateBackendSet_Call) RunAndReturn(run func(context.Context, loadbalancer.UpdateBackendSetRequest) (loadbalancer.UpdateBackendSetResponse, error)) *MockociLoadBalancerClient_UpdateBackendSet_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockociLoadBalancerClient creates a new instance of MockociLoadBalancerClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockociLoadBalancerClient(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockociLoadBalancerClient <span class="cov10" title="32">{
        mock := &amp;MockociLoadBalancerClient{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="32">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="32">return mock</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package app

import (
        context "context"

        loadbalancer "github.com/oracle/oci-go-sdk/v65/loadbalancer"
        mock "github.com/stretchr/testify/mock"
)

// MockociLoadBalancerModel is an autogenerated mock type for the ociLoadBalancerModel type
type MockociLoadBalancerModel struct {
        mock.Mock
}

type MockociLoadBalancerModel_Expecter struct {
        mock *mock.Mock
}

func (_m *MockociLoadBalancerModel) EXPECT() *MockociLoadBalancerModel_Expecter <span class="cov6" title="9">{
        return &amp;MockociLoadBalancerModel_Expecter{mock: &amp;_m.Mock}
}</span>

// reconcileBackendSet provides a mock function with given fields: ctx, params
func (_m *MockociLoadBalancerModel) reconcileBackendSet(ctx context.Context, params reconcileBackendSetParams) (loadbalancer.BackendSet, error) <span class="cov3" title="3">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for reconcileBackendSet")</span>
        }

        <span class="cov3" title="3">var r0 loadbalancer.BackendSet
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, reconcileBackendSetParams) (loadbalancer.BackendSet, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov3" title="3">if rf, ok := ret.Get(0).(func(context.Context, reconcileBackendSetParams) loadbalancer.BackendSet); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                r0 = ret.Get(0).(loadbalancer.BackendSet)
        }</span>

        <span class="cov3" title="3">if rf, ok := ret.Get(1).(func(context.Context, reconcileBackendSetParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov3" title="3">return r0, r1</span>
}

// MockociLoadBalancerModel_reconcileBackendSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'reconcileBackendSet'
type MockociLoadBalancerModel_reconcileBackendSet_Call struct {
        *mock.Call
}

// reconcileBackendSet is a helper method to define mock.On call
//   - ctx context.Context
//   - params reconcileBackendSetParams
func (_e *MockociLoadBalancerModel_Expecter) reconcileBackendSet(ctx interface{}, params interface{}) *MockociLoadBalancerModel_reconcileBackendSet_Call <span class="cov3" title="3">{
        return &amp;MockociLoadBalancerModel_reconcileBackendSet_Call{Call: _e.mock.On("reconcileBackendSet", ctx, params)}
}</span>

func (_c *MockociLoadBalancerModel_reconcileBackendSet_Call) Run(run func(ctx context.Context, params reconcileBackendSetParams)) *MockociLoadBalancerModel_reconcileBackendSet_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(reconcileBackendSetParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerModel_reconcileBackendSet_Call) Return(_a0 loadbalancer.BackendSet, _a1 error) *MockociLoadBalancerModel_reconcileBackendSet_Call <span class="cov3" title="3">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockociLoadBalancerModel_reconcileBackendSet_Call) RunAndReturn(run func(context.Context, reconcileBackendSetParams) (loadbalancer.BackendSet, error)) *MockociLoadBalancerModel_reconcileBackendSet_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// reconcileDefaultBackendSet provides a mock function with given fields: ctx, params
func (_m *MockociLoadBalancerModel) reconcileDefaultBackendSet(ctx context.Context, params reconcileDefaultBackendParams) (loadbalancer.BackendSet, error) <span class="cov3" title="3">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for reconcileDefaultBackendSet")</span>
        }

        <span class="cov3" title="3">var r0 loadbalancer.BackendSet
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, reconcileDefaultBackendParams) (loadbalancer.BackendSet, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov3" title="3">if rf, ok := ret.Get(0).(func(context.Context, reconcileDefaultBackendParams) loadbalancer.BackendSet); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                r0 = ret.Get(0).(loadbalancer.BackendSet)
        }</span>

        <span class="cov3" title="3">if rf, ok := ret.Get(1).(func(context.Context, reconcileDefaultBackendParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov3" title="3">return r0, r1</span>
}

// MockociLoadBalancerModel_reconcileDefaultBackendSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'reconcileDefaultBackendSet'
type MockociLoadBalancerModel_reconcileDefaultBackendSet_Call struct {
        *mock.Call
}

// reconcileDefaultBackendSet is a helper method to define mock.On call
//   - ctx context.Context
//   - params reconcileDefaultBackendParams
func (_e *MockociLoadBalancerModel_Expecter) reconcileDefaultBackendSet(ctx interface{}, params interface{}) *MockociLoadBalancerModel_reconcileDefaultBackendSet_Call <span class="cov3" title="3">{
        return &amp;MockociLoadBalancerModel_reconcileDefaultBackendSet_Call{Call: _e.mock.On("reconcileDefaultBackendSet", ctx, params)}
}</span>

func (_c *MockociLoadBalancerModel_reconcileDefaultBackendSet_Call) Run(run func(ctx context.Context, params reconcileDefaultBackendParams)) *MockociLoadBalancerModel_reconcileDefaultBackendSet_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(reconcileDefaultBackendParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerModel_reconcileDefaultBackendSet_Call) Return(_a0 loadbalancer.BackendSet, _a1 error) *MockociLoadBalancerModel_reconcileDefaultBackendSet_Call <span class="cov3" title="3">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockociLoadBalancerModel_reconcileDefaultBackendSet_Call) RunAndReturn(run func(context.Context, reconcileDefaultBackendParams) (loadbalancer.BackendSet, error)) *MockociLoadBalancerModel_reconcileDefaultBackendSet_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// reconcileHTTPListener provides a mock function with given fields: ctx, params
func (_m *MockociLoadBalancerModel) reconcileHTTPListener(ctx context.Context, params reconcileHTTPListenerParams) (loadbalancer.Listener, error) <span class="cov3" title="3">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for reconcileHTTPListener")</span>
        }

        <span class="cov3" title="3">var r0 loadbalancer.Listener
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, reconcileHTTPListenerParams) (loadbalancer.Listener, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov3" title="3">if rf, ok := ret.Get(0).(func(context.Context, reconcileHTTPListenerParams) loadbalancer.Listener); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                r0 = ret.Get(0).(loadbalancer.Listener)
        }</span>

        <span class="cov3" title="3">if rf, ok := ret.Get(1).(func(context.Context, reconcileHTTPListenerParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov3" title="3">return r0, r1</span>
}

// MockociLoadBalancerModel_reconcileHTTPListener_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'reconcileHTTPListener'
type MockociLoadBalancerModel_reconcileHTTPListener_Call struct {
        *mock.Call
}

// reconcileHTTPListener is a helper method to define mock.On call
//   - ctx context.Context
//   - params reconcileHTTPListenerParams
func (_e *MockociLoadBalancerModel_Expecter) reconcileHTTPListener(ctx interface{}, params interface{}) *MockociLoadBalancerModel_reconcileHTTPListener_Call <span class="cov3" title="3">{
        return &amp;MockociLoadBalancerModel_reconcileHTTPListener_Call{Call: _e.mock.On("reconcileHTTPListener", ctx, params)}
}</span>

func (_c *MockociLoadBalancerModel_reconcileHTTPListener_Call) Run(run func(ctx context.Context, params reconcileHTTPListenerParams)) *MockociLoadBalancerModel_reconcileHTTPListener_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(reconcileHTTPListenerParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerModel_reconcileHTTPListener_Call) Return(_a0 loadbalancer.Listener, _a1 error) *MockociLoadBalancerModel_reconcileHTTPListener_Call <span class="cov3" title="3">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockociLoadBalancerModel_reconcileHTTPListener_Call) RunAndReturn(run func(context.Context, reconcileHTTPListenerParams) (loadbalancer.Listener, error)) *MockociLoadBalancerModel_reconcileHTTPListener_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockociLoadBalancerModel creates a new instance of MockociLoadBalancerModel. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockociLoadBalancerModel(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockociLoadBalancerModel <span class="cov10" title="40">{
        mock := &amp;MockociLoadBalancerModel{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="40">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="40">return mock</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package app

import (
        context "context"

        client "sigs.k8s.io/controller-runtime/pkg/client"

        mock "github.com/stretchr/testify/mock"

        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// MockresourcesModel is an autogenerated mock type for the resourcesModel type
type MockresourcesModel struct {
        mock.Mock
}

type MockresourcesModel_Expecter struct {
        mock *mock.Mock
}

func (_m *MockresourcesModel) EXPECT() *MockresourcesModel_Expecter <span class="cov10" title="21">{
        return &amp;MockresourcesModel_Expecter{mock: &amp;_m.Mock}
}</span>

// isConditionSet provides a mock function with given fields: resource, conditions, conditionType
func (_m *MockresourcesModel) isConditionSet(resource client.Object, conditions []v1.Condition, conditionType string) bool <span class="cov8" title="13">{
        ret := _m.Called(resource, conditions, conditionType)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for isConditionSet")</span>
        }

        <span class="cov8" title="13">var r0 bool
        if rf, ok := ret.Get(0).(func(client.Object, []v1.Condition, string) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(resource, conditions, conditionType)
        }</span> else<span class="cov8" title="13"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov8" title="13">return r0</span>
}

// MockresourcesModel_isConditionSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'isConditionSet'
type MockresourcesModel_isConditionSet_Call struct {
        *mock.Call
}

// isConditionSet is a helper method to define mock.On call
//   - resource client.Object
//   - conditions []v1.Condition
//   - conditionType string
func (_e *MockresourcesModel_Expecter) isConditionSet(resource interface{}, conditions interface{}, conditionType interface{}) *MockresourcesModel_isConditionSet_Call <span class="cov8" title="13">{
        return &amp;MockresourcesModel_isConditionSet_Call{Call: _e.mock.On("isConditionSet", resource, conditions, conditionType)}
}</span>

func (_c *MockresourcesModel_isConditionSet_Call) Run(run func(resource client.Object, conditions []v1.Condition, conditionType string)) *MockresourcesModel_isConditionSet_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(client.Object), args[1].([]v1.Condition), args[2].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockresourcesModel_isConditionSet_Call) Return(_a0 bool) *MockresourcesModel_isConditionSet_Call <span class="cov8" title="13">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockresourcesModel_isConditionSet_Call) RunAndReturn(run func(client.Object, []v1.Condition, string) bool) *MockresourcesModel_isConditionSet_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// setCondition provides a mock function with given fields: ctx, params
func (_m *MockresourcesModel) setCondition(ctx context.Context, params setConditionParams) error <span class="cov7" title="8">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for setCondition")</span>
        }

        <span class="cov7" title="8">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, setConditionParams) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov7" title="8"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov7" title="8">return r0</span>
}

// MockresourcesModel_setCondition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'setCondition'
type MockresourcesModel_setCondition_Call struct {
        *mock.Call
}

// setCondition is a helper method to define mock.On call
//   - ctx context.Context
//   - params setConditionParams
func (_e *MockresourcesModel_Expecter) setCondition(ctx interface{}, params interface{}) *MockresourcesModel_setCondition_Call <span class="cov7" title="8">{
        return &amp;MockresourcesModel_setCondition_Call{Call: _e.mock.On("setCondition", ctx, params)}
}</span>

func (_c *MockresourcesModel_setCondition_Call) Run(run func(ctx context.Context, params setConditionParams)) *MockresourcesModel_setCondition_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(setConditionParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockresourcesModel_setCondition_Call) Return(_a0 error) *MockresourcesModel_setCondition_Call <span class="cov7" title="8">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockresourcesModel_setCondition_Call) RunAndReturn(run func(context.Context, setConditionParams) error) *MockresourcesModel_setCondition_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockresourcesModel creates a new instance of MockresourcesModel. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockresourcesModel(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockresourcesModel <span class="cov9" title="15">{
        mock := &amp;MockresourcesModel{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov9" title="15">{ mock.AssertExpectations(t) }</span>)

        <span class="cov9" title="15">return mock</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package app

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
)

// MockworkRequestsWatcher is an autogenerated mock type for the workRequestsWatcher type
type MockworkRequestsWatcher struct {
        mock.Mock
}

type MockworkRequestsWatcher_Expecter struct {
        mock *mock.Mock
}

func (_m *MockworkRequestsWatcher) EXPECT() *MockworkRequestsWatcher_Expecter <span class="cov8" title="11">{
        return &amp;MockworkRequestsWatcher_Expecter{mock: &amp;_m.Mock}
}</span>

// WaitFor provides a mock function with given fields: ctx, workRequestID
func (_m *MockworkRequestsWatcher) WaitFor(ctx context.Context, workRequestID string) error <span class="cov8" title="11">{
        ret := _m.Called(ctx, workRequestID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for WaitFor")</span>
        }

        <span class="cov8" title="11">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, workRequestID)
        }</span> else<span class="cov8" title="11"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="11">return r0</span>
}

// MockworkRequestsWatcher_WaitFor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WaitFor'
type MockworkRequestsWatcher_WaitFor_Call struct {
        *mock.Call
}

// WaitFor is a helper method to define mock.On call
//   - ctx context.Context
//   - workRequestID string
func (_e *MockworkRequestsWatcher_Expecter) WaitFor(ctx interface{}, workRequestID interface{}) *MockworkRequestsWatcher_WaitFor_Call <span class="cov8" title="11">{
        return &amp;MockworkRequestsWatcher_WaitFor_Call{Call: _e.mock.On("WaitFor", ctx, workRequestID)}
}</span>

func (_c *MockworkRequestsWatcher_WaitFor_Call) Run(run func(ctx context.Context, workRequestID string)) *MockworkRequestsWatcher_WaitFor_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockworkRequestsWatcher_WaitFor_Call) Return(_a0 error) *MockworkRequestsWatcher_WaitFor_Call <span class="cov8" title="11">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockworkRequestsWatcher_WaitFor_Call) RunAndReturn(run func(context.Context, string) error) *MockworkRequestsWatcher_WaitFor_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockworkRequestsWatcher creates a new instance of MockworkRequestsWatcher. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockworkRequestsWatcher(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockworkRequestsWatcher <span class="cov10" title="19">{
        mock := &amp;MockworkRequestsWatcher{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="19">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="19">return mock</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package app

import (
        "context"
        "fmt"
        "log/slog"
        "net/http"

        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/loadbalancer"
        "github.com/samber/lo"
        "go.uber.org/dig"
        gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
)

const defaultBackendSetPort = 80

type reconcileDefaultBackendParams struct {
        loadBalancerID   string
        knownBackendSets map[string]loadbalancer.BackendSet
        gateway          *gatewayv1.Gateway
}

type reconcileBackendSetParams struct {
        loadBalancerID string
        name           string
        healthChecker  *loadbalancer.HealthCheckerDetails
}

type reconcileHTTPListenerParams struct {
        loadBalancerID        string
        knownListeners        map[string]loadbalancer.Listener
        defaultBackendSetName string
        listenerSpec          *gatewayv1.Listener
}

type ociLoadBalancerModel interface {
        reconcileDefaultBackendSet(
                ctx context.Context,
                params reconcileDefaultBackendParams,
        ) (loadbalancer.BackendSet, error)
        reconcileHTTPListener(
                ctx context.Context,
                params reconcileHTTPListenerParams,
        ) (loadbalancer.Listener, error)

        // TODO: It may not need to return the backend set
        // review and update
        reconcileBackendSet(
                ctx context.Context,
                params reconcileBackendSetParams,
        ) (loadbalancer.BackendSet, error)
}

type ociLoadBalancerModelImpl struct {
        ociClient           ociLoadBalancerClient
        logger              *slog.Logger
        workRequestsWatcher workRequestsWatcher
}

func (m *ociLoadBalancerModelImpl) reconcileDefaultBackendSet(
        ctx context.Context,
        params reconcileDefaultBackendParams,
) (loadbalancer.BackendSet, error) <span class="cov6" title="5">{
        defaultBackendSetName := params.gateway.Name + "-default"
        if _, ok := params.knownBackendSets[defaultBackendSetName]; ok </span><span class="cov1" title="1">{
                m.logger.DebugContext(ctx, "Default backend set already exists",
                        slog.String("loadBalancerId", params.loadBalancerID),
                        slog.String("backendName", defaultBackendSetName),
                )
                return params.knownBackendSets[defaultBackendSetName], nil
        }</span>

        <span class="cov5" title="4">m.logger.InfoContext(ctx, "Default backend set not found, creating",
                slog.String("loadBalancerId", params.loadBalancerID),
                slog.String("name", defaultBackendSetName),
        )
        createRes, err := m.ociClient.CreateBackendSet(ctx, loadbalancer.CreateBackendSetRequest{
                LoadBalancerId: &amp;params.loadBalancerID,
                CreateBackendSetDetails: loadbalancer.CreateBackendSetDetails{
                        Name:   &amp;defaultBackendSetName,
                        Policy: lo.ToPtr("ROUND_ROBIN"),
                        HealthChecker: &amp;loadbalancer.HealthCheckerDetails{
                                Protocol: lo.ToPtr("TCP"),
                                Port:     lo.ToPtr(int(defaultBackendSetPort)),
                        },
                },
        })
        if err != nil </span><span class="cov1" title="1">{
                return loadbalancer.BackendSet{},
                        fmt.Errorf("failed to create default backend set %s: %w", defaultBackendSetName, err)
        }</span>

        <span class="cov4" title="3">if err = m.workRequestsWatcher.WaitFor(
                ctx,
                *createRes.OpcWorkRequestId,
        ); err != nil </span><span class="cov1" title="1">{
                return loadbalancer.BackendSet{},
                        fmt.Errorf("failed to wait for default backend set %s: %w", defaultBackendSetName, err)
        }</span>

        <span class="cov3" title="2">res, err := m.ociClient.GetBackendSet(ctx, loadbalancer.GetBackendSetRequest{
                BackendSetName: &amp;defaultBackendSetName,
                LoadBalancerId: lo.ToPtr(params.loadBalancerID),
        })
        if err != nil </span><span class="cov1" title="1">{
                return loadbalancer.BackendSet{}, fmt.Errorf("failed to get default backend set %s: %w", defaultBackendSetName, err)
        }</span>

        <span class="cov1" title="1">return res.BackendSet, nil</span>
}

func (m *ociLoadBalancerModelImpl) reconcileHTTPListener(
        ctx context.Context,
        params reconcileHTTPListenerParams,
) (loadbalancer.Listener, error) <span class="cov6" title="5">{
        listenerName := string(params.listenerSpec.Name)
        if _, ok := params.knownListeners[listenerName]; ok </span><span class="cov1" title="1">{
                m.logger.DebugContext(ctx, "Listener already exists",
                        slog.String("loadBalancerId", params.loadBalancerID),
                        slog.String("listenerName", listenerName),
                )
                return params.knownListeners[listenerName], nil
        }</span>

        <span class="cov5" title="4">m.logger.InfoContext(ctx, "Listener not found, creating",
                slog.String("loadBalancerId", params.loadBalancerID),
                slog.String("name", listenerName),
        )

        createRes, err := m.ociClient.CreateListener(ctx, loadbalancer.CreateListenerRequest{
                LoadBalancerId: &amp;params.loadBalancerID,
                CreateListenerDetails: loadbalancer.CreateListenerDetails{
                        Name:                  lo.ToPtr(listenerName),
                        DefaultBackendSetName: lo.ToPtr(params.defaultBackendSetName),
                        Port:                  lo.ToPtr(int(params.listenerSpec.Port)),
                        Protocol:              lo.ToPtr(string(params.listenerSpec.Protocol)),
                },
        })
        if err != nil </span><span class="cov1" title="1">{
                return loadbalancer.Listener{}, fmt.Errorf("failed to create listener %s: %w", listenerName, err)
        }</span>

        <span class="cov4" title="3">if err = m.workRequestsWatcher.WaitFor(
                ctx,
                *createRes.OpcWorkRequestId,
        ); err != nil </span><span class="cov1" title="1">{
                return loadbalancer.Listener{}, fmt.Errorf("failed to wait for listener %s: %w", listenerName, err)
        }</span>

        <span class="cov3" title="2">res, err := m.ociClient.GetLoadBalancer(ctx, loadbalancer.GetLoadBalancerRequest{
                LoadBalancerId: lo.ToPtr(params.loadBalancerID),
        })
        if err != nil </span><span class="cov1" title="1">{
                return loadbalancer.Listener{}, fmt.Errorf("failed to get listener %s: %w", listenerName, err)
        }</span>

        // TODO: fail if listener is still not there

        <span class="cov1" title="1">return res.LoadBalancer.Listeners[listenerName], nil</span>
}

func (m *ociLoadBalancerModelImpl) reconcileBackendSet(
        ctx context.Context,
        params reconcileBackendSetParams,
) (loadbalancer.BackendSet, error) <span class="cov6" title="5">{
        m.logger.InfoContext(ctx, "Reconciling backend set",
                slog.String("loadBalancerId", params.loadBalancerID),
                slog.String("backendSetName", params.name),
        )

        existingBsFound := true
        existingBs, err := m.ociClient.GetBackendSet(ctx, loadbalancer.GetBackendSetRequest{
                BackendSetName: &amp;params.name,
                LoadBalancerId: &amp;params.loadBalancerID,
        })
        if err != nil </span><span class="cov5" title="4">{
                serviceErr, ok := common.IsServiceError(err)
                if !ok || serviceErr.GetHTTPStatusCode() != http.StatusNotFound </span><span class="cov0" title="0">{
                        return loadbalancer.BackendSet{}, fmt.Errorf("failed to get backend set %s: %w", params.name, err)
                }</span>
                <span class="cov5" title="4">existingBsFound = false</span>
        }

        <span class="cov6" title="5">if existingBsFound </span><span class="cov1" title="1">{
                m.logger.DebugContext(ctx, "Backend set found",
                        slog.String("loadBalancerId", params.loadBalancerID),
                        slog.String("backendSetName", params.name),
                )

                // TODO: Logic to update backend set

                return existingBs.BackendSet, nil
        }</span>

        <span class="cov5" title="4">m.logger.DebugContext(ctx, "Backend set not found, creating",
                slog.String("loadBalancerId", params.loadBalancerID),
                slog.String("backendSetName", params.name),
        )

        createRes, err := m.ociClient.CreateBackendSet(ctx, loadbalancer.CreateBackendSetRequest{
                LoadBalancerId: lo.ToPtr(params.loadBalancerID),
                CreateBackendSetDetails: loadbalancer.CreateBackendSetDetails{
                        Name:          &amp;params.name,
                        HealthChecker: params.healthChecker,
                        Policy:        lo.ToPtr("ROUND_ROBIN"),
                },
        })

        if err != nil </span><span class="cov1" title="1">{
                return loadbalancer.BackendSet{}, fmt.Errorf("failed to create backend set %s: %w", params.name, err)
        }</span>

        <span class="cov4" title="3">if err = m.workRequestsWatcher.WaitFor(
                ctx,
                *createRes.OpcWorkRequestId,
        ); err != nil </span><span class="cov1" title="1">{
                return loadbalancer.BackendSet{}, fmt.Errorf("failed to wait for backend set %s: %w", params.name, err)
        }</span>

        <span class="cov3" title="2">res, err := m.ociClient.GetBackendSet(ctx, loadbalancer.GetBackendSetRequest{
                BackendSetName: &amp;params.name,
                LoadBalancerId: lo.ToPtr(params.loadBalancerID),
        })
        if err != nil </span><span class="cov1" title="1">{
                return loadbalancer.BackendSet{}, fmt.Errorf("failed to get backend set %s: %w", params.name, err)
        }</span>

        <span class="cov1" title="1">return res.BackendSet, nil</span>
}

type ociLoadBalancerModelDeps struct {
        dig.In

        RootLogger          *slog.Logger
        OciClient           ociLoadBalancerClient
        WorkRequestsWatcher workRequestsWatcher
}

func newOciLoadBalancerModel(deps ociLoadBalancerModelDeps) ociLoadBalancerModel <span class="cov10" title="16">{
        return &amp;ociLoadBalancerModelImpl{
                logger:              deps.RootLogger.WithGroup("oci-load-balancer-model"),
                ociClient:           deps.OciClient,
                workRequestsWatcher: deps.WorkRequestsWatcher,
        }
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package app

import (
        "github.com/gemyago/oke-gateway-api/internal/di"
        "github.com/gemyago/oke-gateway-api/internal/services/ociapi"
        "github.com/oracle/oci-go-sdk/v65/loadbalancer"
        "go.uber.org/dig"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

func Register(container *dig.Container) error <span class="cov8" title="1">{
        return di.ProvideAll(container,
                func(c client.Client) k8sClient </span><span class="cov8" title="1">{ return c }</span>,
                func(c loadbalancer.LoadBalancerClient) ociLoadBalancerClient <span class="cov8" title="1">{ return c }</span>,
                func(w *ociapi.WorkRequestsWatcher) workRequestsWatcher <span class="cov8" title="1">{ return w }</span>,
                NewGatewayClassController,
                NewGatewayController,
                NewHTTPRouteController,
                newResourcesModel,
                newGatewayModel,
                newHTTPRouteModel,
                newOciLoadBalancerModel,
                newHTTPBackendModel,
                NewWatchesModel,
        )
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package app

import (
        "context"
        "fmt"
        "log/slog"

        "go.uber.org/dig"
        "k8s.io/apimachinery/pkg/api/meta"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

type setConditionParams struct {
        resource      client.Object
        conditions    *[]metav1.Condition
        conditionType string
        status        metav1.ConditionStatus
        reason        string
        message       string
}

type resourcesModel interface {
        // setCondition sets a condition on a given resource.
        setCondition(ctx context.Context, params setConditionParams) error

        // isConditionSet checks if a specific condition is already set, true, and observed at the correct generation.
        isConditionSet(resource client.Object, conditions []metav1.Condition, conditionType string) bool
}

type resourcesModelImpl struct {
        client k8sClient
        logger *slog.Logger
}

func (m *resourcesModelImpl) setCondition(ctx context.Context, params setConditionParams) error <span class="cov5" title="2">{
        m.logger.DebugContext(ctx,
                fmt.Sprintf("Setting %s condition", params.conditionType),
                slog.String("resource", params.resource.GetName()),
                slog.String("status", string(params.status)),
                slog.String("reason", params.reason),
                slog.String("message", params.message),
        )

        generation := params.resource.GetGeneration()

        acceptedCondition := metav1.Condition{
                Type:               params.conditionType,
                Status:             params.status,
                Reason:             params.reason,
                Message:            params.message,
                ObservedGeneration: generation,
                LastTransitionTime: metav1.Now(),
        }

        meta.SetStatusCondition(params.conditions, acceptedCondition)

        if err := m.client.Status().Update(ctx, params.resource); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to update status for %s: %w", params.resource.GetName(), err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (m *resourcesModelImpl) isConditionSet(
        resource client.Object,
        conditions []metav1.Condition,
        conditionType string) bool <span class="cov10" title="4">{
        existingCondition := meta.FindStatusCondition(conditions, conditionType)
        if existingCondition != nil &amp;&amp;
                existingCondition.ObservedGeneration == resource.GetGeneration() </span><span class="cov1" title="1">{
                return true
        }</span>
        <span class="cov8" title="3">return false</span>
}

type resourcesModelDeps struct {
        dig.In

        K8sClient  k8sClient
        RootLogger *slog.Logger
}

func newResourcesModel(deps resourcesModelDeps) resourcesModel <span class="cov10" title="4">{
        return &amp;resourcesModelImpl{
                client: deps.K8sClient,
                logger: deps.RootLogger.WithGroup("resources-model"),
        }
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package app

import (
        "context"
        "fmt"
        "log/slog"
        "path"

        "github.com/gemyago/oke-gateway-api/internal/diag"
        "github.com/samber/lo"
        "go.uber.org/dig"
        discoveryv1 "k8s.io/api/discovery/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
)

const httpRouteBackendServiceIndexKey = ".metadata.backendRefs.serviceName" // Virtual field name, indexed

// WatchesModel implements the WatchesModel interface.
type WatchesModel struct {
        k8sClient k8sClient
        logger    *slog.Logger
}

type WatchesModelDeps struct {
        dig.In

        K8sClient k8sClient
        Logger    *slog.Logger
}

// NewWatchesModel creates a new watchesModel.
func NewWatchesModel(deps WatchesModelDeps) *WatchesModel <span class="cov8" title="12">{
        return &amp;WatchesModel{
                k8sClient: deps.K8sClient,
                logger:    deps.Logger.WithGroup("watches-model"),
        }
}</span>

// RegisterFieldIndexers registers the indexers for the watches model.
func (m *WatchesModel) RegisterFieldIndexers(ctx context.Context, indexer client.FieldIndexer) error <span class="cov3" title="2">{
        if err := indexer.IndexField(ctx,
                &amp;gatewayv1.HTTPRoute{},
                httpRouteBackendServiceIndexKey,
                func(o client.Object) []string </span><span class="cov0" title="0">{
                        return m.indexHTTPRouteByBackendService(ctx, o)
                }</span>,
        ); err != nil <span class="cov1" title="1">{
                return fmt.Errorf("failed to index HTTPRoute by backend service: %w", err)
        }</span>
        <span class="cov1" title="1">m.logger.DebugContext(ctx, "Field indexers registered",
                slog.String("indexKey", httpRouteBackendServiceIndexKey),
        )
        return nil</span>
}

// indexHTTPRouteByBackendService extracts the namespaced names of Services referenced
// in an HTTPRoute's backendRefs. This is used to create an index for efficient
// lookup when an EndpointSlice changes.
func (m *WatchesModel) indexHTTPRouteByBackendService(ctx context.Context, obj client.Object) []string <span class="cov5" title="4">{
        httpRoute, isRoute := obj.(*gatewayv1.HTTPRoute)
        if !isRoute </span><span class="cov1" title="1">{
                m.logger.WarnContext(ctx, "Received non-HTTPRoute object", slog.Any("object", obj))
                return nil
        }</span>

        <span class="cov4" title="3">uniqueServiceKeys := make(map[string]struct{})
        for _, rule := range httpRoute.Spec.Rules </span><span class="cov6" title="6">{
                for _, backendRef := range rule.BackendRefs </span><span class="cov10" title="17">{
                        ns := httpRoute.Namespace
                        if backendRef.BackendObjectReference.Namespace != nil </span><span class="cov9" title="15">{
                                ns = string(*backendRef.BackendObjectReference.Namespace)
                        }</span>
                        <span class="cov10" title="17">namespacedName := path.Join(
                                ns,
                                string(backendRef.BackendObjectReference.Name),
                        )
                        if _, ok := uniqueServiceKeys[namespacedName]; !ok </span><span class="cov9" title="14">{
                                uniqueServiceKeys[namespacedName] = struct{}{}
                        }</span>
                }
        }

        <span class="cov4" title="3">serviceKeys := lo.Keys(uniqueServiceKeys)
        m.logger.DebugContext(ctx, "Indexed HTTPRoute by backend service",
                slog.String("httpRoute", client.ObjectKeyFromObject(httpRoute).String()),
                slog.String("indexKey", httpRouteBackendServiceIndexKey),
                slog.Any("serviceKeys", serviceKeys),
        )

        return serviceKeys</span>
}

// MapEndpointSliceToHTTPRoute maps EndpointSlice events to HTTPRoute reconcile requests.
// Its signature matches handler.MapFunc.
func (m *WatchesModel) MapEndpointSliceToHTTPRoute(ctx context.Context, obj client.Object) []reconcile.Request <span class="cov6" title="5">{
        epSlice, ok := obj.(*discoveryv1.EndpointSlice)
        if !ok </span><span class="cov1" title="1">{
                m.logger.WarnContext(ctx, "Received non-EndpointSlice object", slog.Any("object", obj))
                return nil
        }</span>

        <span class="cov5" title="4">svcName, ok := epSlice.Labels[discoveryv1.LabelServiceName]
        if !ok </span><span class="cov1" title="1">{
                m.logger.WarnContext(ctx, "EndpointSlice missing service name label", slog.Any("endpointSlice", epSlice))
                return nil
        }</span>

        <span class="cov4" title="3">ns := epSlice.Namespace
        indexKey := path.Join(ns, svcName)

        var routeList gatewayv1.HTTPRouteList
        // TODO: Fetch all pages?
        if err := m.k8sClient.List(
                ctx,
                &amp;routeList,
                client.MatchingFields{httpRouteBackendServiceIndexKey: indexKey},
        ); err != nil </span><span class="cov1" title="1">{
                m.logger.ErrorContext(ctx,
                        "Failed to list HTTPRoutes for service",
                        slog.String("indexKey", indexKey),
                        diag.ErrAttr(err),
                )
                return nil
        }</span>

        <span class="cov3" title="2">if len(routeList.Items) == 0 </span><span class="cov1" title="1">{
                m.logger.DebugContext(
                        ctx,
                        "No HTTPRoutes found for service",
                        slog.String("service", svcName),
                        slog.String("indexKey", indexKey),
                )
                return nil
        }</span>

        <span class="cov1" title="1">requests := make([]reconcile.Request, len(routeList.Items))
        for i, route := range routeList.Items </span><span class="cov3" title="2">{
                requests[i] = reconcile.Request{
                        NamespacedName: client.ObjectKeyFromObject(&amp;route),
                }
                m.logger.InfoContext(ctx,
                        "Queueing HTTPRoute for reconciliation due to EndpointSlice change",
                        slog.String("httpRoute", client.ObjectKeyFromObject(&amp;route).String()),
                        slog.String("endpointSlice", client.ObjectKeyFromObject(epSlice).String()),
                )
        }</span>

        <span class="cov1" title="1">return requests</span>
}

// Note: indexHTTPRouteByBackendService and httpRouteBackendServiceIndexKey removed as part of stubbing.
</pre>
		
		<pre class="file" id="file32" style="display: none">package config

import (
        "embed"
        "fmt"
        "strings"

        "github.com/spf13/viper"
)

//go:embed *.json
var resources embed.FS

func mergeResourceCfg(cfg *viper.Viper, resourceName string) error <span class="cov10" title="19">{
        resourceStream, err := resources.Open(resourceName)
        if err != nil </span><span class="cov5" title="4">{
                return fmt.Errorf("failed to read config %v: %w", resourceName, err)
        }</span>
        <span class="cov9" title="15">defer resourceStream.Close()

        if err = cfg.MergeConfig(resourceStream); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config %v: %w", resourceName, err)
        }</span>
        <span class="cov9" title="15">return nil</span>
}

type LoadOpts struct {
        env                   string
        defaultConfigFileName string
}

func (opts *LoadOpts) WithEnv(val string) *LoadOpts <span class="cov7" title="8">{
        if val != "" </span><span class="cov5" title="4">{
                opts.env = val
        }</span>
        <span class="cov7" title="8">return opts</span>
}

func NewLoadOpts() *LoadOpts <span class="cov8" title="10">{
        return &amp;LoadOpts{
                env:                   "local",
                defaultConfigFileName: "default.json",
        }
}</span>

func New() *viper.Viper <span class="cov8" title="10">{
        v := viper.New()
        v.SetEnvPrefix("APP")
        v.SetConfigType("json")
        v.SetEnvKeyReplacer(
                strings.NewReplacer("-", "_", ".", "_"),
        )
        v.AutomaticEnv()
        return v
}</span>

func Load(cfg *viper.Viper, opts *LoadOpts) error <span class="cov8" title="10">{
        if err := mergeResourceCfg(cfg, opts.defaultConfigFileName); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov7" title="9">if err := mergeResourceCfg(cfg, opts.env+".json"); err != nil </span><span class="cov4" title="3">{
                return err
        }</span>

        // Some common aliases to have cli params with the same name as config keys
        <span class="cov6" title="6">cfg.RegisterAlias("defaultLogLevel", "log-level")
        cfg.RegisterAlias("jsonLogs", "json-logs")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package config

import (
        "fmt"

        "github.com/gemyago/oke-gateway-api/internal/di"
        "github.com/spf13/viper"
        "go.uber.org/dig"
)

type configValueProvider struct {
        cfg        *viper.Viper
        configPath string
        diPath     string
}

func provideConfigValue(cfg *viper.Viper, path string) configValueProvider <span class="cov10" title="28">{
        if !cfg.IsSet(path) </span><span class="cov1" title="1">{
                panic(fmt.Errorf("config key not found: %s", path))</span>
        }
        <span class="cov9" title="27">return configValueProvider{cfg, path, "config." + path}</span>
}

func (p configValueProvider) asInt() di.ConstructorWithOpts <span class="cov3" title="3">{
        return di.ProvideValue(p.cfg.GetInt(p.configPath), dig.Name(p.diPath))
}</span>

func (p configValueProvider) asInt32() di.ConstructorWithOpts <span class="cov1" title="1">{
        return di.ProvideValue(p.cfg.GetInt32(p.configPath), dig.Name(p.diPath))
}</span>

func (p configValueProvider) asString() di.ConstructorWithOpts <span class="cov6" title="7">{
        return di.ProvideValue(p.cfg.GetString(p.configPath), dig.Name(p.diPath))
}</span>

func (p configValueProvider) asBool() di.ConstructorWithOpts <span class="cov5" title="5">{
        return di.ProvideValue(p.cfg.GetBool(p.configPath), dig.Name(p.diPath))
}</span>

func (p configValueProvider) asDuration() di.ConstructorWithOpts <span class="cov7" title="11">{
        return di.ProvideValue(p.cfg.GetDuration(p.configPath), dig.Name(p.diPath))
}</span>

func Provide(container *dig.Container, cfg *viper.Viper) error <span class="cov2" title="2">{
        return di.ProvideAll(container,
                provideConfigValue(cfg, "gracefulShutdownTimeout").asDuration(),

                // http server config
                provideConfigValue(cfg, "httpServer.host").asString(),
                provideConfigValue(cfg, "httpServer.port").asInt(),
                provideConfigValue(cfg, "httpServer.idleTimeout").asDuration(),
                provideConfigValue(cfg, "httpServer.readHeaderTimeout").asDuration(),
                provideConfigValue(cfg, "httpServer.readTimeout").asDuration(),
                provideConfigValue(cfg, "httpServer.writeTimeout").asDuration(),
                provideConfigValue(cfg, "httpServer.mode").asString(),
                provideConfigValue(cfg, "httpServer.accessLogsLevel").asString(),

                // k8sapi config
                provideConfigValue(cfg, "k8sapi.noop").asBool(),

                // ociapi config
                provideConfigValue(cfg, "ociapi.noop").asBool(),
        )
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package di

import (
        "fmt"
        "reflect"

        "go.uber.org/dig"
)

// Dig is used as DI toolkit https://pkg.go.dev/go.uber.org/dig
// we are not creating any abstraction over it, but we do have a set of tools to make it easier to use

type ConstructorWithOpts struct {
        Constructor interface{}
        Options     []dig.ProvideOption
}

func ProvideAll(container *dig.Container, providers ...interface{}) error <span class="cov7" title="23">{
        for i, provider := range providers </span><span class="cov10" title="71">{
                switch p := provider.(type) </span>{
                case ConstructorWithOpts:<span class="cov8" title="36">
                        if err := container.Provide(p.Constructor, p.Options...); err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to provide %d-th dependency: %w", i, err)
                        }</span>
                default:<span class="cov8" title="35">
                        if err := container.Provide(provider); err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to provide %d-th dependency: %w", i, err)
                        }</span>
                }
        }
        <span class="cov7" title="21">return nil</span>
}

// ProvideValue will create a constructor (e.g func) from a given value.
func ProvideValue[T any](val T, opts ...dig.ProvideOption) ConstructorWithOpts <span class="cov8" title="37">{
        return ConstructorWithOpts{
                Constructor: func() T </span><span class="cov7" title="23">{ return val }</span>,
                Options:     opts,
        }
}

// ProvideWithArg will create a constructor with a first arg explicitly provided
// supposed return no error.
func ProvideWithArg[
        TArg any,
        TConstructorArg any,
        TRes any,
](
        arg TArg,
        constructor func(arg TArg, cArg TConstructorArg) TRes,
) func(TConstructorArg) TRes <span class="cov1" title="1">{
        return func(cArg TConstructorArg) TRes </span><span class="cov1" title="1">{
                return constructor(arg, cArg)
        }</span>
}

// ProvideWithArgErr will create a constructor with a first arg explicitly provided
// supposed return an error.
func ProvideWithArgErr[
        TArg any,
        TConstructorArg any,
        TDep any,
](
        arg TArg,
        constructor func(arg TArg, cArg TConstructorArg) (TDep, error),
) func(TConstructorArg) (TDep, error) <span class="cov1" title="1">{
        return func(cArg TConstructorArg) (TDep, error) </span><span class="cov1" title="1">{
                return constructor(arg, cArg)
        }</span>
}

// ProvideAs is used to provide one type as another, typically
// used to provide implementation struct as particular interface.
func ProvideAs[TSource any, TTarget any](source TSource) (TTarget, error) <span class="cov2" title="2">{
        target, ok := any(source).(TTarget)
        if !ok </span><span class="cov1" title="1">{
                var src TSource
                var tgt TTarget
                return target, fmt.Errorf("failed to cast %s to %s", reflect.TypeOf(src), reflect.TypeOf(tgt))
        }</span>
        <span class="cov1" title="1">return target, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package diag

import "log/slog"

func ErrAttr(err error) slog.Attr <span class="cov10" title="5">{
        return slog.Any("err", err)
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package diag

import (
        context "context"
        slog "log/slog"

        mock "github.com/stretchr/testify/mock"
)

// MockSlogHandler is an autogenerated mock type for the Handler type
type MockSlogHandler struct {
        mock.Mock
}

type MockSlogHandler_Expecter struct {
        mock *mock.Mock
}

func (_m *MockSlogHandler) EXPECT() *MockSlogHandler_Expecter <span class="cov8" title="3">{
        return &amp;MockSlogHandler_Expecter{mock: &amp;_m.Mock}
}</span>

// Enabled provides a mock function with given fields: _a0, _a1
func (_m *MockSlogHandler) Enabled(_a0 context.Context, _a1 slog.Level) bool <span class="cov0" title="0">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Enabled")</span>
        }

        <span class="cov0" title="0">var r0 bool
        if rf, ok := ret.Get(0).(func(context.Context, slog.Level) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockSlogHandler_Enabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Enabled'
type MockSlogHandler_Enabled_Call struct {
        *mock.Call
}

// Enabled is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 slog.Level
func (_e *MockSlogHandler_Expecter) Enabled(_a0 interface{}, _a1 interface{}) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        return &amp;MockSlogHandler_Enabled_Call{Call: _e.mock.On("Enabled", _a0, _a1)}
}</span>

func (_c *MockSlogHandler_Enabled_Call) Run(run func(_a0 context.Context, _a1 slog.Level)) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(slog.Level))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_Enabled_Call) Return(_a0 bool) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_Enabled_Call) RunAndReturn(run func(context.Context, slog.Level) bool) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Handle provides a mock function with given fields: _a0, _a1
func (_m *MockSlogHandler) Handle(_a0 context.Context, _a1 slog.Record) error <span class="cov5" title="2">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Handle")</span>
        }

        <span class="cov5" title="2">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, slog.Record) error); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov5" title="2"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov5" title="2">return r0</span>
}

// MockSlogHandler_Handle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Handle'
type MockSlogHandler_Handle_Call struct {
        *mock.Call
}

// Handle is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 slog.Record
func (_e *MockSlogHandler_Expecter) Handle(_a0 interface{}, _a1 interface{}) *MockSlogHandler_Handle_Call <span class="cov5" title="2">{
        return &amp;MockSlogHandler_Handle_Call{Call: _e.mock.On("Handle", _a0, _a1)}
}</span>

func (_c *MockSlogHandler_Handle_Call) Run(run func(_a0 context.Context, _a1 slog.Record)) *MockSlogHandler_Handle_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(slog.Record))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_Handle_Call) Return(_a0 error) *MockSlogHandler_Handle_Call <span class="cov5" title="2">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_Handle_Call) RunAndReturn(run func(context.Context, slog.Record) error) *MockSlogHandler_Handle_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// WithAttrs provides a mock function with given fields: attrs
func (_m *MockSlogHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov1" title="1">{
        ret := _m.Called(attrs)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for WithAttrs")</span>
        }

        <span class="cov1" title="1">var r0 slog.Handler
        if rf, ok := ret.Get(0).(func([]slog.Attr) slog.Handler); ok </span><span class="cov0" title="0">{
                r0 = rf(attrs)
        }</span> else<span class="cov1" title="1"> {
                if ret.Get(0) != nil </span><span class="cov1" title="1">{
                        r0 = ret.Get(0).(slog.Handler)
                }</span>
        }

        <span class="cov1" title="1">return r0</span>
}

// MockSlogHandler_WithAttrs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithAttrs'
type MockSlogHandler_WithAttrs_Call struct {
        *mock.Call
}

// WithAttrs is a helper method to define mock.On call
//   - attrs []slog.Attr
func (_e *MockSlogHandler_Expecter) WithAttrs(attrs interface{}) *MockSlogHandler_WithAttrs_Call <span class="cov1" title="1">{
        return &amp;MockSlogHandler_WithAttrs_Call{Call: _e.mock.On("WithAttrs", attrs)}
}</span>

func (_c *MockSlogHandler_WithAttrs_Call) Run(run func(attrs []slog.Attr)) *MockSlogHandler_WithAttrs_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].([]slog.Attr))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_WithAttrs_Call) Return(_a0 slog.Handler) *MockSlogHandler_WithAttrs_Call <span class="cov1" title="1">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_WithAttrs_Call) RunAndReturn(run func([]slog.Attr) slog.Handler) *MockSlogHandler_WithAttrs_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// WithGroup provides a mock function with given fields: name
func (_m *MockSlogHandler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        ret := _m.Called(name)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for WithGroup")</span>
        }

        <span class="cov0" title="0">var r0 slog.Handler
        if rf, ok := ret.Get(0).(func(string) slog.Handler); ok </span><span class="cov0" title="0">{
                r0 = rf(name)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(slog.Handler)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// MockSlogHandler_WithGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithGroup'
type MockSlogHandler_WithGroup_Call struct {
        *mock.Call
}

// WithGroup is a helper method to define mock.On call
//   - name string
func (_e *MockSlogHandler_Expecter) WithGroup(name interface{}) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        return &amp;MockSlogHandler_WithGroup_Call{Call: _e.mock.On("WithGroup", name)}
}</span>

func (_c *MockSlogHandler_WithGroup_Call) Run(run func(name string)) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_WithGroup_Call) Return(_a0 slog.Handler) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_WithGroup_Call) RunAndReturn(run func(string) slog.Handler) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockSlogHandler creates a new instance of MockSlogHandler. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSlogHandler(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockSlogHandler <span class="cov10" title="4">{
        mock := &amp;MockSlogHandler{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="4">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="4">return mock</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package diag

import (
        "context"
        "io"
        "log/slog"
        "os"
)

type contextKey string

const (
        contextDiagAttrs = contextKey("diag.context-key.log-attribs")
)

type LogAttributes struct {
        CorrelationID slog.Value
}

func GetLogAttributesFromContext(ctx context.Context) LogAttributes <span class="cov4" title="9">{
        res, _ := ctx.Value(contextDiagAttrs).(LogAttributes)
        return res
}</span>

func SetLogAttributesToContext(ctx context.Context, attributes LogAttributes) context.Context <span class="cov4" title="6">{
        return context.WithValue(ctx, contextDiagAttrs, attributes)
}</span>

type diagLogHandler struct {
        target slog.Handler
}

func (h *diagLogHandler) Enabled(ctx context.Context, lvl slog.Level) bool <span class="cov10" title="147">{
        return h.target.Enabled(ctx, lvl)
}</span>

func (h *diagLogHandler) Handle(ctx context.Context, rec slog.Record) error <span class="cov9" title="92">{
        if diagAttributes, ok := ctx.Value(contextDiagAttrs).(LogAttributes); ok </span><span class="cov2" title="2">{
                rec.AddAttrs(
                        slog.Attr{Key: "correlationId", Value: diagAttributes.CorrelationID},
                )
        }</span>

        <span class="cov9" title="92">return h.target.Handle(ctx, rec)</span>
}

func (h *diagLogHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov9" title="127">{
        return &amp;diagLogHandler{target: h.target.WithAttrs(attrs)}
}</span>

func (h *diagLogHandler) WithGroup(name string) slog.Handler <span class="cov9" title="126">{
        // Using WithAttrs here since group will nest all the attributes
        // inside of it (including correlationId), which makes it harder to
        // filter logs by the correlationId.
        // Consumers can use slog.Group if some attributes needs to be grouped
        return h.WithAttrs([]slog.Attr{slog.String("group", name)})
}</span>

var _ slog.Handler = &amp;diagLogHandler{}

type RootLoggerOpts struct {
        output io.Writer

        jsonLogs bool

        // Info is default (zero)
        logLevel slog.Level
}

func (opts *RootLoggerOpts) WithJSONLogs(value bool) *RootLoggerOpts <span class="cov2" title="3">{
        opts.jsonLogs = value
        return opts
}</span>

func (opts *RootLoggerOpts) WithLogLevel(logLevel slog.Level) *RootLoggerOpts <span class="cov2" title="3">{
        opts.logLevel = logLevel
        return opts
}</span>

func (opts *RootLoggerOpts) WithOutput(output io.Writer) *RootLoggerOpts <span class="cov9" title="120">{
        opts.output = output
        return opts
}</span>

func (opts *RootLoggerOpts) WithOptionalOutputFile(outputFile string) *RootLoggerOpts <span class="cov2" title="3">{
        if outputFile == "" </span><span class="cov1" title="1">{
                return opts
        }</span>
        <span class="cov2" title="2">f, err := os.OpenFile(outputFile, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0o666)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov2" title="2">opts.output = f
        return opts</span>
}

func NewRootLoggerOpts() *RootLoggerOpts <span class="cov9" title="124">{
        return &amp;RootLoggerOpts{
                output: os.Stdout,
        }
}</span>

func SetupRootLogger(opts *RootLoggerOpts) *slog.Logger <span class="cov9" title="124">{
        logHandlerOpts := &amp;slog.HandlerOptions{Level: opts.logLevel}
        var logHandler slog.Handler
        if opts.jsonLogs </span><span class="cov1" title="1">{
                logHandler = slog.NewJSONHandler(opts.output, logHandlerOpts)
        }</span> else<span class="cov9" title="123"> {
                logHandler = slog.NewTextHandler(opts.output, logHandlerOpts)
        }</span>
        <span class="cov9" title="124">return slog.New(&amp;diagLogHandler{target: logHandler})</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">//go:build !release

// TODO: generated code should include "//go:build !release" tags
//go:generate mockgen -typed -package diag -destination mock_slog_handler_test.go log/slog Handler

package diag

import (
        "fmt"
        "log/slog"
        "os"
        "path/filepath"
        "runtime"
)

// openTestLogFile will open a log file in a project root directory.
func openTestLogFile() *os.File <span class="cov5" title="10">{
        _, filename, _, _ := runtime.Caller(0) // Will be current file
        testFilePath := filepath.Join(filename, "..", "..", "..", "test.log")
        f, err := os.OpenFile(testFilePath, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0o666)
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("fail to open log file %q for test logging: %w", testFilePath, err)
                panic(err)</span>
        }
        <span class="cov5" title="10">return f</span>
}

var testOutput = openTestLogFile() //nolint:gochecknoglobals //it's ok for tests

func RootTestLogger() *slog.Logger <span class="cov10" title="119">{
        return SetupRootLogger(
                NewRootLoggerOpts().WithOutput(testOutput),
        )
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package k8s

import (
        "context"
        "errors"
        "log/slog"

        "github.com/gemyago/oke-gateway-api/internal/app"
        "github.com/gemyago/oke-gateway-api/internal/diag"
        "github.com/google/uuid"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

type controllerMiddleware[request comparable] func(
        next reconcile.TypedReconciler[request],
) reconcile.TypedReconciler[request]

func newTracingMiddleware() controllerMiddleware[reconcile.Request] <span class="cov1" title="1">{
        return func(next reconcile.TypedReconciler[reconcile.Request]) reconcile.TypedReconciler[reconcile.Request] </span><span class="cov1" title="1">{
                return reconcile.TypedFunc[reconcile.Request](
                        func(ctx context.Context, req reconcile.Request) (reconcile.Result, error) </span><span class="cov1" title="1">{
                                diagCtx := diag.SetLogAttributesToContext(ctx, diag.LogAttributes{
                                        CorrelationID: slog.StringValue(uuid.New().String()),
                                })
                                return next.Reconcile(diagCtx, req)
                        }</span>,
                )
        }
}

func newErrorHandlingMiddleware(
        logger *slog.Logger,
) controllerMiddleware[reconcile.Request] <span class="cov10" title="3">{
        return func(next reconcile.TypedReconciler[reconcile.Request]) reconcile.TypedReconciler[reconcile.Request] </span><span class="cov10" title="3">{
                // TODO: Handle and do not requeue some errors
                // like 4xx errors from OCI

                return reconcile.TypedFunc[reconcile.Request](
                        func(ctx context.Context, req reconcile.Request) (reconcile.Result, error) </span><span class="cov10" title="3">{
                                res, err := next.Reconcile(ctx, req)
                                if err != nil </span><span class="cov6" title="2">{
                                        var reconcileErr *app.ReconcileError
                                        if errors.As(err, &amp;reconcileErr) &amp;&amp; !reconcileErr.IsRetriable() </span><span class="cov1" title="1">{
                                                // Non-retriable error, do not requeue
                                                logger.ErrorContext(ctx, "Non-retriable reconcile error, skipping requeue",
                                                        slog.Any("request", req),
                                                        diag.ErrAttr(err),
                                                )
                                                return reconcile.Result{}, nil // Return nil error to stop reconciliation
                                        }</span>

                                        <span class="cov1" title="1">logger.ErrorContext(ctx, "Reconcile failed",
                                                slog.Any("request", req),
                                                diag.ErrAttr(err),
                                        )</span>
                                }
                                <span class="cov6" title="2">return res, err</span>
                        })
        }
}

func wireupReconciler(
        ctrl reconcile.TypedReconciler[reconcile.Request],
        middlewares ...controllerMiddleware[reconcile.Request],
) reconcile.TypedReconciler[reconcile.Request] <span class="cov6" title="2">{
        for i := len(middlewares) - 1; i &gt;= 0; i-- </span><span class="cov6" title="2">{
                ctrl = middlewares[i](ctrl)
        }</span>
        <span class="cov6" title="2">return ctrl</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package k8s

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/gemyago/oke-gateway-api/internal/app"
        "github.com/go-logr/logr"
        "go.uber.org/dig"
        discoveryv1 "k8s.io/api/discovery/v1"
        "k8s.io/client-go/rest"
        "sigs.k8s.io/controller-runtime/pkg/builder"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/manager"
        "sigs.k8s.io/controller-runtime/pkg/predicate"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
)

// StartManagerDeps contains the dependencies for the controller manager.
type StartManagerDeps struct {
        dig.In

        RootLogger       *slog.Logger
        Manager          manager.Manager
        GatewayClassCtrl *app.GatewayClassController
        GatewayCtrl      *app.GatewayController
        HTTPRouteCtrl    *app.HTTPRouteController
        WatchesModel     *app.WatchesModel
        Config           *rest.Config
}

// StartManager starts the controller manager.
func StartManager(ctx context.Context, deps StartManagerDeps) error <span class="cov0" title="0">{ // coverage-ignore -- challenging to test
        logger := deps.RootLogger.WithGroup("k8s")

        rlogLogger := logr.FromSlogHandler(logger.Handler())
        loggerCtx := logr.NewContext(ctx, rlogLogger)
        log.SetLogger(rlogLogger)

        mgr := deps.Manager

        if err := deps.WatchesModel.RegisterFieldIndexers(ctx, mgr.GetFieldIndexer()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register field indexers: %w", err)
        }</span>

        <span class="cov0" title="0">middlewares := []controllerMiddleware[reconcile.Request]{
                newTracingMiddleware(),
                newErrorHandlingMiddleware(deps.RootLogger),
        }

        if err := builder.ControllerManagedBy(mgr).
                For(&amp;gatewayv1.Gateway{}).
                WithEventFilter(predicate.Or(predicate.GenerationChangedPredicate{}, predicate.LabelChangedPredicate{})).
                Complete(wireupReconciler(deps.GatewayCtrl, middlewares...)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to setup Gateway controller: %w", err)
        }</span>

        <span class="cov0" title="0">if err := builder.ControllerManagedBy(mgr).
                For(&amp;gatewayv1.GatewayClass{}).
                WithEventFilter(predicate.Or(predicate.GenerationChangedPredicate{}, predicate.LabelChangedPredicate{})).
                Complete(wireupReconciler(deps.GatewayClassCtrl, middlewares...)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to setup GatewayClass controller: %w", err)
        }</span>

        <span class="cov0" title="0">if err := builder.ControllerManagedBy(mgr).
                For(&amp;gatewayv1.HTTPRoute{}).
                Watches(
                        &amp;discoveryv1.EndpointSlice{},
                        handler.EnqueueRequestsFromMapFunc(deps.WatchesModel.MapEndpointSliceToHTTPRoute),
                ).
                WithEventFilter(predicate.Or(predicate.GenerationChangedPredicate{}, predicate.LabelChangedPredicate{})).
                Complete(wireupReconciler(deps.HTTPRouteCtrl, middlewares...)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to setup HTTPRoute controller: %w", err)
        }</span>

        <span class="cov0" title="0">logger.InfoContext(loggerCtx, "Starting controller manager")
        return mgr.Start(loggerCtx)</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// coverage-ignore

package k8sapi

import (
        "fmt"
        "log/slog"
        "os"
        "path/filepath"

        "github.com/gemyago/oke-gateway-api/internal/types"
        "go.uber.org/dig"
        "k8s.io/apimachinery/pkg/runtime"
        clientgoscheme "k8s.io/client-go/kubernetes/scheme"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/client-go/util/homedir"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/manager"
        gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
)

type ConfigDeps struct {
        dig.In

        RootLogger *slog.Logger

        // This can be set via APP_K8SAPI_NOOP env variable
        Noop bool `name:"config.k8sapi.noop"`
}

func newConfig(deps ConfigDeps) (*rest.Config, error) <span class="cov8" title="1">{
        if deps.Noop </span><span class="cov8" title="1">{
                deps.RootLogger.Warn("Kubernetes API client is in noop mode")
                return &amp;rest.Config{}, nil
        }</span>

        <span class="cov0" title="0">kubeconfig := os.Getenv("KUBECONFIG")

        if kubeconfig == "" </span><span class="cov0" title="0">{
                if home := homedir.HomeDir(); home != "" </span><span class="cov0" title="0">{
                        kubeconfig = filepath.Join(home, ".kube", "config")
                }</span>
        }

        <span class="cov0" title="0">return clientcmd.BuildConfigFromFlags("", kubeconfig)</span>
}

func newManager(config *rest.Config) (manager.Manager, error) <span class="cov8" title="1">{
        scheme := runtime.NewScheme()

        if err := clientgoscheme.AddToScheme(scheme); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add kubernetes scheme: %w", err)
        }</span>

        <span class="cov8" title="1">if err := types.AddKnownTypes(scheme); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add gateway api scheme: %w", err)
        }</span>

        <span class="cov8" title="1">if err := gatewayv1.Install(scheme); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add gateway api scheme: %w", err)
        }</span>

        <span class="cov8" title="1">return manager.New(config, manager.Options{
                Scheme: scheme,
        })</span>
}

func newClient(manager manager.Manager) (client.Client, error) <span class="cov8" title="1">{
        return manager.GetClient(), nil
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package k8sapi

import (
        context "context"

        client "sigs.k8s.io/controller-runtime/pkg/client"

        mock "github.com/stretchr/testify/mock"
)

// MockFieldIndexer is an autogenerated mock type for the FieldIndexer type
type MockFieldIndexer struct {
        mock.Mock
}

type MockFieldIndexer_Expecter struct {
        mock *mock.Mock
}

func (_m *MockFieldIndexer) EXPECT() *MockFieldIndexer_Expecter <span class="cov10" title="2">{
        return &amp;MockFieldIndexer_Expecter{mock: &amp;_m.Mock}
}</span>

// IndexField provides a mock function with given fields: ctx, obj, field, extractValue
func (_m *MockFieldIndexer) IndexField(ctx context.Context, obj client.Object, field string, extractValue client.IndexerFunc) error <span class="cov10" title="2">{
        ret := _m.Called(ctx, obj, field, extractValue)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for IndexField")</span>
        }

        <span class="cov10" title="2">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, client.Object, string, client.IndexerFunc) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, obj, field, extractValue)
        }</span> else<span class="cov10" title="2"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov10" title="2">return r0</span>
}

// MockFieldIndexer_IndexField_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IndexField'
type MockFieldIndexer_IndexField_Call struct {
        *mock.Call
}

// IndexField is a helper method to define mock.On call
//   - ctx context.Context
//   - obj client.Object
//   - field string
//   - extractValue client.IndexerFunc
func (_e *MockFieldIndexer_Expecter) IndexField(ctx interface{}, obj interface{}, field interface{}, extractValue interface{}) *MockFieldIndexer_IndexField_Call <span class="cov10" title="2">{
        return &amp;MockFieldIndexer_IndexField_Call{Call: _e.mock.On("IndexField", ctx, obj, field, extractValue)}
}</span>

func (_c *MockFieldIndexer_IndexField_Call) Run(run func(ctx context.Context, obj client.Object, field string, extractValue client.IndexerFunc)) *MockFieldIndexer_IndexField_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(client.Object), args[2].(string), args[3].(client.IndexerFunc))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockFieldIndexer_IndexField_Call) Return(_a0 error) *MockFieldIndexer_IndexField_Call <span class="cov10" title="2">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockFieldIndexer_IndexField_Call) RunAndReturn(run func(context.Context, client.Object, string, client.IndexerFunc) error) *MockFieldIndexer_IndexField_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockFieldIndexer creates a new instance of MockFieldIndexer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockFieldIndexer(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockFieldIndexer <span class="cov10" title="2">{
        mock := &amp;MockFieldIndexer{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="2">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="2">return mock</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package k8sapi

import (
        context "context"

        client "sigs.k8s.io/controller-runtime/pkg/client"

        mock "github.com/stretchr/testify/mock"
)

// MockSubResourceWriter is an autogenerated mock type for the SubResourceWriter type
type MockSubResourceWriter struct {
        mock.Mock
}

type MockSubResourceWriter_Expecter struct {
        mock *mock.Mock
}

func (_m *MockSubResourceWriter) EXPECT() *MockSubResourceWriter_Expecter <span class="cov10" title="8">{
        return &amp;MockSubResourceWriter_Expecter{mock: &amp;_m.Mock}
}</span>

// Create provides a mock function with given fields: ctx, obj, subResource, opts
func (_m *MockSubResourceWriter) Create(ctx context.Context, obj client.Object, subResource client.Object, opts ...client.SubResourceCreateOption) error <span class="cov0" title="0">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, ctx, obj, subResource)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Create")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, client.Object, client.Object, ...client.SubResourceCreateOption) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, obj, subResource, opts...)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockSubResourceWriter_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockSubResourceWriter_Create_Call struct {
        *mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - obj client.Object
//   - subResource client.Object
//   - opts ...client.SubResourceCreateOption
func (_e *MockSubResourceWriter_Expecter) Create(ctx interface{}, obj interface{}, subResource interface{}, opts ...interface{}) *MockSubResourceWriter_Create_Call <span class="cov0" title="0">{
        return &amp;MockSubResourceWriter_Create_Call{Call: _e.mock.On("Create",
                append([]interface{}{ctx, obj, subResource}, opts...)...)}
}</span>

func (_c *MockSubResourceWriter_Create_Call) Run(run func(ctx context.Context, obj client.Object, subResource client.Object, opts ...client.SubResourceCreateOption)) *MockSubResourceWriter_Create_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]client.SubResourceCreateOption, len(args)-3)
                for i, a := range args[3:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(client.SubResourceCreateOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(client.Object), args[2].(client.Object), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSubResourceWriter_Create_Call) Return(_a0 error) *MockSubResourceWriter_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSubResourceWriter_Create_Call) RunAndReturn(run func(context.Context, client.Object, client.Object, ...client.SubResourceCreateOption) error) *MockSubResourceWriter_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Patch provides a mock function with given fields: ctx, obj, patch, opts
func (_m *MockSubResourceWriter) Patch(ctx context.Context, obj client.Object, patch client.Patch, opts ...client.SubResourcePatchOption) error <span class="cov0" title="0">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, ctx, obj, patch)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Patch")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, client.Object, client.Patch, ...client.SubResourcePatchOption) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, obj, patch, opts...)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockSubResourceWriter_Patch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Patch'
type MockSubResourceWriter_Patch_Call struct {
        *mock.Call
}

// Patch is a helper method to define mock.On call
//   - ctx context.Context
//   - obj client.Object
//   - patch client.Patch
//   - opts ...client.SubResourcePatchOption
func (_e *MockSubResourceWriter_Expecter) Patch(ctx interface{}, obj interface{}, patch interface{}, opts ...interface{}) *MockSubResourceWriter_Patch_Call <span class="cov0" title="0">{
        return &amp;MockSubResourceWriter_Patch_Call{Call: _e.mock.On("Patch",
                append([]interface{}{ctx, obj, patch}, opts...)...)}
}</span>

func (_c *MockSubResourceWriter_Patch_Call) Run(run func(ctx context.Context, obj client.Object, patch client.Patch, opts ...client.SubResourcePatchOption)) *MockSubResourceWriter_Patch_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]client.SubResourcePatchOption, len(args)-3)
                for i, a := range args[3:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(client.SubResourcePatchOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(client.Object), args[2].(client.Patch), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSubResourceWriter_Patch_Call) Return(_a0 error) *MockSubResourceWriter_Patch_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSubResourceWriter_Patch_Call) RunAndReturn(run func(context.Context, client.Object, client.Patch, ...client.SubResourcePatchOption) error) *MockSubResourceWriter_Patch_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Update provides a mock function with given fields: ctx, obj, opts
func (_m *MockSubResourceWriter) Update(ctx context.Context, obj client.Object, opts ...client.SubResourceUpdateOption) error <span class="cov10" title="8">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov10" title="8">var _ca []interface{}
        _ca = append(_ca, ctx, obj)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Update")</span>
        }

        <span class="cov10" title="8">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, client.Object, ...client.SubResourceUpdateOption) error); ok </span><span class="cov1" title="1">{
                r0 = rf(ctx, obj, opts...)
        }</span> else<span class="cov9" title="7"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov10" title="8">return r0</span>
}

// MockSubResourceWriter_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockSubResourceWriter_Update_Call struct {
        *mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - obj client.Object
//   - opts ...client.SubResourceUpdateOption
func (_e *MockSubResourceWriter_Expecter) Update(ctx interface{}, obj interface{}, opts ...interface{}) *MockSubResourceWriter_Update_Call <span class="cov10" title="8">{
        return &amp;MockSubResourceWriter_Update_Call{Call: _e.mock.On("Update",
                append([]interface{}{ctx, obj}, opts...)...)}
}</span>

func (_c *MockSubResourceWriter_Update_Call) Run(run func(ctx context.Context, obj client.Object, opts ...client.SubResourceUpdateOption)) *MockSubResourceWriter_Update_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]client.SubResourceUpdateOption, len(args)-2)
                for i, a := range args[2:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(client.SubResourceUpdateOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(client.Object), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSubResourceWriter_Update_Call) Return(_a0 error) *MockSubResourceWriter_Update_Call <span class="cov9" title="7">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSubResourceWriter_Update_Call) RunAndReturn(run func(context.Context, client.Object, ...client.SubResourceUpdateOption) error) *MockSubResourceWriter_Update_Call <span class="cov1" title="1">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockSubResourceWriter creates a new instance of MockSubResourceWriter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSubResourceWriter(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockSubResourceWriter <span class="cov10" title="8">{
        mock := &amp;MockSubResourceWriter{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="8">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="8">return mock</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package k8sapi

import (
        "github.com/gemyago/oke-gateway-api/internal/di"
        "go.uber.org/dig"
)

func Register(container *dig.Container) error <span class="cov8" title="1">{
        return di.ProvideAll(container,
                newConfig,
                newManager,
                newClient,
        )
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package ociapi

import (
        "fmt"
        "log/slog"

        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/loadbalancer"
        "go.uber.org/dig"
)

type LoadBalancerConfigDeps struct {
        dig.In

        RootLogger *slog.Logger

        ConfigProvider common.ConfigurationProvider

        // This can be set via APP_OCIAPI_NOOP env variable
        Noop bool `name:"config.ociapi.noop"`
}

func newLoadBalancerClient(
        deps LoadBalancerConfigDeps,
) (loadbalancer.LoadBalancerClient, error) <span class="cov8" title="1">{
        if deps.Noop </span><span class="cov8" title="1">{
                deps.RootLogger.Warn("OCI API client is in noop mode")
                return loadbalancer.LoadBalancerClient{}, nil
        }</span>

        <span class="cov0" title="0">client, err := loadbalancer.NewLoadBalancerClientWithConfigurationProvider(deps.ConfigProvider)
        if err != nil </span><span class="cov0" title="0">{
                return loadbalancer.LoadBalancerClient{}, fmt.Errorf("failed to create load balancer client: %w", err)
        }</span>
        <span class="cov0" title="0">return client, nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package ociapi

import (
        "github.com/oracle/oci-go-sdk/v65/common"
)

func newConfigProvider() (common.ConfigurationProvider, error) <span class="cov8" title="1">{
        // TODO: This needs more advanced setup and support in cluster config
        configProvider := common.DefaultConfigProvider()
        return configProvider, nil
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package ociapi

import (
        context "context"

        loadbalancer "github.com/oracle/oci-go-sdk/v65/loadbalancer"
        mock "github.com/stretchr/testify/mock"
)

// MockworkRequestsClient is an autogenerated mock type for the workRequestsClient type
type MockworkRequestsClient struct {
        mock.Mock
}

type MockworkRequestsClient_Expecter struct {
        mock *mock.Mock
}

func (_m *MockworkRequestsClient) EXPECT() *MockworkRequestsClient_Expecter <span class="cov10" title="10">{
        return &amp;MockworkRequestsClient_Expecter{mock: &amp;_m.Mock}
}</span>

// GetWorkRequest provides a mock function with given fields: ctx, request
func (_m *MockworkRequestsClient) GetWorkRequest(ctx context.Context, request loadbalancer.GetWorkRequestRequest) (loadbalancer.GetWorkRequestResponse, error) <span class="cov10" title="10">{
        ret := _m.Called(ctx, request)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetWorkRequest")</span>
        }

        <span class="cov10" title="10">var r0 loadbalancer.GetWorkRequestResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.GetWorkRequestRequest) (loadbalancer.GetWorkRequestResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, request)
        }</span>
        <span class="cov10" title="10">if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.GetWorkRequestRequest) loadbalancer.GetWorkRequestResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, request)
        }</span> else<span class="cov10" title="10"> {
                r0 = ret.Get(0).(loadbalancer.GetWorkRequestResponse)
        }</span>

        <span class="cov10" title="10">if rf, ok := ret.Get(1).(func(context.Context, loadbalancer.GetWorkRequestRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, request)
        }</span> else<span class="cov10" title="10"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov10" title="10">return r0, r1</span>
}

// MockworkRequestsClient_GetWorkRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkRequest'
type MockworkRequestsClient_GetWorkRequest_Call struct {
        *mock.Call
}

// GetWorkRequest is a helper method to define mock.On call
//   - ctx context.Context
//   - request loadbalancer.GetWorkRequestRequest
func (_e *MockworkRequestsClient_Expecter) GetWorkRequest(ctx interface{}, request interface{}) *MockworkRequestsClient_GetWorkRequest_Call <span class="cov10" title="10">{
        return &amp;MockworkRequestsClient_GetWorkRequest_Call{Call: _e.mock.On("GetWorkRequest", ctx, request)}
}</span>

func (_c *MockworkRequestsClient_GetWorkRequest_Call) Run(run func(ctx context.Context, request loadbalancer.GetWorkRequestRequest)) *MockworkRequestsClient_GetWorkRequest_Call <span class="cov1" title="1">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov1" title="1">{
                run(args[0].(context.Context), args[1].(loadbalancer.GetWorkRequestRequest))
        }</span>)
        <span class="cov1" title="1">return _c</span>
}

func (_c *MockworkRequestsClient_GetWorkRequest_Call) Return(_a0 loadbalancer.GetWorkRequestResponse, _a1 error) *MockworkRequestsClient_GetWorkRequest_Call <span class="cov10" title="10">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockworkRequestsClient_GetWorkRequest_Call) RunAndReturn(run func(context.Context, loadbalancer.GetWorkRequestRequest) (loadbalancer.GetWorkRequestResponse, error)) *MockworkRequestsClient_GetWorkRequest_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockworkRequestsClient creates a new instance of MockworkRequestsClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockworkRequestsClient(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockworkRequestsClient <span class="cov6" title="4">{
        mock := &amp;MockworkRequestsClient{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov6" title="4">{ mock.AssertExpectations(t) }</span>)

        <span class="cov6" title="4">return mock</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package ociapi

import (
        "github.com/gemyago/oke-gateway-api/internal/di"
        "github.com/oracle/oci-go-sdk/v65/loadbalancer"
        "go.uber.org/dig"
)

func Register(container *dig.Container) error <span class="cov8" title="1">{
        return di.ProvideAll(container,
                newConfigProvider,
                newLoadBalancerClient,
                NewWorkRequestsWatcher,
                func(c loadbalancer.LoadBalancerClient) workRequestsClient </span><span class="cov8" title="1">{ return c }</span>,
        )
}
</pre>
		
		<pre class="file" id="file49" style="display: none">//go:build !release

package ociapi

import (
        "fmt"
        "math/rand/v2"

        "github.com/go-faker/faker/v4"
        "github.com/oracle/oci-go-sdk/v65/common"
)

type MockServiceError struct {
        statusCode   int
        message      string
        code         string
        opcRequestID string
}

func (m *MockServiceError) GetHTTPStatusCode() int <span class="cov10" title="4">{
        return m.statusCode
}</span>

func (m *MockServiceError) GetMessage() string <span class="cov0" title="0">{
        return m.message
}</span>

func (m *MockServiceError) GetCode() string <span class="cov0" title="0">{
        return m.code
}</span>

func (m *MockServiceError) GetOpcRequestID() string <span class="cov0" title="0">{
        return m.opcRequestID
}</span>

func (m *MockServiceError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("mock service error statusCode: %d, message: %s", m.statusCode, m.message)
}</span>

var _ common.ServiceError = &amp;MockServiceError{}
var _ error = &amp;MockServiceError{}

type RandomServiceErrorOpts func(*MockServiceError)

func NewRandomServiceError(opts ...RandomServiceErrorOpts) *MockServiceError <span class="cov10" title="4">{
        res := &amp;MockServiceError{
                statusCode:   rand.IntN(399) + 100,
                message:      faker.Sentence(),
                code:         faker.Word(),
                opcRequestID: faker.UUIDHyphenated(),
        }

        for _, opt := range opts </span><span class="cov10" title="4">{
                opt(res)
        }</span>

        <span class="cov10" title="4">return res</span>
}

func RandomServiceErrorWithStatusCode(statusCode int) RandomServiceErrorOpts <span class="cov10" title="4">{
        return func(m *MockServiceError) </span><span class="cov10" title="4">{
                m.statusCode = statusCode
        }</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package ociapi

import (
        "context"
        "fmt"
        "log/slog"
        "time"

        "github.com/oracle/oci-go-sdk/v65/loadbalancer" // Assuming v65, adjust if needed
        "go.uber.org/dig"
)

// workRequestsClient defines the interface for OCI work requests client operations.
type workRequestsClient interface {
        // GetWorkRequest gets the details of a work request.
        GetWorkRequest(
                ctx context.Context,
                request loadbalancer.GetWorkRequestRequest,
        ) (loadbalancer.GetWorkRequestResponse, error)
}

// WorkRequestsWatcher defines the interface for watching OCI Work Requests.
type WorkRequestsWatcher struct {
        client          workRequestsClient
        logger          *slog.Logger
        pollInterval    time.Duration
        maxPollDuration time.Duration
}

// WaitFor waits for a work request to succeed.
func (w *WorkRequestsWatcher) WaitFor(ctx context.Context, workRequestID string) error <span class="cov6" title="4">{
        request := loadbalancer.GetWorkRequestRequest{
                WorkRequestId: &amp;workRequestID,
        }

        intervalTicker := time.NewTicker(w.pollInterval)
        defer intervalTicker.Stop()

        deadlineTicker := time.NewTimer(w.maxPollDuration)
        defer deadlineTicker.Stop()

        for </span><span class="cov10" title="10">{
                response, err := w.client.GetWorkRequest(ctx, request)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get work request %s: %w", workRequestID, err)
                }</span>

                <span class="cov10" title="10">if response.WorkRequest.LifecycleState == loadbalancer.WorkRequestLifecycleStateSucceeded </span><span class="cov1" title="1">{
                        return nil
                }</span>

                <span class="cov9" title="9">if response.WorkRequest.LifecycleState == loadbalancer.WorkRequestLifecycleStateFailed </span><span class="cov1" title="1">{
                        return fmt.Errorf("work request %s is in %s state", workRequestID, response.WorkRequest.LifecycleState)
                }</span>

                <span class="cov9" title="8">w.logger.DebugContext(
                        ctx, "work request is in progress",
                        slog.String("workRequestID", workRequestID),
                        slog.String("status", string(response.WorkRequest.LifecycleState)),
                )

                select </span>{
                case &lt;-intervalTicker.C:<span class="cov8" title="6"></span>
                case &lt;-deadlineTicker.C:<span class="cov1" title="1">
                        return fmt.Errorf("work request %s timed out: %w", workRequestID, context.DeadlineExceeded)</span>
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        return fmt.Errorf("work request %s timed out: %w", workRequestID, context.Canceled)</span>
                }
        }
}

type WorkRequestsWatcherDeps struct {
        dig.In `ignore-unexported:"true"`

        Client     workRequestsClient
        RootLogger *slog.Logger

        pollInterval    time.Duration
        maxPollDuration time.Duration
}

const defaultPollInterval = 2 * time.Second
const defaultMaxPollDuration = 20 * time.Minute

func NewWorkRequestsWatcher(deps WorkRequestsWatcherDeps) *WorkRequestsWatcher <span class="cov7" title="5">{
        if deps.pollInterval == 0 </span><span class="cov1" title="1">{
                deps.pollInterval = defaultPollInterval
        }</span>

        <span class="cov7" title="5">if deps.maxPollDuration == 0 </span><span class="cov6" title="4">{
                deps.maxPollDuration = defaultMaxPollDuration
        }</span>

        <span class="cov7" title="5">return &amp;WorkRequestsWatcher{
                client:          deps.Client,
                logger:          deps.RootLogger.WithGroup("oci-work-requests"),
                pollInterval:    deps.pollInterval,
                maxPollDuration: deps.maxPollDuration,
        }</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package services

import (
        "time"

        "github.com/gemyago/oke-gateway-api/internal/di"
        "go.uber.org/dig"
)

func Register(container *dig.Container) error <span class="cov10" title="2">{
        return di.ProvideAll(container,
                NewTimeProvider,
                di.ProvideValue(time.NewTicker),
                NewShutdownHooks,
        )
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">// ShutdownHooks are used to implement a graceful shutdown
// of the application. This may include closing database connections, flushing pending
// events to the queue, shutting down the http server, etc.

package services

import (
        "context"
        "fmt"
        "log/slog"
        "reflect"
        "time"

        "go.uber.org/dig"
        "golang.org/x/sync/errgroup"
)

type shutdownHook struct {
        name       string
        shutdownFn func(ctx context.Context) error
}

type ShutdownHooks struct {
        logger *slog.Logger
        hooks  []shutdownHook
        deps   ShutdownHooksRegistryDeps
}

// HasHook checks if a shutdown hook with the given name is registered.
// Typical usage is in tests and must be carefully considered for production scenarios.
func (h *ShutdownHooks) HasHook(name string, method any) bool <span class="cov6" title="4">{
        for _, hook := range h.hooks </span><span class="cov4" title="3">{
                if hook.name == name </span><span class="cov3" title="2">{
                        return reflect.ValueOf(hook.shutdownFn).Pointer() == reflect.ValueOf(method).Pointer()
                }</span>
        }
        <span class="cov3" title="2">return false</span>
}

func (h *ShutdownHooks) Register(name string, shutdown func(ctx context.Context) error) <span class="cov10" title="12">{
        h.hooks = append(h.hooks, shutdownHook{name: name, shutdownFn: shutdown})
}</span>

func (h *ShutdownHooks) RegisterNoCtx(name string, shutdown func() error) <span class="cov4" title="3">{
        h.Register(name, func(_ context.Context) error </span><span class="cov4" title="3">{
                return shutdown()
        }</span>)
}

func (h *ShutdownHooks) PerformShutdown(ctx context.Context) error <span class="cov6" title="5">{
        ctx, cancel := context.WithTimeout(ctx, h.deps.GracefulShutdownTimeout)
        defer cancel()

        errGrp := errgroup.Group{}
        for _, hook := range h.hooks </span><span class="cov9" title="10">{
                errGrp.Go(func() error </span><span class="cov9" title="10">{
                        hookName := hook.name
                        h.logger.InfoContext(ctx, fmt.Sprintf("Shutting down %s", hookName))
                        if err := hook.shutdownFn(ctx); err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to perform shutdown hook %s: %w", hookName, err)
                        }</span>
                        <span class="cov8" title="9">return nil</span>
                })
        }

        <span class="cov6" title="5">done := make(chan error)
        go func() </span><span class="cov6" title="5">{
                done &lt;- errGrp.Wait()
        }</span>()

        <span class="cov6" title="5">select </span>{
        case err := &lt;-done:<span class="cov6" title="5">
                return err</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        }
}

type ShutdownHooksRegistryDeps struct {
        dig.In

        RootLogger *slog.Logger

        // config
        GracefulShutdownTimeout time.Duration `name:"config.gracefulShutdownTimeout"`
}

func NewShutdownHooks(deps ShutdownHooksRegistryDeps) *ShutdownHooks <span class="cov8" title="7">{
        return &amp;ShutdownHooks{
                logger: deps.RootLogger.WithGroup("shutdown"),
                deps:   deps,
        }
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">//go:build !release

package services

import (
        "time"

        "github.com/gemyago/oke-gateway-api/internal/diag"
        "github.com/go-faker/faker/v4"
)

type MockNow struct {
        value time.Time
}

var _ TimeProvider = &amp;MockNow{}

func (m *MockNow) SetValue(t time.Time) <span class="cov0" title="0">{
        m.value = t
}</span>

func (m *MockNow) Now() time.Time <span class="cov0" title="0">{
        return m.value
}</span>

func NewMockNow() *MockNow <span class="cov0" title="0">{
        return &amp;MockNow{
                value: time.UnixMilli(faker.RandomUnixTime()),
        }
}</span>

func MockNowValue(p TimeProvider) time.Time <span class="cov0" title="0">{
        mp, ok := p.(*MockNow)
        if !ok </span><span class="cov0" title="0">{
                panic("provided TimeProvider is not a MockNow")</span>
        }
        <span class="cov0" title="0">return mp.value</span>
}

const defaultTestShutdownTimeout = 30 * time.Second

func NewTestShutdownHooks() *ShutdownHooks <span class="cov8" title="1">{
        return NewShutdownHooks(ShutdownHooksRegistryDeps{
                RootLogger:              diag.RootTestLogger(),
                GracefulShutdownTimeout: defaultTestShutdownTimeout,
        })
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package services

import "time"

type TimeProvider interface {
        Now() time.Time
}

type timeProviderFn func() time.Time

func (fn timeProviderFn) Now() time.Time <span class="cov8" title="1">{
        return fn()
}</span>

func NewTimeProvider() TimeProvider <span class="cov8" title="1">{
        return timeProviderFn(time.Now)
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package types

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

const (
        // GroupName is the group name used in this package.
        GroupName = "oke-gateway-api.gemyago.github.io"
        // Version is the API version.
        Version = "v1"
)

// Adds the list of known types to Scheme.
func AddKnownTypes(scheme *runtime.Scheme) error <span class="cov8" title="1">{
        groupVersion := schema.GroupVersion{Group: GroupName, Version: Version}
        scheme.AddKnownTypes(groupVersion,
                &amp;GatewayConfig{},
                &amp;GatewayConfigList{},
        )
        metav1.AddToGroupVersion(scheme, groupVersion)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">//go:build !ignore_autogenerated

/**/

// Code generated by controller-gen. DO NOT EDIT.

package types

import (
        "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GatewayConfig) DeepCopyInto(out *GatewayConfig) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        out.Spec = in.Spec
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GatewayConfig.
func (in *GatewayConfig) DeepCopy() *GatewayConfig <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(GatewayConfig)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *GatewayConfig) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GatewayConfigList) DeepCopyInto(out *GatewayConfigList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]GatewayConfig, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GatewayConfigList.
func (in *GatewayConfigList) DeepCopy() *GatewayConfigList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(GatewayConfigList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *GatewayConfigList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GatewayConfigSpec) DeepCopyInto(out *GatewayConfigSpec) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GatewayConfigSpec.
func (in *GatewayConfigSpec) DeepCopy() *GatewayConfigSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(GatewayConfigSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GatewayConfigStatus) DeepCopyInto(out *GatewayConfigStatus) <span class="cov0" title="0">{
        *out = *in
        if in.Conditions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make([]v1.Condition, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GatewayConfigStatus.
func (in *GatewayConfigStatus) DeepCopy() *GatewayConfigStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(GatewayConfigStatus)
        in.DeepCopyInto(out)
        return out</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
