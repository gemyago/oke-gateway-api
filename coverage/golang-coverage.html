
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>controller: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/gemyago/oke-gateway-api/cmd/controller/main.go (57.1%)</option>
				
				<option value="file1">github.com/gemyago/oke-gateway-api/cmd/controller/root.go (100.0%)</option>
				
				<option value="file2">github.com/gemyago/oke-gateway-api/cmd/controller/start.go (91.4%)</option>
				
				<option value="file3">github.com/gemyago/oke-gateway-api/cmd/server/main.go (57.1%)</option>
				
				<option value="file4">github.com/gemyago/oke-gateway-api/cmd/server/root.go (100.0%)</option>
				
				<option value="file5">github.com/gemyago/oke-gateway-api/cmd/server/start.go (91.7%)</option>
				
				<option value="file6">github.com/gemyago/oke-gateway-api/internal/api/http/handler.go (100.0%)</option>
				
				<option value="file7">github.com/gemyago/oke-gateway-api/internal/api/http/middleware/chain.go (100.0%)</option>
				
				<option value="file8">github.com/gemyago/oke-gateway-api/internal/api/http/middleware/recover.go (100.0%)</option>
				
				<option value="file9">github.com/gemyago/oke-gateway-api/internal/api/http/middleware/tracing.go (100.0%)</option>
				
				<option value="file10">github.com/gemyago/oke-gateway-api/internal/api/http/register.go (100.0%)</option>
				
				<option value="file11">github.com/gemyago/oke-gateway-api/internal/api/http/server/register.go (100.0%)</option>
				
				<option value="file12">github.com/gemyago/oke-gateway-api/internal/api/http/server/server.go (92.3%)</option>
				
				<option value="file13">github.com/gemyago/oke-gateway-api/internal/app/errors.go (100.0%)</option>
				
				<option value="file14">github.com/gemyago/oke-gateway-api/internal/app/gateway_controller.go (96.3%)</option>
				
				<option value="file15">github.com/gemyago/oke-gateway-api/internal/app/gateway_model.go (97.4%)</option>
				
				<option value="file16">github.com/gemyago/oke-gateway-api/internal/app/gatewayclass_controller.go (100.0%)</option>
				
				<option value="file17">github.com/gemyago/oke-gateway-api/internal/app/httpbackend_model.go (93.1%)</option>
				
				<option value="file18">github.com/gemyago/oke-gateway-api/internal/app/httproute_controller.go (100.0%)</option>
				
				<option value="file19">github.com/gemyago/oke-gateway-api/internal/app/httproute_model.go (100.0%)</option>
				
				<option value="file20">github.com/gemyago/oke-gateway-api/internal/app/mock_gateway_model.go (70.5%)</option>
				
				<option value="file21">github.com/gemyago/oke-gateway-api/internal/app/mock_http_backend_model.go (61.7%)</option>
				
				<option value="file22">github.com/gemyago/oke-gateway-api/internal/app/mock_http_route_model.go (61.5%)</option>
				
				<option value="file23">github.com/gemyago/oke-gateway-api/internal/app/mock_k_8_s_client.go (64.4%)</option>
				
				<option value="file24">github.com/gemyago/oke-gateway-api/internal/app/mock_oci_load_balancer_client.go (40.5%)</option>
				
				<option value="file25">github.com/gemyago/oke-gateway-api/internal/app/mock_oci_load_balancer_model.go (59.6%)</option>
				
				<option value="file26">github.com/gemyago/oke-gateway-api/internal/app/mock_oci_load_balancer_routing_rules_mapper.go (38.0%)</option>
				
				<option value="file27">github.com/gemyago/oke-gateway-api/internal/app/mock_resources_model.go (63.2%)</option>
				
				<option value="file28">github.com/gemyago/oke-gateway-api/internal/app/mock_work_requests_watcher.go (68.2%)</option>
				
				<option value="file29">github.com/gemyago/oke-gateway-api/internal/app/oci_load_balancer_model.go (94.2%)</option>
				
				<option value="file30">github.com/gemyago/oke-gateway-api/internal/app/oci_load_balancer_routing_rules.go (92.3%)</option>
				
				<option value="file31">github.com/gemyago/oke-gateway-api/internal/app/register.go (100.0%)</option>
				
				<option value="file32">github.com/gemyago/oke-gateway-api/internal/app/resources_model.go (96.7%)</option>
				
				<option value="file33">github.com/gemyago/oke-gateway-api/internal/app/watches_model.go (97.7%)</option>
				
				<option value="file34">github.com/gemyago/oke-gateway-api/internal/config/load.go (95.8%)</option>
				
				<option value="file35">github.com/gemyago/oke-gateway-api/internal/config/provide.go (100.0%)</option>
				
				<option value="file36">github.com/gemyago/oke-gateway-api/internal/di/dig.go (100.0%)</option>
				
				<option value="file37">github.com/gemyago/oke-gateway-api/internal/diag/attributes.go (100.0%)</option>
				
				<option value="file38">github.com/gemyago/oke-gateway-api/internal/diag/mock_slog_handler.go (34.7%)</option>
				
				<option value="file39">github.com/gemyago/oke-gateway-api/internal/diag/slog.go (96.6%)</option>
				
				<option value="file40">github.com/gemyago/oke-gateway-api/internal/diag/testing.go (75.0%)</option>
				
				<option value="file41">github.com/gemyago/oke-gateway-api/internal/k8s/middleware.go (100.0%)</option>
				
				<option value="file42">github.com/gemyago/oke-gateway-api/internal/k8s/start_manager.go (0.0%)</option>
				
				<option value="file43">github.com/gemyago/oke-gateway-api/internal/services/k8sapi/client.go (40.9%)</option>
				
				<option value="file44">github.com/gemyago/oke-gateway-api/internal/services/k8sapi/mock_field_indexer.go (68.2%)</option>
				
				<option value="file45">github.com/gemyago/oke-gateway-api/internal/services/k8sapi/mock_sub_resource_writer.go (23.8%)</option>
				
				<option value="file46">github.com/gemyago/oke-gateway-api/internal/services/k8sapi/register.go (100.0%)</option>
				
				<option value="file47">github.com/gemyago/oke-gateway-api/internal/services/ociapi/clients.go (42.9%)</option>
				
				<option value="file48">github.com/gemyago/oke-gateway-api/internal/services/ociapi/config.go (100.0%)</option>
				
				<option value="file49">github.com/gemyago/oke-gateway-api/internal/services/ociapi/mock_work_requests_client.go (78.6%)</option>
				
				<option value="file50">github.com/gemyago/oke-gateway-api/internal/services/ociapi/oci_resources.go (100.0%)</option>
				
				<option value="file51">github.com/gemyago/oke-gateway-api/internal/services/ociapi/register.go (100.0%)</option>
				
				<option value="file52">github.com/gemyago/oke-gateway-api/internal/services/ociapi/testing.go (63.6%)</option>
				
				<option value="file53">github.com/gemyago/oke-gateway-api/internal/services/ociapi/work_requests_watcher.go (95.5%)</option>
				
				<option value="file54">github.com/gemyago/oke-gateway-api/internal/services/register.go (100.0%)</option>
				
				<option value="file55">github.com/gemyago/oke-gateway-api/internal/services/shutdown.go (95.8%)</option>
				
				<option value="file56">github.com/gemyago/oke-gateway-api/internal/services/testing.go (46.2%)</option>
				
				<option value="file57">github.com/gemyago/oke-gateway-api/internal/services/time.go (100.0%)</option>
				
				<option value="file58">github.com/gemyago/oke-gateway-api/internal/types/register.go (100.0%)</option>
				
				<option value="file59">github.com/gemyago/oke-gateway-api/internal/types/zz_generated.deepcopy.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "os"

        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

func setupCommands() *cobra.Command <span class="cov10" title="3">{
        container := dig.New()
        rootCmd := newRootCmd(container)
        rootCmd.AddCommand(
                newStartServerCmd(container),
        )
        return rootCmd
}</span>

func main() <span class="cov0" title="0">{ // coverage-ignore
        rootCmd := setupCommands()
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                // cobra will print error to stdout
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "errors"
        "fmt"
        "log/slog"

        "github.com/gemyago/oke-gateway-api/internal/app"
        "github.com/gemyago/oke-gateway-api/internal/config"
        "github.com/gemyago/oke-gateway-api/internal/di"
        "github.com/gemyago/oke-gateway-api/internal/diag"
        "github.com/gemyago/oke-gateway-api/internal/services"
        "github.com/samber/lo"
        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

func newRootCmd(container *dig.Container) *cobra.Command <span class="cov10" title="3">{
        logsOutputFile := ""

        cmd := &amp;cobra.Command{
                Use:   "server",
                Short: "Command to start the server",
        }
        cmd.SilenceUsage = true
        cmd.PersistentFlags().StringP("log-level", "l", "", "Produce logs with given level. Default is env specific.")
        cmd.PersistentFlags().StringVar(
                &amp;logsOutputFile,
                "logs-file",
                "",
                "Produce logs to file instead of stdout. Used for tests only.",
        )
        cmd.PersistentFlags().Bool(
                "json-logs",
                false,
                "Indicates if logs should be in JSON format or text (default)",
        )
        cmd.PersistentFlags().StringP(
                "env",
                "e",
                "",
                "Env that the process is running in.",
        )
        cfg := config.New()
        lo.Must0(cfg.BindPFlags(cmd.PersistentFlags()))
        cmd.PersistentPreRunE = func(_ *cobra.Command, _ []string) error </span><span class="cov10" title="3">{
                err := config.Load(cfg, config.NewLoadOpts().WithEnv(cfg.GetString("env")))
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov6" title="2">var logLevel slog.Level
                if err = logLevel.UnmarshalText([]byte(cfg.GetString("defaultLogLevel"))); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov1" title="1">rootLogger := diag.SetupRootLogger(
                        diag.NewRootLoggerOpts().
                                WithJSONLogs(cfg.GetBool("jsonLogs")).
                                WithLogLevel(logLevel).
                                WithOptionalOutputFile(logsOutputFile),
                )

                err = errors.Join(
                        config.Provide(container, cfg),

                        // app layer
                        app.Register(container),

                        // services
                        services.Register(container),

                        di.ProvideAll(container,
                                di.ProvideValue(rootLogger),
                        ),
                )

                return lo.
                        If(err != nil, fmt.Errorf("failed to inject dependencies: %w", err)).
                        Else(nil)</span>
        }
        <span class="cov10" title="3">return cmd</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "errors"
        "log/slog"
        "os/signal"
        "time"

        "github.com/gemyago/oke-gateway-api/internal/diag"
        "github.com/gemyago/oke-gateway-api/internal/k8s"
        "github.com/gemyago/oke-gateway-api/internal/services"
        "github.com/gemyago/oke-gateway-api/internal/services/k8sapi"
        "github.com/gemyago/oke-gateway-api/internal/services/ociapi"
        "github.com/spf13/cobra"
        "go.uber.org/dig"
        "golang.org/x/sys/unix"
)

type startServerParams struct {
        dig.In `ignore-unexported:"true"`

        RootLogger *slog.Logger

        *services.ShutdownHooks

        ManagerDeps k8s.StartManagerDeps

        noop bool
}

func startServer(params startServerParams) error <span class="cov1" title="1">{
        rootLogger := params.RootLogger
        rootCtx := context.Background()

        shutdown := func() error </span><span class="cov1" title="1">{
                rootLogger.InfoContext(rootCtx, "Trying to shut down gracefully")
                ts := time.Now()

                err := params.ShutdownHooks.PerformShutdown(rootCtx)
                if err != nil </span><span class="cov0" title="0">{
                        rootLogger.ErrorContext(rootCtx, "Failed to shut down gracefully", diag.ErrAttr(err))
                }</span>

                <span class="cov1" title="1">rootLogger.InfoContext(rootCtx, "Service stopped",
                        slog.Duration("duration", time.Since(ts)),
                )
                return err</span>
        }

        <span class="cov1" title="1">signalCtx, cancel := signal.NotifyContext(rootCtx, unix.SIGINT, unix.SIGTERM)
        defer cancel()

        const startedComponents = 1
        startupErrors := make(chan error, startedComponents)
        go func() </span><span class="cov1" title="1">{
                if params.noop </span><span class="cov1" title="1">{
                        rootLogger.InfoContext(signalCtx, "NOOP: Starting k8s controller manager")
                        startupErrors &lt;- nil
                        return
                }</span>
                <span class="cov0" title="0">startupErrors &lt;- k8s.StartManager(signalCtx, params.ManagerDeps)</span>
        }()

        <span class="cov1" title="1">var startupErr error
        select </span>{
        case startupErr = &lt;-startupErrors:<span class="cov1" title="1">
                if startupErr != nil </span><span class="cov0" title="0">{
                        rootLogger.ErrorContext(rootCtx, "Server startup failed", "err", startupErr)
                }</span>
        case &lt;-signalCtx.Done():<span class="cov0" title="0"></span> // coverage-ignore
                // We will attempt to shut down in both cases
                // so doing it once on a next line
        }
        <span class="cov1" title="1">return errors.Join(startupErr, shutdown())</span>
}

func newStartServerCmd(container *dig.Container) *cobra.Command <span class="cov10" title="3">{
        cmd := &amp;cobra.Command{
                Use:   "start",
                Short: "Command to start server",
        }
        noop := false
        cmd.Flags().BoolVar(
                &amp;noop,
                "noop",
                false,
                "Do not start. Just setup deps and exit. Useful for testing if setup is all working.",
        )
        cmd.PreRunE = func(_ *cobra.Command, _ []string) error </span><span class="cov1" title="1">{
                return errors.Join(
                        k8sapi.Register(container),
                        ociapi.Register(container),
                )
        }</span>
        <span class="cov10" title="3">cmd.RunE = func(_ *cobra.Command, _ []string) error </span><span class="cov1" title="1">{
                return container.Invoke(func(params startServerParams) error </span><span class="cov1" title="1">{
                        params.noop = noop
                        return startServer(params)
                }</span>)
        }
        <span class="cov10" title="3">return cmd</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "os"

        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

func setupCommands() *cobra.Command <span class="cov10" title="3">{
        container := dig.New()
        rootCmd := newRootCmd(container)
        rootCmd.AddCommand(
                newStartServerCmd(container),
        )
        return rootCmd
}</span>

func main() <span class="cov0" title="0">{ // coverage-ignore
        rootCmd := setupCommands()
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                // cobra will print error to stdout
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "errors"
        "fmt"
        "log/slog"

        "github.com/gemyago/oke-gateway-api/internal/config"
        "github.com/gemyago/oke-gateway-api/internal/di"
        "github.com/gemyago/oke-gateway-api/internal/diag"
        "github.com/gemyago/oke-gateway-api/internal/services"
        "github.com/samber/lo"
        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

func newRootCmd(container *dig.Container) *cobra.Command <span class="cov10" title="3">{
        logsOutputFile := ""

        cmd := &amp;cobra.Command{
                Use:   "server",
                Short: "Command to start the simple server",
        }
        cmd.SilenceUsage = true
        cmd.PersistentFlags().StringP("log-level", "l", "", "Produce logs with given level. Default is env specific.")
        cmd.PersistentFlags().StringVar(
                &amp;logsOutputFile,
                "logs-file",
                "",
                "Produce logs to file instead of stdout. Used for tests only.",
        )
        cmd.PersistentFlags().Bool(
                "json-logs",
                false,
                "Indicates if logs should be in JSON format or text (default)",
        )
        cmd.PersistentFlags().StringP(
                "env",
                "e",
                "",
                "Env that the process is running in.",
        )
        cfg := config.New()
        lo.Must0(cfg.BindPFlags(cmd.PersistentFlags()))
        cmd.PersistentPreRunE = func(_ *cobra.Command, _ []string) error </span><span class="cov10" title="3">{
                err := config.Load(cfg, config.NewLoadOpts().WithEnv(cfg.GetString("env")))
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov6" title="2">var logLevel slog.Level
                if err = logLevel.UnmarshalText([]byte(cfg.GetString("defaultLogLevel"))); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov1" title="1">rootLogger := diag.SetupRootLogger(
                        diag.NewRootLoggerOpts().
                                WithJSONLogs(cfg.GetBool("jsonLogs")).
                                WithLogLevel(logLevel).
                                WithOptionalOutputFile(logsOutputFile),
                )

                err = errors.Join(
                        config.Provide(container, cfg),

                        // services
                        services.Register(container),

                        di.ProvideAll(container,
                                di.ProvideValue(rootLogger),
                        ),
                )

                return lo.
                        If(err != nil, fmt.Errorf("failed to inject dependencies: %w", err)).
                        Else(nil)</span>
        }
        <span class="cov10" title="3">return cmd</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "context"
        "errors"
        "log/slog"
        "os/signal"
        "time"

        "github.com/gemyago/oke-gateway-api/internal/api/http"
        "github.com/gemyago/oke-gateway-api/internal/api/http/server"
        "github.com/gemyago/oke-gateway-api/internal/diag"
        "github.com/gemyago/oke-gateway-api/internal/services"
        "github.com/spf13/cobra"
        "go.uber.org/dig"
        "golang.org/x/sys/unix"
)

type startServerParams struct {
        dig.In `ignore-unexported:"true"`

        RootLogger *slog.Logger

        HTTPServer *server.HTTPServer

        *services.ShutdownHooks

        noop bool
}

func startServer(params startServerParams) error <span class="cov1" title="1">{
        rootLogger := params.RootLogger
        httpServer := params.HTTPServer
        rootCtx := context.Background()

        shutdown := func() error </span><span class="cov1" title="1">{
                rootLogger.InfoContext(rootCtx, "Trying to shut down gracefully")
                ts := time.Now()

                err := params.ShutdownHooks.PerformShutdown(rootCtx)
                if err != nil </span><span class="cov0" title="0">{
                        rootLogger.ErrorContext(rootCtx, "Failed to shut down gracefully", diag.ErrAttr(err))
                }</span>

                <span class="cov1" title="1">rootLogger.InfoContext(rootCtx, "Service stopped",
                        slog.Duration("duration", time.Since(ts)),
                )
                return err</span>
        }

        <span class="cov1" title="1">signalCtx, cancel := signal.NotifyContext(rootCtx, unix.SIGINT, unix.SIGTERM)
        defer cancel()

        const startedComponents = 2
        startupErrors := make(chan error, startedComponents)
        go func() </span><span class="cov1" title="1">{
                if params.noop </span><span class="cov1" title="1">{
                        rootLogger.InfoContext(signalCtx, "NOOP: Starting http server")
                        startupErrors &lt;- nil
                        return
                }</span>
                <span class="cov0" title="0">startupErrors &lt;- httpServer.Start(signalCtx)</span>
        }()

        <span class="cov1" title="1">var startupErr error
        select </span>{
        case startupErr = &lt;-startupErrors:<span class="cov1" title="1">
                if startupErr != nil </span><span class="cov0" title="0">{
                        rootLogger.ErrorContext(rootCtx, "Server startup failed", "err", startupErr)
                }</span>
        case &lt;-signalCtx.Done():<span class="cov0" title="0"></span> // coverage-ignore
                // We will attempt to shut down in both cases
                // so doing it once on a next line
        }
        <span class="cov1" title="1">return errors.Join(startupErr, shutdown())</span>
}

func newStartServerCmd(container *dig.Container) *cobra.Command <span class="cov10" title="3">{
        cmd := &amp;cobra.Command{
                Use:   "start",
                Short: "Start the server",
        }
        noop := false
        cmd.Flags().BoolVar(
                &amp;noop,
                "noop",
                false,
                "Pretend to start.",
        )
        cmd.PreRunE = func(_ *cobra.Command, _ []string) error </span><span class="cov1" title="1">{
                return errors.Join(
                        server.Register(container),
                        http.Register(container),
                )
        }</span>
        <span class="cov10" title="3">cmd.RunE = func(_ *cobra.Command, _ []string) error </span><span class="cov1" title="1">{
                return container.Invoke(func(params startServerParams) error </span><span class="cov1" title="1">{
                        params.noop = noop
                        return startServer(params)
                }</span>)
        }
        <span class="cov10" title="3">return cmd</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package http

import (
        "encoding/json"
        "io"
        "log/slog"
        "net/http"

        "github.com/gemyago/oke-gateway-api/internal/diag"
        "go.uber.org/dig"
)

type EchoResponse struct {
        RequestHeaders http.Header `json:"requestHeaders"`
        RequestBody    string      `json:"requestBody"`
        RequestMethod  string      `json:"requestMethod"`
        RequestURL     string      `json:"requestURL"`
        Host           string      `json:"host"`
}

type RootHandlerDeps struct {
        dig.In

        RootLogger *slog.Logger

        Mode string `name:"config.httpServer.mode"`
}

const (
        HandlerModeEcho    = "echo"
        HandlerModeStealth = "stealth"
)

func NewRootHandler(deps RootHandlerDeps) http.Handler <span class="cov10" title="5">{
        logger := deps.RootLogger.WithGroup("http-handler")

        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="4">{
                if deps.Mode == HandlerModeStealth </span><span class="cov1" title="1">{
                        w.WriteHeader(http.StatusNotFound)
                        return
                }</span>
                <span class="cov7" title="3">body, err := io.ReadAll(r.Body)
                if err != nil </span><span class="cov1" title="1">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov4" title="2">w.WriteHeader(http.StatusOK)
                err = json.NewEncoder(w).Encode(EchoResponse{
                        RequestHeaders: r.Header,
                        RequestBody:    string(body),
                        RequestMethod:  r.Method,
                        RequestURL:     r.URL.String(),
                        Host:           r.Host,
                })
                if err != nil </span><span class="cov1" title="1">{
                        // We can just log at this point, as we've already written a response
                        logger.Error("failed to encode response", diag.ErrAttr(err))
                        return
                }</span>
        })
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package middleware

import "net/http"

type Middleware func(http.Handler) http.Handler

func Chain(middlewares ...Middleware) func(http.Handler) http.Handler <span class="cov6" title="5">{
        return func(h http.Handler) http.Handler </span><span class="cov6" title="5">{
                for i := len(middlewares) - 1; i &gt;= 0; i-- </span><span class="cov10" title="15">{
                        h = middlewares[i](h)
                }</span>
                <span class="cov6" title="5">return h</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package middleware

import (
        "errors"
        "log/slog"
        "net/http"
        "runtime/debug"
)

// NewRecovererMiddleware creates a middleware that will handle panics
// log them and respond with 500 to client. This should be the last in a chain.
func NewRecovererMiddleware(rootLogger *slog.Logger) Middleware <span class="cov10" title="7">{
        return func(next http.Handler) http.Handler </span><span class="cov10" title="7">{
                fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov7" title="4">{
                        defer func() </span><span class="cov7" title="4">{
                                if rvr := recover(); rvr != nil </span><span class="cov4" title="2">{
                                        if err, ok := rvr.(error); ok &amp;&amp; errors.Is(err, http.ErrAbortHandler) </span><span class="cov1" title="1">{
                                                rootLogger.InfoContext(r.Context(), "Request aborted")
                                                return
                                        }</span>
                                        <span class="cov1" title="1">rootLogger.ErrorContext(
                                                r.Context(),
                                                "Unhandled panic",
                                                slog.Any("panic", rvr),
                                                slog.String("stack", string(debug.Stack())),
                                        )
                                        // TODO: Do not write header if already written
                                        w.WriteHeader(http.StatusInternalServerError)</span>
                                }
                        }()

                        <span class="cov7" title="4">next.ServeHTTP(w, r)</span>
                }

                <span class="cov10" title="7">return http.HandlerFunc(fn)</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package middleware

import (
        "log/slog"
        "net/http"

        "github.com/gemyago/oke-gateway-api/internal/diag"
        "github.com/gofrs/uuid/v5"
)

type TracingMiddlewareCfg struct {
        generateUUID func() string
}

func NewTracingMiddlewareCfg() *TracingMiddlewareCfg <span class="cov10" title="6">{
        return &amp;TracingMiddlewareCfg{
                generateUUID: func() string </span><span class="cov4" title="2">{
                        return uuid.Must(uuid.NewV4()).String()
                }</span>,
        }
}

func NewTracingMiddleware(cfg *TracingMiddlewareCfg) Middleware <span class="cov10" title="6">{
        generateUUID := cfg.generateUUID
        return func(next http.Handler) http.Handler </span><span class="cov10" title="6">{
                return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) </span><span class="cov6" title="3">{
                        correlationID := req.Header.Get("x-correlation-id")
                        if correlationID == "" </span><span class="cov4" title="2">{
                                correlationID = generateUUID()
                        }</span>
                        <span class="cov6" title="3">logAttributes := diag.GetLogAttributesFromContext(req.Context())
                        logAttributes.CorrelationID = slog.StringValue(correlationID)
                        nextCtx := diag.SetLogAttributesToContext(req.Context(), logAttributes)
                        next.ServeHTTP(w, req.WithContext(nextCtx))</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package http

import (
        "errors"

        "github.com/gemyago/oke-gateway-api/internal/di"
        "go.uber.org/dig"
)

func Register(container *dig.Container) error <span class="cov8" title="1">{
        return errors.Join(
                di.ProvideAll(container,
                        NewRootHandler,
                ),
        )
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package server

import (
        "github.com/gemyago/oke-gateway-api/internal/di"
        "go.uber.org/dig"
)

func Register(container *dig.Container) error <span class="cov8" title="1">{
        return di.ProvideAll(
                container,
                NewHTTPServer,
        )
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package server

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "net"
        "net/http"
        "time"

        "github.com/gemyago/oke-gateway-api/internal/api/http/middleware"
        "github.com/gemyago/oke-gateway-api/internal/services"
        sloghttp "github.com/samber/slog-http"
        "go.uber.org/dig"
)

type HTTPServerDeps struct {
        dig.In `ignore-unexported:"true"`

        RootLogger *slog.Logger

        // config
        Host              string        `name:"config.httpServer.host"`
        Port              int           `name:"config.httpServer.port"`
        IdleTimeout       time.Duration `name:"config.httpServer.idleTimeout"`
        ReadHeaderTimeout time.Duration `name:"config.httpServer.readHeaderTimeout"`
        ReadTimeout       time.Duration `name:"config.httpServer.readTimeout"`
        WriteTimeout      time.Duration `name:"config.httpServer.writeTimeout"`
        AccessLogsLevel   string        `name:"config.httpServer.accessLogsLevel"`
        Mode              string        `name:"config.httpServer.mode"`

        // handler
        Handler http.Handler

        // services
        *services.ShutdownHooks

        // listeningSignal is an optional channel that Start will close when the server is listening.
        // Primarily for testing.
        listeningSignal chan&lt;- struct{}
}

type HTTPServer struct {
        httpSrv *http.Server
        deps    HTTPServerDeps
        logger  *slog.Logger
}

func (srv *HTTPServer) Start(ctx context.Context) error <span class="cov1" title="1">{
        listener, err := net.Listen("tcp", srv.httpSrv.Addr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to listen on %s: %w", srv.httpSrv.Addr, err)
        }</span>

        <span class="cov1" title="1">actualAddr := listener.Addr().String()
        srv.logger.InfoContext(ctx, "Started http listener",
                slog.String("addr", actualAddr),
                slog.String("idleTimeout", srv.deps.IdleTimeout.String()),
                slog.String("readHeaderTimeout", srv.deps.ReadHeaderTimeout.String()),
                slog.String("readTimeout", srv.deps.ReadTimeout.String()),
                slog.String("writeTimeout", srv.deps.WriteTimeout.String()),
                slog.String("accessLogsLevel", srv.deps.AccessLogsLevel),
                slog.String("mode", srv.deps.Mode),
        )

        if srv.deps.listeningSignal != nil </span><span class="cov1" title="1">{
                close(srv.deps.listeningSignal)
        }</span>

        // http.Serve always returns a non-nil error.
        // It returns http.ErrServerClosed when Shutdown or Close is called.
        <span class="cov1" title="1">err = srv.httpSrv.Serve(listener)
        if err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                return fmt.Errorf("http server Serve error: %w", err)
        }</span>

        <span class="cov1" title="1">srv.logger.InfoContext(ctx, "HTTP server shut down gracefully")
        return nil</span>
}

func buildMiddlewareChain(deps HTTPServerDeps) http.Handler <span class="cov10" title="5">{
        defaultLogLevel := slog.LevelInfo
        clientErrorLevel := slog.LevelWarn
        serverErrorLevel := slog.LevelError

        if deps.AccessLogsLevel != "" </span><span class="cov4" title="2">{
                if err := defaultLogLevel.UnmarshalText([]byte(deps.AccessLogsLevel)); err != nil </span><span class="cov1" title="1">{
                        panic(fmt.Errorf("failed to unmarshal access logs level: %w", err))</span>
                }
                <span class="cov1" title="1">clientErrorLevel = defaultLogLevel
                serverErrorLevel = defaultLogLevel</span>
        }

        // Router wire-up
        <span class="cov8" title="4">chain := middleware.Chain(
                middleware.NewTracingMiddleware(middleware.NewTracingMiddlewareCfg()),
                sloghttp.NewWithConfig(deps.RootLogger, sloghttp.Config{
                        DefaultLevel:     defaultLogLevel,
                        ClientErrorLevel: clientErrorLevel,
                        ServerErrorLevel: serverErrorLevel,

                        WithUserAgent:      true,
                        WithRequestID:      false, // We handle it ourselves (tracing middleware)
                        WithRequestHeader:  true,
                        WithResponseHeader: true,
                        WithSpanID:         true,
                        WithTraceID:        true,
                }),
                middleware.NewRecovererMiddleware(deps.RootLogger),
        )
        return chain(deps.Handler)</span>
}

// NewHTTPServer constructor factory for general use *http.Server.
func NewHTTPServer(deps HTTPServerDeps) *HTTPServer <span class="cov4" title="2">{
        address := fmt.Sprintf("%s:%d", deps.Host, deps.Port)
        srv := &amp;http.Server{
                Addr:              address,
                IdleTimeout:       deps.IdleTimeout,
                ReadHeaderTimeout: deps.ReadHeaderTimeout,
                ReadTimeout:       deps.ReadTimeout,
                WriteTimeout:      deps.WriteTimeout,
                Handler:           buildMiddlewareChain(deps),
                ErrorLog:          slog.NewLogLogger(deps.RootLogger.Handler(), slog.LevelError),
        }

        deps.ShutdownHooks.Register("http-server", srv.Shutdown)

        return &amp;HTTPServer{
                deps:    deps,
                httpSrv: srv,
                logger:  deps.RootLogger.WithGroup("http-server"),
        }
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package app

import "fmt"

type resourceStatusError struct {
        conditionType string
        reason        string
        message       string
        cause         error
}

func (e resourceStatusError) Error() string <span class="cov10" title="5">{
        if e.cause != nil </span><span class="cov1" title="1">{
                return fmt.Sprintf(
                        "resourceStatusError: type=%s, reason=%s, message=%s, cause=%s",
                        e.conditionType, e.reason, e.message, e.cause)
        }</span>
        <span class="cov8" title="4">return fmt.Sprintf("resourceStatusError: type=%s, reason=%s, message=%s", e.conditionType, e.reason, e.message)</span>
}

type ReconcileError struct {
        message   string
        retriable bool
        cause     error
}

func (e ReconcileError) Error() string <span class="cov7" title="3">{
        if e.cause != nil </span><span class="cov1" title="1">{
                return fmt.Sprintf("reconcileError: retriable=%t, message=%s, cause=%s", e.retriable, e.message, e.cause)
        }</span>
        <span class="cov4" title="2">return fmt.Sprintf("reconcileError: retriable=%t, message=%s", e.retriable, e.message)</span>
}

func (e ReconcileError) IsRetriable() bool <span class="cov10" title="5">{
        return e.retriable
}</span>

func NewReconcileError(message string, retriable bool) *ReconcileError <span class="cov8" title="4">{
        return &amp;ReconcileError{
                retriable: retriable,
                message:   message,
        }
}</span>

func NewReconcileErrorWithCause(message string, retriable bool, cause error) *ReconcileError <span class="cov7" title="3">{
        return &amp;ReconcileError{
                retriable: retriable,
                message:   message,
                cause:     cause,
        }
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package app

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "strconv"

        "go.uber.org/dig"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
)

// GatewayController is a simple controller that watches Gateway resources.
type GatewayController struct {
        client         k8sClient
        logger         *slog.Logger
        resourcesModel resourcesModel
        gatewayModel   gatewayModel
}

// GatewayControllerDeps contains the dependencies for the GatewayController.
type GatewayControllerDeps struct {
        dig.In

        RootLogger     *slog.Logger
        K8sClient      k8sClient
        ResourcesModel resourcesModel
        GatewayModel   gatewayModel
}

// NewGatewayController creates a new GatewayController.
func NewGatewayController(deps GatewayControllerDeps) *GatewayController <span class="cov10" title="10">{
        return &amp;GatewayController{
                client:         deps.K8sClient,
                logger:         deps.RootLogger.WithGroup("gateway-controller"),
                resourcesModel: deps.ResourcesModel, // Initialize resourcesModel
                gatewayModel:   deps.GatewayModel,
        }
}</span>

// processResourceError handles errors from resource programming operations.
// It checks if the error is a resourceStatusError and updates the condition accordingly.
// Returns a reconcile result and error to be returned from the Reconcile method.
func (r *GatewayController) processResourceError(
        ctx context.Context,
        err error,
        gateway *gatewayv1.Gateway,
) (reconcile.Result, error) <span class="cov7" title="5">{
        var reasonErr *resourceStatusError
        if errors.As(err, &amp;reasonErr) </span><span class="cov5" title="3">{
                if err = r.resourcesModel.setCondition(ctx, setConditionParams{
                        resource:      gateway,
                        conditions:    &amp;gateway.Status.Conditions,
                        conditionType: reasonErr.conditionType,
                        status:        v1.ConditionFalse,
                        reason:        reasonErr.reason,
                        message:       reasonErr.message,
                }); err != nil </span><span class="cov1" title="1">{
                        return reconcile.Result{}, fmt.Errorf("failed to set condition for Gateway %s: %w", gateway.Name, err)
                }</span>
                <span class="cov3" title="2">r.logger.WarnContext(ctx, "Failed to program gateway",
                        slog.String("gateway", gateway.GetName()),
                        slog.String("reason", reasonErr.Error()),
                )
                return reconcile.Result{}, nil</span>
        }
        <span class="cov3" title="2">return reconcile.Result{}, fmt.Errorf("failed to program Gateway %s: %w", gateway.Name, err)</span>
}

// Reconcile implements the reconcile.Reconciler interface for Gateway resources.
func (r *GatewayController) Reconcile(ctx context.Context, req reconcile.Request) (reconcile.Result, error) <span class="cov9" title="9">{
        r.logger.InfoContext(ctx, fmt.Sprintf("Processing reconciliation for Gateway %s", req.NamespacedName))
        var data resolvedGatewayDetails
        relevant, err := r.gatewayModel.resolveReconcileRequest(ctx, req, &amp;data)
        if err != nil </span><span class="cov5" title="3">{
                return r.processResourceError(ctx, err, &amp;data.gateway)
        }</span>
        <span class="cov8" title="6">if !relevant </span><span class="cov1" title="1">{
                return reconcile.Result{}, nil
        }</span>

        <span class="cov7" title="5">if !r.resourcesModel.isConditionSet(isConditionSetParams{
                resource:      &amp;data.gateway,
                conditions:    data.gateway.Status.Conditions,
                conditionType: string(gatewayv1.GatewayConditionAccepted),
        }) </span><span class="cov1" title="1">{
                if err = r.resourcesModel.setCondition(ctx, setConditionParams{
                        resource:      &amp;data.gateway,
                        conditions:    &amp;data.gateway.Status.Conditions,
                        conditionType: string(gatewayv1.GatewayConditionAccepted),
                        status:        v1.ConditionTrue,
                        reason:        string(gatewayv1.GatewayReasonAccepted),
                        message:       fmt.Sprintf("Gateway %s accepted by %s", data.gateway.Name, ControllerClassName),
                }); err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, fmt.Errorf("failed to set accepted condition for Gateway %s: %w", req.NamespacedName, err)
                }</span>
        }

        <span class="cov7" title="5">if !r.resourcesModel.isConditionSet(isConditionSetParams{
                resource:      &amp;data.gateway,
                conditions:    data.gateway.Status.Conditions,
                conditionType: string(gatewayv1.GatewayConditionProgrammed),
                annotations: map[string]string{
                        GatewayProgrammingRevisionAnnotation: GatewayProgrammingRevisionValue,
                },
        }) </span><span class="cov6" title="4">{
                r.logger.DebugContext(ctx, "Programming gateway",
                        slog.Any("req", req),
                        slog.Any("gateway", data.gateway),
                        slog.Any("gatewayClass", data.gatewayClass),
                        slog.Any("config", data.config),
                )

                if err = r.gatewayModel.programGateway(ctx, &amp;data); err != nil </span><span class="cov3" title="2">{
                        return r.processResourceError(ctx, err, &amp;data.gateway)
                }</span>

                <span class="cov3" title="2">if err = r.resourcesModel.setCondition(ctx, setConditionParams{
                        resource:      &amp;data.gateway,
                        conditions:    &amp;data.gateway.Status.Conditions,
                        conditionType: string(gatewayv1.GatewayConditionProgrammed),
                        status:        v1.ConditionTrue,
                        reason:        string(gatewayv1.GatewayConditionProgrammed),
                        message:       fmt.Sprintf("Gateway %s programmed by %s", data.gateway.Name, ControllerClassName),
                        annotations: map[string]string{
                                GatewayProgrammingRevisionAnnotation: GatewayProgrammingRevisionValue,
                        },
                }); err != nil </span><span class="cov1" title="1">{
                        return reconcile.Result{}, fmt.Errorf("failed to set accepted condition for Gateway %s: %w", req.NamespacedName, err)
                }</span>

                <span class="cov1" title="1">r.logger.InfoContext(ctx,
                        "Successfully set Programmed condition for Gateway",
                        slog.String("gateway", req.NamespacedName.String()),
                )</span>
        } else<span class="cov1" title="1"> {
                r.logger.DebugContext(ctx,
                        "Programmed condition already set for this Gateway generation",
                        slog.String("gateway", req.NamespacedName.String()),
                        slog.String("generation", strconv.FormatInt(data.gateway.Generation, 10)),
                )
        }</span>

        <span class="cov3" title="2">return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package app

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/gemyago/oke-gateway-api/internal/types"
        "github.com/oracle/oci-go-sdk/v65/loadbalancer"
        "go.uber.org/dig"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        apitypes "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
)

type resolvedGatewayDetails struct {
        gateway      gatewayv1.Gateway
        gatewayClass gatewayv1.GatewayClass
        config       types.GatewayConfig
}

type gatewayModel interface {
        // resolveReconcileRequest will resolve related resources for the reconcile request.
        // If returns false if the request is not relevant for this controller.
        // It returns true if the request is relevant for this controller.
        // It may return an error if there was error resolving the request.
        // If error happens, it may not be always known if the request is relevant.
        resolveReconcileRequest(
                ctx context.Context,
                req reconcile.Request,
                receiver *resolvedGatewayDetails,
        ) (bool, error)

        programGateway(ctx context.Context, data *resolvedGatewayDetails) error
}

type gatewayModelImpl struct {
        client               k8sClient
        logger               *slog.Logger
        ociClient            ociLoadBalancerClient
        ociLoadBalancerModel ociLoadBalancerModel
}

func (m *gatewayModelImpl) resolveReconcileRequest(
        ctx context.Context,
        req reconcile.Request,
        receiver *resolvedGatewayDetails,
) (bool, error) <span class="cov8" title="9">{
        if err := m.client.Get(ctx, req.NamespacedName, &amp;receiver.gateway); err != nil </span><span class="cov3" title="2">{
                if apierrors.IsNotFound(err) </span><span class="cov1" title="1">{
                        m.logger.InfoContext(ctx, fmt.Sprintf("Gateway %s not found", req.NamespacedName))
                        return false, nil
                }</span>
                <span class="cov1" title="1">return false, fmt.Errorf("failed to get Gateway %s: %w", req.NamespacedName, err)</span>
        }

        <span class="cov7" title="7">if err := m.client.Get(ctx, apitypes.NamespacedName{
                Name: string(receiver.gateway.Spec.GatewayClassName),
        }, &amp;receiver.gatewayClass); err != nil </span><span class="cov3" title="2">{
                if apierrors.IsNotFound(err) </span><span class="cov1" title="1">{
                        m.logger.InfoContext(ctx, fmt.Sprintf("GatewayClass %s not found", receiver.gateway.Spec.GatewayClassName))
                        return false, nil
                }</span>
                <span class="cov1" title="1">return false, fmt.Errorf("failed to get GatewayClass %s: %w", receiver.gateway.Spec.GatewayClassName, err)</span>
        }

        <span class="cov6" title="5">if receiver.gatewayClass.Spec.ControllerName != gatewayv1.GatewayController(ControllerClassName) </span><span class="cov1" title="1">{
                m.logger.InfoContext(
                        ctx,
                        fmt.Sprintf("GatewayClass %s is not managed by this controller", receiver.gateway.Spec.GatewayClassName),
                )
                return false, nil
        }</span>

        <span class="cov5" title="4">if receiver.gateway.Spec.Infrastructure == nil || receiver.gateway.Spec.Infrastructure.ParametersRef == nil </span><span class="cov1" title="1">{
                return false, &amp;resourceStatusError{
                        conditionType: string(gatewayv1.GatewayConditionAccepted),
                        reason:        string(gatewayv1.GatewayReasonInvalidParameters),
                        message:       "spec.infrastructure is missing parametersRef",
                }
        }</span>

        <span class="cov4" title="3">configName := apitypes.NamespacedName{
                Namespace: receiver.gateway.Namespace,
                Name:      receiver.gateway.Spec.Infrastructure.ParametersRef.Name,
        }

        if err := m.client.Get(ctx, configName, &amp;receiver.config); err != nil </span><span class="cov3" title="2">{
                if apierrors.IsNotFound(err) </span><span class="cov1" title="1">{
                        return false, &amp;resourceStatusError{
                                conditionType: string(gatewayv1.GatewayConditionAccepted),
                                reason:        string(gatewayv1.GatewayReasonInvalidParameters),
                                message:       "spec.infrastructure is pointing to a non-existent GatewayConfig",
                        }
                }</span>
                <span class="cov1" title="1">return false, fmt.Errorf("failed to get GatewayConfig %s: %w", configName, err)</span>
        }

        // TODO: Make sure config is complete

        <span class="cov1" title="1">return true, nil</span>
}

func (m *gatewayModelImpl) programGateway(ctx context.Context, data *resolvedGatewayDetails) error <span class="cov5" title="4">{
        loadBalancerID := data.config.Spec.LoadBalancerID
        m.logger.DebugContext(ctx, "Fetching OCI Load Balancer details",
                slog.String("loadBalancerId", loadBalancerID),
        )

        // TODO: We probably need to reset Programmed condition if we're here

        request := loadbalancer.GetLoadBalancerRequest{
                LoadBalancerId: &amp;loadBalancerID,
        }

        response, err := m.ociClient.GetLoadBalancer(ctx, request)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to get OCI Load Balancer %s: %w", loadBalancerID, err)
        }</span>

        <span class="cov4" title="3">m.logger.DebugContext(ctx, "Successfully retrieved OCI Load Balancer details",
                slog.Any("loadBalancer", response.LoadBalancer),
        )

        defaultBackendSet, err := m.ociLoadBalancerModel.reconcileDefaultBackendSet(ctx, reconcileDefaultBackendParams{
                loadBalancerID:   loadBalancerID,
                knownBackendSets: response.LoadBalancer.BackendSets,
                gateway:          &amp;data.gateway,
        })
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to program default backend set: %w", err)
        }</span>

        <span class="cov3" title="2">for _, listener := range data.gateway.Spec.Listeners </span><span class="cov6" title="5">{
                // TODO: Support listener with hostname

                params := reconcileHTTPListenerParams{
                        loadBalancerID:        loadBalancerID,
                        knownListeners:        response.LoadBalancer.Listeners,
                        defaultBackendSetName: *defaultBackendSet.Name,
                        listenerSpec:          &amp;listener,
                }

                if err = m.ociLoadBalancerModel.reconcileHTTPListener(ctx, params); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("failed to reconcile listener %s: %w", listener.Name, err)
                }</span>
        }

        <span class="cov1" title="1">if err = m.ociLoadBalancerModel.removeMissingListeners(ctx, removeMissingListenersParams{
                loadBalancerID:   loadBalancerID,
                knownListeners:   response.LoadBalancer.Listeners,
                gatewayListeners: data.gateway.Spec.Listeners,
        }); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove missing listeners: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

type gatewayModelDeps struct {
        dig.In

        K8sClient            k8sClient
        RootLogger           *slog.Logger
        OciClient            ociLoadBalancerClient
        OciLoadBalancerModel ociLoadBalancerModel
}

func newGatewayModel(deps gatewayModelDeps) gatewayModel <span class="cov10" title="14">{
        return &amp;gatewayModelImpl{
                client:               deps.K8sClient,
                logger:               deps.RootLogger.WithGroup("gateway-model"),
                ociClient:            deps.OciClient,
                ociLoadBalancerModel: deps.OciLoadBalancerModel,
        }
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package app

import (
        "context"
        "fmt"
        "log/slog"

        "go.uber.org/dig"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
)

// GatewayClassController is a simple controller that watches GatewayClass resources.
type GatewayClassController struct {
        client         k8sClient
        logger         *slog.Logger
        resourcesModel resourcesModel
}

// GatewayClassControllerDeps contains the dependencies for the GatewayClassController.
type GatewayClassControllerDeps struct {
        dig.In

        RootLogger     *slog.Logger
        K8sClient      k8sClient
        ResourcesModel resourcesModel
}

// NewGatewayClassController creates a new GatewayClassController.
func NewGatewayClassController(deps GatewayClassControllerDeps) *GatewayClassController <span class="cov10" title="7">{
        return &amp;GatewayClassController{
                client:         deps.K8sClient,
                logger:         deps.RootLogger.WithGroup("gateway-class-controller"),
                resourcesModel: deps.ResourcesModel,
        }
}</span>

// Reconcile implements the reconcile.Reconciler interface.
func (r *GatewayClassController) Reconcile(ctx context.Context, req reconcile.Request) (reconcile.Result, error) <span class="cov9" title="6">{
        var gatewayClass gatewayv1.GatewayClass
        if err := r.client.Get(ctx, req.NamespacedName, &amp;gatewayClass); err != nil </span><span class="cov4" title="2">{
                if errors.IsNotFound(err) </span><span class="cov1" title="1">{
                        r.logger.DebugContext(ctx, fmt.Sprintf("GatewayClass not present: %s", req.NamespacedName))
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov1" title="1">return reconcile.Result{}, fmt.Errorf("failed to get GatewayClass %s: %w", req.NamespacedName, err)</span>
        }

        // Check if the ControllerName matches the one we are responsible for
        <span class="cov7" title="4">if gatewayClass.Spec.ControllerName != ControllerClassName </span><span class="cov1" title="1">{
                r.logger.InfoContext(ctx,
                        "Ignoring GatewayClass because controllerName does not match",
                        slog.String("gatewayClass", req.NamespacedName.String()),
                        slog.String("expectedControllerName", ControllerClassName),
                        slog.String("actualControllerName", string(gatewayClass.Spec.ControllerName)),
                )
                return reconcile.Result{}, nil // Ignore this GatewayClass
        }</span>

        <span class="cov6" title="3">r.logger.InfoContext(ctx, fmt.Sprintf("Processing reconciliation for GatewayClass %s", req.NamespacedName))

        // Check if the GatewayClass is already in the desired state
        if r.resourcesModel.isConditionSet(isConditionSetParams{
                resource:      &amp;gatewayClass,
                conditions:    gatewayClass.Status.Conditions,
                conditionType: string(gatewayv1.GatewayClassConditionStatusAccepted),
        }) </span><span class="cov1" title="1">{
                r.logger.DebugContext(ctx, "GatewayClass is already accepted",
                        slog.String("gatewayClass", req.NamespacedName.String()),
                )
                return reconcile.Result{}, nil // Already in desired state
        }</span>

        <span class="cov4" title="2">r.logger.DebugContext(ctx, "GatewayClass reconciliation details",
                slog.Any("req", req),
                slog.Any("gatewayClass", gatewayClass),
        )

        if err := r.resourcesModel.setCondition(ctx, setConditionParams{
                resource:      &amp;gatewayClass,
                conditions:    &amp;gatewayClass.Status.Conditions,
                conditionType: string(gatewayv1.GatewayClassConditionStatusAccepted),
                status:        metav1.ConditionTrue,
                reason:        string(gatewayv1.GatewayClassReasonAccepted),
                message:       fmt.Sprintf("GatewayClass %s is accepted by %s", gatewayClass.Name, ControllerClassName),
        }); err != nil </span><span class="cov1" title="1">{
                return reconcile.Result{},
                        fmt.Errorf("failed to set accepted condition for GatewayClass %s: %w",
                                req.NamespacedName,
                                err)
        }</span>

        <span class="cov1" title="1">r.logger.InfoContext(ctx,
                "Successfully reconciled and accepted GatewayClass",
                slog.Any("gatewayClass", req.NamespacedName),
        )
        return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package app

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/gemyago/oke-gateway-api/internal/types"
        "github.com/oracle/oci-go-sdk/v65/loadbalancer"
        "github.com/samber/lo"
        "go.uber.org/dig"
        discoveryv1 "k8s.io/api/discovery/v1"
        client "sigs.k8s.io/controller-runtime/pkg/client"
        gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
)

type syncRouteEndpointsParams struct {
        httpRoute gatewayv1.HTTPRoute
        config    types.GatewayConfig
}

type syncRouteBackendRefEndpointsParams struct {
        config     types.GatewayConfig
        httpRoute  gatewayv1.HTTPRoute
        backendRef gatewayv1.HTTPBackendRef
}

type identifyBackendsToUpdateParams struct {
        endpointPort    int32
        currentBackends []loadbalancer.Backend
        endpointSlices  []discoveryv1.EndpointSlice
}

type identifyBackendsToUpdateResult struct {
        updateRequired  bool
        updatedBackends []loadbalancer.BackendDetails
        drainingCount   int
}

// httpBackendModel defines the interface for managing OCI backend sets based on HTTPRoute definitions.
type httpBackendModel interface {
        // syncRouteEndpoints synchronizes the OCI Load Balancer Backend Sets associated with the
        // provided HTTPRoute, ensuring they contain the correct set of ready endpoints
        // derived from the referenced Kubernetes Services' EndpointSlices.
        syncRouteEndpoints(ctx context.Context, params syncRouteEndpointsParams) error

        // identifyBackendsToUpdate identifies the backends that need to be updated in the OCI Load Balancer Backend Set.
        // It will correctly handle endpoint status changes, including draining endpoints.
        identifyBackendsToUpdate(
                ctx context.Context,
                params identifyBackendsToUpdateParams,
        ) (identifyBackendsToUpdateResult, error)

        // syncRouteBackendRefEndpoints synchronizes the OCI Load Balancer Backend Sets associated with the
        // single backend ref of the provided HTTPRoute.
        syncRouteBackendRefEndpoints(ctx context.Context, params syncRouteBackendRefEndpointsParams) error
}

type httpBackendModelImpl struct {
        logger              *slog.Logger
        k8sClient           k8sClient
        ociClient           ociLoadBalancerClient
        workRequestsWatcher workRequestsWatcher

        // Used to allow mocking own methods in tests
        self httpBackendModel
}

func (m *httpBackendModelImpl) syncRouteEndpoints(
        ctx context.Context,
        params syncRouteEndpointsParams,
) error <span class="cov4" title="3">{
        m.logger.InfoContext(ctx, "Syncing backend endpoints",
                slog.String("httpRoute", params.httpRoute.Name),
                slog.String("config", params.config.Name),
        )

        processedBackendRefs := make(map[string]bool)

        for index, rule := range params.httpRoute.Spec.Rules </span><span class="cov6" title="6">{
                for _, backendRef := range rule.BackendRefs </span><span class="cov10" title="18">{
                        refNamespace := lo.Ternary(
                                backendRef.Namespace != nil,
                                string(lo.FromPtr(backendRef.Namespace)),
                                params.httpRoute.Namespace,
                        )
                        refKey := refNamespace + "/" + string(backendRef.Name)

                        if _, ok := processedBackendRefs[refKey]; ok </span><span class="cov6" title="5">{
                                continue</span>
                        }

                        <span class="cov8" title="13">if err := m.self.syncRouteBackendRefEndpoints(ctx, syncRouteBackendRefEndpointsParams{
                                httpRoute:  params.httpRoute,
                                config:     params.config,
                                backendRef: backendRef,
                        }); err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to sync route backend endpoints for rule %d: %w", index, err)
                        }</span>
                        <span class="cov8" title="12">processedBackendRefs[refKey] = true</span>
                }
        }

        <span class="cov3" title="2">return nil</span>
}

func (m *httpBackendModelImpl) identifyBackendsToUpdate(
        ctx context.Context,
        params identifyBackendsToUpdateParams,
) (identifyBackendsToUpdateResult, error) <span class="cov7" title="9">{
        desiredBackendsMap := make(map[string]loadbalancer.BackendDetails)
        var drainingCount int

        for _, slice := range params.endpointSlices </span><span class="cov7" title="8">{
                for _, endpoint := range slice.Endpoints </span><span class="cov9" title="14">{
                        if endpoint.Conditions.Ready != nil &amp;&amp; !*endpoint.Conditions.Ready </span><span class="cov3" title="2">{
                                continue</span>
                        }
                        <span class="cov8" title="12">if len(endpoint.Addresses) == 0 </span><span class="cov1" title="1">{
                                m.logger.WarnContext(ctx, "Endpoint has no addresses", slog.Any("endpoint", endpoint))
                                continue</span>
                        }
                        <span class="cov8" title="11">ipAddress := endpoint.Addresses[0]
                        isDraining := endpoint.Conditions.Terminating != nil &amp;&amp; *endpoint.Conditions.Terminating

                        if isDraining </span><span class="cov3" title="2">{
                                drainingCount++
                        }</span>

                        <span class="cov8" title="11">desiredBackendsMap[ipAddress] = loadbalancer.BackendDetails{
                                Port:      lo.ToPtr(int(params.endpointPort)),
                                IpAddress: &amp;ipAddress,
                                Drain:     lo.ToPtr(isDraining),
                                // Weight, MaxConnections, Backup, Offline are not managed here
                        }</span>
                }
        }

        <span class="cov7" title="9">currentBackendsMap := lo.SliceToMap(
                lo.Filter(params.currentBackends, func(b loadbalancer.Backend, _ int) bool </span><span class="cov8" title="11">{
                        return b.IpAddress != nil
                }</span>),
                func(b loadbalancer.Backend) (string, loadbalancer.Backend) <span class="cov8" title="11">{
                        return *b.IpAddress, b
                }</span>,
        )

        <span class="cov7" title="9">updateRequired := false
        if len(desiredBackendsMap) != len(currentBackendsMap) </span><span class="cov6" title="5">{
                updateRequired = true
        }</span> else<span class="cov5" title="4"> {
                for ip, desired := range desiredBackendsMap </span><span class="cov5" title="4">{
                        current, exists := currentBackendsMap[ip]
                        if !exists || lo.FromPtr(desired.Drain) != lo.FromPtr(current.Drain) </span><span class="cov3" title="2">{
                                updateRequired = true
                                break</span>
                        }
                }
        }

        <span class="cov7" title="9">updatedBackends := lo.Values(desiredBackendsMap)

        return identifyBackendsToUpdateResult{
                updateRequired:  updateRequired,
                updatedBackends: updatedBackends,
                drainingCount:   drainingCount,
        }, nil</span>
}

func (m *httpBackendModelImpl) syncRouteBackendRefEndpoints(
        ctx context.Context,
        params syncRouteBackendRefEndpointsParams,
) error <span class="cov3" title="2">{
        backendRef := params.backendRef
        backendSetName := ociBackendSetNameFromBackendRef(params.httpRoute, backendRef)

        getResp, err := m.ociClient.GetBackendSet(ctx, loadbalancer.GetBackendSetRequest{
                LoadBalancerId: &amp;params.config.Spec.LoadBalancerID,
                BackendSetName: &amp;backendSetName,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get backend set %s: %w", backendSetName, err)
        }</span>
        <span class="cov3" title="2">existingBackendSet := getResp.BackendSet

        backendPort := lo.FromPtr(params.backendRef.BackendObjectReference.Port)

        var endpointSlices discoveryv1.EndpointSliceList

        if err = m.k8sClient.List(ctx, &amp;endpointSlices, client.MatchingLabels{
                // TODO: Check if namespace is needed
                discoveryv1.LabelServiceName: string(backendRef.BackendObjectReference.Name),
        }); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list endpoint slices for backend %s: %w", backendRef.BackendObjectReference.Name, err)
        }</span>

        <span class="cov3" title="2">backendsToUpdate, err := m.self.identifyBackendsToUpdate(ctx, identifyBackendsToUpdateParams{
                endpointPort:    int32(backendPort),
                currentBackends: existingBackendSet.Backends,
                endpointSlices:  endpointSlices.Items,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to identify backends to update: %w", err)
        }</span>

        <span class="cov3" title="2">if !backendsToUpdate.updateRequired </span><span class="cov1" title="1">{
                m.logger.InfoContext(ctx, "Backend set already up-to-date, skipping update",
                        slog.String("backendSetName", backendSetName),
                        slog.String("httpRoute", params.httpRoute.Name),
                        slog.String("backendRefName", string(backendRef.Name)),
                )
                return nil
        }</span>

        <span class="cov1" title="1">m.logger.InfoContext(ctx, "Syncing backend endpoints for backendRef",
                slog.String("httpRoute", params.httpRoute.Name),
                slog.String("backendRefName", string(backendRef.Name)),
                slog.String("backendSetName", backendSetName),
                slog.Int("currentBackends", len(existingBackendSet.Backends)),
                slog.Int("updatedBackends", len(backendsToUpdate.updatedBackends)),
                slog.Int("drainingCount", backendsToUpdate.drainingCount),
        )

        ociUpdateResp, err := m.ociClient.UpdateBackendSet(ctx, loadbalancer.UpdateBackendSetRequest{
                LoadBalancerId:          &amp;params.config.Spec.LoadBalancerID,
                BackendSetName:          &amp;backendSetName,
                UpdateBackendSetDetails: makeUpdateOciBackendSetDetails(existingBackendSet, backendsToUpdate.updatedBackends),
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update backend set %s: %w", backendSetName, err)
        }</span>

        <span class="cov1" title="1">err = m.workRequestsWatcher.WaitFor(ctx, *ociUpdateResp.OpcWorkRequestId)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to wait for backend set %s to be updated: %w", backendSetName, err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func makeUpdateOciBackendSetDetails(
        existingBackendSet loadbalancer.BackendSet,
        newBackends []loadbalancer.BackendDetails,
) loadbalancer.UpdateBackendSetDetails <span class="cov1" title="1">{
        updateDetails := loadbalancer.UpdateBackendSetDetails{
                Backends: newBackends,

                Policy:                                  existingBackendSet.Policy,
                SessionPersistenceConfiguration:         existingBackendSet.SessionPersistenceConfiguration,
                LbCookieSessionPersistenceConfiguration: existingBackendSet.LbCookieSessionPersistenceConfiguration,
        }

        if existingBackendSet.HealthChecker != nil </span><span class="cov1" title="1">{
                updateDetails.HealthChecker = &amp;loadbalancer.HealthCheckerDetails{
                        Protocol:          existingBackendSet.HealthChecker.Protocol,
                        UrlPath:           existingBackendSet.HealthChecker.UrlPath,
                        Port:              existingBackendSet.HealthChecker.Port,
                        ReturnCode:        existingBackendSet.HealthChecker.ReturnCode,
                        Retries:           existingBackendSet.HealthChecker.Retries,
                        TimeoutInMillis:   existingBackendSet.HealthChecker.TimeoutInMillis,
                        IntervalInMillis:  existingBackendSet.HealthChecker.IntervalInMillis,
                        ResponseBodyRegex: existingBackendSet.HealthChecker.ResponseBodyRegex,
                        IsForcePlainText:  existingBackendSet.HealthChecker.IsForcePlainText,
                }
        }</span>

        <span class="cov1" title="1">if existingBackendSet.SslConfiguration != nil </span><span class="cov1" title="1">{
                updateDetails.SslConfiguration = &amp;loadbalancer.SslConfigurationDetails{
                        CertificateName:                existingBackendSet.SslConfiguration.CertificateName,
                        TrustedCertificateAuthorityIds: existingBackendSet.SslConfiguration.TrustedCertificateAuthorityIds,
                        VerifyDepth:                    existingBackendSet.SslConfiguration.VerifyDepth,
                        VerifyPeerCertificate:          existingBackendSet.SslConfiguration.VerifyPeerCertificate,
                        CertificateIds:                 existingBackendSet.SslConfiguration.CertificateIds,
                        CipherSuiteName:                existingBackendSet.SslConfiguration.CipherSuiteName,
                        ServerOrderPreference: loadbalancer.SslConfigurationDetailsServerOrderPreferenceEnum(
                                existingBackendSet.SslConfiguration.ServerOrderPreference,
                        ),
                        Protocols:            existingBackendSet.SslConfiguration.Protocols,
                        HasSessionResumption: existingBackendSet.SslConfiguration.HasSessionResumption,
                }
        }</span>

        <span class="cov1" title="1">return updateDetails</span>
}

// httpBackendModelDeps contains the dependencies for the HTTPBackendModel.
type httpBackendModelDeps struct {
        dig.In `ignore-unexported:"true"`

        RootLogger            *slog.Logger
        K8sClient             k8sClient
        OciLoadBalancerClient ociLoadBalancerClient
        WorkRequestsWatcher   workRequestsWatcher

        // Used to allow mocking own methods in tests
        self httpBackendModel
}

// newHTTPBackendModel creates a new HTTPBackendModel.
func newHTTPBackendModel(deps httpBackendModelDeps) httpBackendModel <span class="cov9" title="15">{
        model := &amp;httpBackendModelImpl{
                logger:              deps.RootLogger.WithGroup("http-backend-model"),
                k8sClient:           deps.K8sClient,
                ociClient:           deps.OciLoadBalancerClient,
                workRequestsWatcher: deps.WorkRequestsWatcher,
                self:                deps.self,
        }
        model.self = lo.Ternary[httpBackendModel](model.self != nil, model.self, model)
        return model
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package app

import (
        "context"
        "fmt"
        "log/slog"

        "go.uber.org/dig"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
)

// HTTPRouteController is a simple controller that watches HTTPRoute resources.
type HTTPRouteController struct {
        logger           *slog.Logger
        httpRouteModel   httpRouteModel
        httpBackendModel httpBackendModel
}

// HTTPRouteControllerDeps contains the dependencies for the HTTPRouteController.
type HTTPRouteControllerDeps struct {
        dig.In

        RootLogger       *slog.Logger
        HTTPRouteModel   httpRouteModel
        HTTPBackendModel httpBackendModel
}

// NewHTTPRouteController creates a new HTTPRouteController.
func NewHTTPRouteController(deps HTTPRouteControllerDeps) *HTTPRouteController <span class="cov10" title="11">{
        return &amp;HTTPRouteController{
                logger:           deps.RootLogger.WithGroup("httproute-controller"),
                httpRouteModel:   deps.HTTPRouteModel,
                httpBackendModel: deps.HTTPBackendModel,
        }
}</span>

func (r *HTTPRouteController) performProgramming(
        ctx context.Context,
        resolvedData resolvedRouteDetails,
) error <span class="cov7" title="5">{
        r.logger.DebugContext(ctx, "Performing HTTProute programming",
                slog.String("httpRoute", resolvedData.httpRoute.Name),
                slog.String("gateway", resolvedData.gatewayDetails.gateway.Name),
        )

        var acceptedRoute *gatewayv1.HTTPRoute
        acceptedRoute, err := r.httpRouteModel.acceptRoute(ctx, resolvedData)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to accept route: %w", err)
        }</span>

        <span class="cov6" title="4">knownBackends, err := r.httpRouteModel.resolveBackendRefs(ctx, resolveBackendRefsParams{
                httpRoute: *acceptedRoute,
        })
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to resolve backend refs: %w", err)
        }</span>

        <span class="cov5" title="3">programResult, err := r.httpRouteModel.programRoute(ctx, programRouteParams{
                gateway:          resolvedData.gatewayDetails.gateway,
                config:           resolvedData.gatewayDetails.config,
                httpRoute:        *acceptedRoute,
                matchedListeners: resolvedData.matchedListeners,
                knownBackends:    knownBackends,
        })
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to program route: %w", err)
        }</span>

        // Mark the route as programmed by setting the ResolvedRefs condition
        <span class="cov3" title="2">if err = r.httpRouteModel.setProgrammed(ctx, setProgrammedParams{
                gatewayClass:          resolvedData.gatewayDetails.gatewayClass,
                gateway:               resolvedData.gatewayDetails.gateway,
                httpRoute:             *acceptedRoute,
                matchedRef:            resolvedData.matchedRef,
                programmedPolicyRules: programResult.programmedPolicyRules,
        }); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to set programmed status: %w", err)
        }</span>

        <span class="cov1" title="1">r.logger.InfoContext(ctx, "Successfully programmed HTTProute",
                slog.String("httpRoute", resolvedData.httpRoute.Name),
                slog.String("gateway", resolvedData.gatewayDetails.gateway.Name),
        )

        return nil</span>
}

// Reconcile implements the reconcile.Reconciler interface.
// For now, it just returns a "not implemented" error.
func (r *HTTPRouteController) Reconcile(ctx context.Context, req reconcile.Request) (reconcile.Result, error) <span class="cov9" title="10">{
        r.logger.InfoContext(ctx, fmt.Sprintf("Processing reconciliation for HTTProute %s", req.NamespacedName))

        resolvedRequests, err := r.httpRouteModel.resolveRequest(ctx, req)
        if err != nil </span><span class="cov1" title="1">{
                return reconcile.Result{}, fmt.Errorf("failed to resolve request parent: %w", err)
        }</span>
        <span class="cov9" title="9">if len(resolvedRequests) == 0 </span><span class="cov1" title="1">{
                r.logger.InfoContext(ctx, "Ignoring irrelevant HTTPRoute route",
                        slog.String("httpRoute", req.NamespacedName.String()),
                )
                return reconcile.Result{}, nil
        }</span>

        <span class="cov8" title="8">for _, resolvedData := range resolvedRequests </span><span class="cov8" title="8">{
                var programmingRequired bool
                programmingRequired, err = r.httpRouteModel.isProgrammingRequired(resolvedData)
                if err != nil </span><span class="cov1" title="1">{
                        return reconcile.Result{}, fmt.Errorf("failed to check programming requirement for gateway %s: %w",
                                resolvedData.gatewayDetails.gateway.Name, err)
                }</span>

                <span class="cov8" title="7">if programmingRequired </span><span class="cov7" title="5">{
                        err = r.performProgramming(ctx, resolvedData)
                        if err != nil </span><span class="cov6" title="4">{
                                return reconcile.Result{}, fmt.Errorf("failed to perform programming for gateway %s: %w",
                                        resolvedData.gatewayDetails.gateway.Name, err)
                        }</span>
                } else<span class="cov3" title="2"> {
                        r.logger.DebugContext(ctx, "HTTPRoute programming not required for parent",
                                slog.String("httpRoute", req.NamespacedName.String()),
                                slog.String("gateway", resolvedData.gatewayDetails.gateway.Name),
                        )
                }</span>

                <span class="cov5" title="3">err = r.httpBackendModel.syncRouteEndpoints(ctx, syncRouteEndpointsParams{
                        httpRoute: resolvedData.httpRoute,
                        config:    resolvedData.gatewayDetails.config,
                })
                if err != nil </span><span class="cov1" title="1">{
                        return reconcile.Result{}, fmt.Errorf("failed to sync backend endpoints: %w", err)
                }</span>
        }

        <span class="cov3" title="2">r.logger.InfoContext(ctx, fmt.Sprintf("Reconciled HTTProute %s", req.NamespacedName))

        return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package app

import (
        "context"
        "fmt"
        "log/slog"
        "strings"

        "github.com/gemyago/oke-gateway-api/internal/types"
        "github.com/oracle/oci-go-sdk/v65/loadbalancer"
        "github.com/samber/lo"
        "go.uber.org/dig"
        v1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/api/meta"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        apitypes "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
)

type resolvedRouteDetails struct {
        gatewayDetails   resolvedGatewayDetails
        httpRoute        gatewayv1.HTTPRoute
        matchedRef       gatewayv1.ParentReference
        matchedListeners []gatewayv1.Listener
}

type resolveBackendRefsParams struct {
        httpRoute gatewayv1.HTTPRoute
}

type programRouteParams struct {
        gateway          gatewayv1.Gateway
        config           types.GatewayConfig
        httpRoute        gatewayv1.HTTPRoute
        knownBackends    map[string]v1.Service
        matchedListeners []gatewayv1.Listener
}

type programRouteResult struct {
        // Names of the policy rules that were programmed for this particular route
        programmedPolicyRules []string
}

type setProgrammedParams struct {
        httpRoute    gatewayv1.HTTPRoute
        gatewayClass gatewayv1.GatewayClass
        gateway      gatewayv1.Gateway
        matchedRef   gatewayv1.ParentReference

        // List of load balancer policy rules that were programmed for this route
        programmedPolicyRules []string
}

// httpRouteModel defines the interface for managing HTTPRoute resources.
type httpRouteModel interface {
        // resolveRequest resolves the parent details for a given HTTPRoute.
        // It returns a map of parent names (gateway names) to resolved route details.
        resolveRequest(
                ctx context.Context,
                req reconcile.Request,
        ) (map[apitypes.NamespacedName]resolvedRouteDetails, error)

        // acceptRoute accepts a reconcile request for a given HTTPRoute.
        // It returns updated HTTPRoute with status parents updated.
        acceptRoute(
                ctx context.Context,
                routeDetails resolvedRouteDetails,
        ) (*gatewayv1.HTTPRoute, error)

        // resolveBackendRefs resolves the backend references for a given HTTPRoute.
        // It returns a map of service name to service object. It may update the route status
        // with the ResolvedRefs condition.
        resolveBackendRefs(
                ctx context.Context,
                params resolveBackendRefsParams,
        ) (map[string]v1.Service, error)

        // isProgrammingRequired checks if the route programming is required based on the current state.
        isProgrammingRequired(
                details resolvedRouteDetails,
        ) (bool, error)

        // programRoute programs a given HTTPRoute.
        programRoute(
                ctx context.Context,
                params programRouteParams,
        ) (programRouteResult, error)

        // setProgrammed marks the route as successfully programmed by updating its status.
        setProgrammed(
                ctx context.Context,
                params setProgrammedParams,
        ) error
}

// parentRefSameTarget checks if two parent references target the same resource.
// It ignores the section name and port.
func parentRefSameTarget(a, b gatewayv1.ParentReference) bool <span class="cov7" title="12">{
        return a.Name == b.Name &amp;&amp;
                lo.FromPtr(a.Namespace) == lo.FromPtr(b.Namespace) &amp;&amp;
                lo.FromPtr(a.Kind) == lo.FromPtr(b.Kind) &amp;&amp;
                lo.FromPtr(a.Group) == lo.FromPtr(b.Group)
}</span>

// makeTargetOnlyParentRef makes a parent reference that only targets the resource
// by name and namespace. It ignores the section name and port.
func makeTargetOnlyParentRef(parentRef gatewayv1.ParentReference) gatewayv1.ParentReference <span class="cov6" title="7">{
        return gatewayv1.ParentReference{
                Name:      parentRef.Name,
                Namespace: parentRef.Namespace,
                Kind:      parentRef.Kind,
                Group:     parentRef.Group,
        }
}</span>

func backendRefName(
        backendRef gatewayv1.HTTPBackendRef,
        defaultNamespace string,
) apitypes.NamespacedName <span class="cov6" title="9">{
        return apitypes.NamespacedName{
                Name: string(backendRef.BackendObjectReference.Name),
                Namespace: lo.IfF(
                        backendRef.BackendObjectReference.Namespace != nil,
                        func() string </span><span class="cov6" title="7">{ return string(*backendRef.BackendObjectReference.Namespace) }</span>,
                ).Else(defaultNamespace),
        }
}

type httpRouteModelImpl struct {
        client               k8sClient
        logger               *slog.Logger
        gatewayModel         gatewayModel
        resourcesModel       resourcesModel
        ociLoadBalancerModel ociLoadBalancerModel
}

// resolveRouteParentRefData attempts to resolve a single parent reference for an HTTPRoute.
// It returns the resolved gateway details, the matched listeners based on SectionName (if any),
// and an error if resolution fails. If the gateway is not found or no listeners match the
// SectionName, it returns nil details/listeners without an error.
func (m *httpRouteModelImpl) resolveRouteParentRefData(
        ctx context.Context,
        httpRoute gatewayv1.HTTPRoute,
        parentRef gatewayv1.ParentReference,
        defaultNamespace string,
) (*resolvedGatewayDetails, []gatewayv1.Listener, error) <span class="cov7" title="13">{
        var resolvedGatewayData resolvedGatewayDetails
        gatewayNamespace := defaultNamespace
        if parentRef.Namespace != nil </span><span class="cov7" title="13">{
                gatewayNamespace = string(lo.FromPtr(parentRef.Namespace))
        }</span>
        <span class="cov7" title="13">parentName := apitypes.NamespacedName{
                Namespace: gatewayNamespace,
                Name:      string(parentRef.Name),
        }
        m.logger.DebugContext(ctx, "Resolving parent for HTTProute",
                slog.String("parentName", parentName.String()),
                slog.Any("parentRef", parentRef),
                slog.String("route", apitypes.NamespacedName{
                        Namespace: httpRoute.Namespace,
                        Name:      httpRoute.Name,
                }.String()),
        )

        gatewayResolved, err := m.gatewayModel.resolveReconcileRequest(ctx, reconcile.Request{
                NamespacedName: parentName,
        }, &amp;resolvedGatewayData)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, fmt.Errorf("failed to resolve gateway %s for route %s/%s: %w",
                        parentName.String(), httpRoute.Namespace, httpRoute.Name, err)
        }</span>
        <span class="cov7" title="12">if !gatewayResolved </span><span class="cov5" title="5">{
                m.logger.DebugContext(ctx, "Gateway not resolved or not relevant",
                        slog.String("parentName", parentName.String()),
                )
                return nil, nil, nil
        }</span>

        <span class="cov6" title="7">if parentRef.SectionName != nil </span><span class="cov5" title="5">{
                sectionName := *parentRef.SectionName
                matchingListeners := lo.Filter(resolvedGatewayData.gateway.Spec.Listeners, func(l gatewayv1.Listener, _ int) bool </span><span class="cov7" title="11">{
                        return l.Name == sectionName
                }</span>)

                <span class="cov5" title="5">if len(matchingListeners) == 0 </span><span class="cov2" title="2">{
                        m.logger.DebugContext(ctx, "Gateway resolved, but no listener matched section name",
                                slog.String("parentName", parentName.String()),
                                slog.String("sectionName", string(sectionName)),
                        )
                        return nil, nil, nil
                }</span>

                <span class="cov3" title="3">m.logger.DebugContext(ctx, "Gateway resolved with matching section name listener(s)",
                        slog.String("parentName", parentName.String()),
                        slog.String("sectionName", string(sectionName)),
                        slog.Int("matchedListenersCount", len(matchingListeners)),
                )
                return &amp;resolvedGatewayData, matchingListeners, nil</span>
        }

        // If no SectionName, all listeners are considered matched
        <span class="cov2" title="2">m.logger.DebugContext(ctx, "Gateway resolved without section name, all listeners match",
                slog.String("parentName", parentName.String()),
        )
        return &amp;resolvedGatewayData, resolvedGatewayData.gateway.Spec.Listeners, nil</span>
}

// aggregateRouteParentRefData adds or updates the results map with the resolved parent details.
// It handles merging listeners if the same gateway is referenced multiple times (e.g., by different sections).
func (m *httpRouteModelImpl) aggregateRouteParentRefData(
        ctx context.Context,
        results map[apitypes.NamespacedName]resolvedRouteDetails,
        httpRoute gatewayv1.HTTPRoute,
        gatewayDetails resolvedGatewayDetails,
        matchedRef gatewayv1.ParentReference, // Should be target-only ref
        matchedListeners []gatewayv1.Listener,
) <span class="cov5" title="5">{
        parentName := apitypes.NamespacedName{
                Namespace: gatewayDetails.gateway.Namespace,
                Name:      gatewayDetails.gateway.Name,
        }

        if existingResult, found := results[parentName]; found </span><span class="cov1" title="1">{
                newListeners := lo.UniqBy(
                        append(existingResult.matchedListeners, matchedListeners...),
                        func(l gatewayv1.Listener) gatewayv1.SectionName </span><span class="cov2" title="2">{
                                return l.Name
                        }</span>,
                )
                <span class="cov1" title="1">existingResult.matchedListeners = newListeners
                results[parentName] = existingResult
                m.logger.DebugContext(ctx, "Appended/merged listeners for existing gateway result",
                        slog.String("parentName", parentName.String()),
                        slog.Int("totalListeners", len(newListeners)),
                )</span>
        } else<span class="cov4" title="4"> {
                results[parentName] = resolvedRouteDetails{
                        httpRoute:        httpRoute,
                        gatewayDetails:   gatewayDetails,
                        matchedRef:       matchedRef, // Use the target-only ref
                        matchedListeners: matchedListeners,
                }
                m.logger.DebugContext(ctx, "Added new gateway result",
                        slog.String("parentName", parentName.String()),
                        slog.Int("initialListeners", len(matchedListeners)),
                )
        }</span>
}

func (m *httpRouteModelImpl) resolveRequest(
        ctx context.Context,
        req reconcile.Request,
) (map[apitypes.NamespacedName]resolvedRouteDetails, error) <span class="cov6" title="9">{
        var httpRoute gatewayv1.HTTPRoute
        if err := m.client.Get(ctx, req.NamespacedName, &amp;httpRoute); err != nil </span><span class="cov2" title="2">{
                if apierrors.IsNotFound(err) </span><span class="cov1" title="1">{
                        m.logger.DebugContext(ctx, "HTTProute not found during resolution",
                                slog.String("route", req.NamespacedName.String()),
                        )
                        return map[apitypes.NamespacedName]resolvedRouteDetails{}, nil
                }</span>
                <span class="cov1" title="1">return nil, fmt.Errorf("failed to get HTTPRoute %s: %w", req.NamespacedName.String(), err)</span>
        }

        <span class="cov6" title="7">results := make(map[apitypes.NamespacedName]resolvedRouteDetails)

        for _, parentRef := range httpRoute.Spec.ParentRefs </span><span class="cov7" title="13">{
                resolvedGatewayData, matchedListeners, err := m.resolveRouteParentRefData(
                        ctx,
                        httpRoute,
                        parentRef,
                        req.NamespacedName.Namespace,
                )
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>

                <span class="cov7" title="12">if resolvedGatewayData != nil </span><span class="cov5" title="5">{
                        m.aggregateRouteParentRefData(ctx,
                                results,
                                httpRoute,
                                *resolvedGatewayData,
                                makeTargetOnlyParentRef(parentRef),
                                matchedListeners,
                        )
                }</span>
        }

        <span class="cov5" title="6">if len(results) == 0 </span><span class="cov2" title="2">{
                m.logger.InfoContext(ctx, "No relevant gateway found for HTTProute after checking all parents",
                        slog.String("route", req.NamespacedName.String()),
                        slog.Int("triedParentRefs", len(httpRoute.Spec.ParentRefs)),
                )
        }</span>

        <span class="cov5" title="6">return results, nil</span>
}

// TODO: Some mechanism to check if all parents are accepted
// also if listeners are present

func (m *httpRouteModelImpl) acceptRoute(
        ctx context.Context,
        routeDetails resolvedRouteDetails,
) (*gatewayv1.HTTPRoute, error) <span class="cov5" title="5">{
        parentStatus, parentStatusIndex, found := lo.FindIndexOf(
                routeDetails.httpRoute.Status.Parents,
                func(s gatewayv1.RouteParentStatus) bool </span><span class="cov6" title="9">{
                        return s.ControllerName == routeDetails.gatewayDetails.gatewayClass.Spec.ControllerName &amp;&amp;
                                parentRefSameTarget(s.ParentRef, routeDetails.matchedRef)
                }</span>)
        <span class="cov5" title="5">if found </span><span class="cov3" title="3">{
                existingCondition := meta.FindStatusCondition(
                        parentStatus.Conditions,
                        string(gatewayv1.RouteConditionAccepted),
                )
                if existingCondition != nil &amp;&amp;
                        existingCondition.ObservedGeneration == routeDetails.httpRoute.Generation &amp;&amp;
                        existingCondition.Status == metav1.ConditionTrue </span><span class="cov1" title="1">{
                        m.logger.DebugContext(ctx, "HTTProute is already accepted",
                                slog.String("route", routeDetails.httpRoute.Name),
                                slog.String("gateway", routeDetails.gatewayDetails.gateway.Name),
                                slog.Int64("generation", existingCondition.ObservedGeneration),
                        )
                        return &amp;routeDetails.httpRoute, nil
                }</span>
        } else<span class="cov2" title="2"> {
                parentStatus = gatewayv1.RouteParentStatus{
                        // We collapse the parent ref into a single object
                        // so using just name and namespace
                        ParentRef:      makeTargetOnlyParentRef(routeDetails.matchedRef),
                        ControllerName: routeDetails.gatewayDetails.gatewayClass.Spec.ControllerName,
                }
        }</span>

        <span class="cov4" title="4">httpRoute := routeDetails.httpRoute.DeepCopy()
        meta.SetStatusCondition(&amp;parentStatus.Conditions, metav1.Condition{
                Type:               string(gatewayv1.RouteConditionAccepted),
                Status:             metav1.ConditionTrue,
                Reason:             string(gatewayv1.RouteReasonAccepted),
                ObservedGeneration: httpRoute.Generation,
                LastTransitionTime: metav1.Now(),
                Message:            fmt.Sprintf("Route accepted by %s", routeDetails.gatewayDetails.gateway.Name),
        })

        if found </span><span class="cov2" title="2">{
                m.logger.InfoContext(ctx, "Updating HTTProute status as Accepted",
                        slog.String("route", httpRoute.Name),
                        slog.String("gateway", routeDetails.gatewayDetails.gateway.Name),
                )
                httpRoute.Status.Parents[parentStatusIndex] = parentStatus
        }</span> else<span class="cov2" title="2"> {
                m.logger.InfoContext(ctx, "Accepting new HTTProute",
                        slog.String("route", httpRoute.Name),
                        slog.String("gateway", routeDetails.gatewayDetails.gateway.Name),
                )
                httpRoute.Status.Parents = append(httpRoute.Status.Parents, parentStatus)
        }</span>

        <span class="cov4" title="4">if err := m.client.Status().Update(ctx, httpRoute); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to update status for HTTProute %s: %w", httpRoute.Name, err)
        }</span>

        <span class="cov3" title="3">return httpRoute, nil</span>
}

func (m *httpRouteModelImpl) resolveBackendRefs(
        ctx context.Context,
        params resolveBackendRefsParams,
) (map[string]v1.Service, error) <span class="cov2" title="2">{
        resolvedBackendRefs := make(map[string]v1.Service)
        for _, rule := range params.httpRoute.Spec.Rules </span><span class="cov3" title="3">{
                for _, backendRef := range rule.BackendRefs </span><span class="cov5" title="5">{
                        fullName := backendRefName(backendRef, params.httpRoute.Namespace)

                        var service v1.Service
                        if err := m.client.Get(ctx, fullName, &amp;service); err != nil </span><span class="cov1" title="1">{
                                return nil, fmt.Errorf("failed to get service %s: %w", fullName.String(), err)
                        }</span>

                        <span class="cov4" title="4">m.logger.DebugContext(ctx, "Backend ref resolved",
                                slog.String("fullName", fullName.String()),
                                slog.String("uuid", string(service.UID)),
                        )
                        resolvedBackendRefs[fullName.String()] = service</span>

                        // TODO: Maybe check port and other stuff here
                }
        }

        // TODO: This should handle unresolved refs and update the status
        // as per spec

        <span class="cov1" title="1">return resolvedBackendRefs, nil</span>
}

func (m *httpRouteModelImpl) programRoute(
        ctx context.Context,
        params programRouteParams,
) (programRouteResult, error) <span class="cov5" title="5">{
        // First, reconcile all backend sets for known backends
        for key, service := range params.knownBackends </span><span class="cov6" title="9">{
                err := m.ociLoadBalancerModel.reconcileBackendSet(ctx, reconcileBackendSetParams{
                        loadBalancerID: params.config.Spec.LoadBalancerID,
                        service:        service,
                })
                if err != nil </span><span class="cov1" title="1">{
                        return programRouteResult{}, fmt.Errorf("failed to reconcile backend set for service %s: %w", key, err)
                }</span>
        }

        // Create all routing rules for the HTTP route
        <span class="cov4" title="4">policyRules := make([]loadbalancer.RoutingRule, 0, len(params.httpRoute.Spec.Rules))
        policyRulesNames := make([]string, 0, len(params.httpRoute.Spec.Rules))
        for ruleIndex := range params.httpRoute.Spec.Rules </span><span class="cov5" title="6">{
                rule, err := m.ociLoadBalancerModel.makeRoutingRule(ctx, makeRoutingRuleParams{
                        httpRoute:          params.httpRoute,
                        httpRouteRuleIndex: ruleIndex,
                })
                if err != nil </span><span class="cov1" title="1">{
                        return programRouteResult{},
                                fmt.Errorf("failed to make routing rule %d for route %s: %w", ruleIndex, params.httpRoute.Name, err)
                }</span>
                <span class="cov5" title="5">policyRules = append(policyRules, rule)
                policyRulesNames = append(policyRulesNames, *rule.Name)</span>
        }

        <span class="cov3" title="3">var prevPolicyRules []string
        if prevPolicyRulesStr, ok := params.httpRoute.Annotations[HTTPRouteProgrammedPolicyRulesAnnotation]; ok </span><span class="cov1" title="1">{
                prevPolicyRules = strings.Split(prevPolicyRulesStr, ",")
        }</span>

        // Commit the rules to each listener's policy
        <span class="cov3" title="3">for _, listener := range params.matchedListeners </span><span class="cov6" title="8">{
                err := m.ociLoadBalancerModel.commitRoutingPolicy(ctx, commitRoutingPolicyParams{
                        loadBalancerID:  params.config.Spec.LoadBalancerID,
                        listenerName:    string(listener.Name),
                        policyRules:     policyRules,
                        prevPolicyRules: prevPolicyRules,
                })
                if err != nil </span><span class="cov1" title="1">{
                        return programRouteResult{}, fmt.Errorf("failed to commit routing policy for listener %s: %w", listener.Name, err)
                }</span>
        }

        <span class="cov2" title="2">return programRouteResult{
                programmedPolicyRules: policyRulesNames,
        }, nil</span>
}

func (m *httpRouteModelImpl) isProgrammingRequired(
        details resolvedRouteDetails,
) (bool, error) <span class="cov3" title="3">{
        parentStatus, found := lo.Find(details.httpRoute.Status.Parents, func(s gatewayv1.RouteParentStatus) bool </span><span class="cov3" title="3">{
                return s.ControllerName == details.gatewayDetails.gatewayClass.Spec.ControllerName &amp;&amp;
                        parentRefSameTarget(s.ParentRef, details.matchedRef)
        }</span>)

        <span class="cov3" title="3">if !found </span><span class="cov2" title="2">{
                return true, nil
        }</span>

        <span class="cov1" title="1">return !m.resourcesModel.isConditionSet(isConditionSetParams{
                resource:      &amp;details.httpRoute,
                conditions:    parentStatus.Conditions,
                conditionType: string(gatewayv1.RouteConditionResolvedRefs),
                annotations: map[string]string{
                        HTTPRouteProgrammingRevisionAnnotation: HTTPRouteProgrammingRevisionValue,
                },
        }), nil</span>
}

func (m *httpRouteModelImpl) setProgrammed(
        ctx context.Context,
        params setProgrammedParams,
) error <span class="cov4" title="4">{
        httpRoute := params.httpRoute.DeepCopy()

        _, statusIndex, found := lo.FindIndexOf(
                httpRoute.Status.Parents,
                func(s gatewayv1.RouteParentStatus) bool </span><span class="cov5" title="5">{
                        return s.ControllerName == params.gatewayClass.Spec.ControllerName &amp;&amp;
                                parentRefSameTarget(s.ParentRef, params.matchedRef)
                }</span>,
        )

        <span class="cov4" title="4">if !found </span><span class="cov2" title="2">{
                return fmt.Errorf("parent status not found for controller %s and parentRef %s",
                        params.gatewayClass.Spec.ControllerName,
                        params.matchedRef.Name,
                )
        }</span>

        <span class="cov2" title="2">if err := m.resourcesModel.setCondition(ctx, setConditionParams{
                resource:      httpRoute,
                conditions:    &amp;httpRoute.Status.Parents[statusIndex].Conditions,
                conditionType: string(gatewayv1.RouteConditionResolvedRefs),
                status:        metav1.ConditionTrue,
                reason:        string(gatewayv1.RouteReasonResolvedRefs),
                message:       fmt.Sprintf("Route programmed by %s", params.gateway.Name),
                annotations: map[string]string{
                        HTTPRouteProgrammingRevisionAnnotation:   HTTPRouteProgrammingRevisionValue,
                        HTTPRouteProgrammedPolicyRulesAnnotation: strings.Join(params.programmedPolicyRules, ","),
                },
        }); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to update programmed status for HTTProute %s: %w", httpRoute.Name, err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// httpRouteModelDeps defines the dependencies required for the httpRouteModel.
type httpRouteModelDeps struct {
        dig.In

        K8sClient      k8sClient
        RootLogger     *slog.Logger
        GatewayModel   gatewayModel
        OciLBModel     ociLoadBalancerModel
        ResourcesModel resourcesModel
}

// newHTTPRouteModel creates a new instance of httpRouteModel.
func newHTTPRouteModel(deps httpRouteModelDeps) httpRouteModel <span class="cov10" title="29">{
        return &amp;httpRouteModelImpl{
                client:               deps.K8sClient,
                logger:               deps.RootLogger.WithGroup("httproute-model"),
                gatewayModel:         deps.GatewayModel,
                ociLoadBalancerModel: deps.OciLBModel,
                resourcesModel:       deps.ResourcesModel,
        }
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package app

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
        reconcile "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// MockgatewayModel is an autogenerated mock type for the gatewayModel type
type MockgatewayModel struct {
        mock.Mock
}

type MockgatewayModel_Expecter struct {
        mock *mock.Mock
}

func (_m *MockgatewayModel) EXPECT() *MockgatewayModel_Expecter <span class="cov9" title="25">{
        return &amp;MockgatewayModel_Expecter{mock: &amp;_m.Mock}
}</span>

// programGateway provides a mock function with given fields: ctx, data
func (_m *MockgatewayModel) programGateway(ctx context.Context, data *resolvedGatewayDetails) error <span class="cov4" title="4">{
        ret := _m.Called(ctx, data)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for programGateway")</span>
        }

        <span class="cov4" title="4">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *resolvedGatewayDetails) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, data)
        }</span> else<span class="cov4" title="4"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov4" title="4">return r0</span>
}

// MockgatewayModel_programGateway_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'programGateway'
type MockgatewayModel_programGateway_Call struct {
        *mock.Call
}

// programGateway is a helper method to define mock.On call
//   - ctx context.Context
//   - data *resolvedGatewayDetails
func (_e *MockgatewayModel_Expecter) programGateway(ctx interface{}, data interface{}) *MockgatewayModel_programGateway_Call <span class="cov4" title="4">{
        return &amp;MockgatewayModel_programGateway_Call{Call: _e.mock.On("programGateway", ctx, data)}
}</span>

func (_c *MockgatewayModel_programGateway_Call) Run(run func(ctx context.Context, data *resolvedGatewayDetails)) *MockgatewayModel_programGateway_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*resolvedGatewayDetails))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockgatewayModel_programGateway_Call) Return(_a0 error) *MockgatewayModel_programGateway_Call <span class="cov4" title="4">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockgatewayModel_programGateway_Call) RunAndReturn(run func(context.Context, *resolvedGatewayDetails) error) *MockgatewayModel_programGateway_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// resolveReconcileRequest provides a mock function with given fields: ctx, req, receiver
func (_m *MockgatewayModel) resolveReconcileRequest(ctx context.Context, req reconcile.Request, receiver *resolvedGatewayDetails) (bool, error) <span class="cov8" title="22">{
        ret := _m.Called(ctx, req, receiver)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for resolveReconcileRequest")</span>
        }

        <span class="cov8" title="22">var r0 bool
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, reconcile.Request, *resolvedGatewayDetails) (bool, error)); ok </span><span class="cov5" title="7">{
                return rf(ctx, req, receiver)
        }</span>
        <span class="cov7" title="15">if rf, ok := ret.Get(0).(func(context.Context, reconcile.Request, *resolvedGatewayDetails) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, req, receiver)
        }</span> else<span class="cov7" title="15"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov7" title="15">if rf, ok := ret.Get(1).(func(context.Context, reconcile.Request, *resolvedGatewayDetails) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, req, receiver)
        }</span> else<span class="cov7" title="15"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov7" title="15">return r0, r1</span>
}

// MockgatewayModel_resolveReconcileRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'resolveReconcileRequest'
type MockgatewayModel_resolveReconcileRequest_Call struct {
        *mock.Call
}

// resolveReconcileRequest is a helper method to define mock.On call
//   - ctx context.Context
//   - req reconcile.Request
//   - receiver *resolvedGatewayDetails
func (_e *MockgatewayModel_Expecter) resolveReconcileRequest(ctx interface{}, req interface{}, receiver interface{}) *MockgatewayModel_resolveReconcileRequest_Call <span class="cov8" title="21">{
        return &amp;MockgatewayModel_resolveReconcileRequest_Call{Call: _e.mock.On("resolveReconcileRequest", ctx, req, receiver)}
}</span>

func (_c *MockgatewayModel_resolveReconcileRequest_Call) Run(run func(ctx context.Context, req reconcile.Request, receiver *resolvedGatewayDetails)) *MockgatewayModel_resolveReconcileRequest_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(reconcile.Request), args[2].(*resolvedGatewayDetails))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockgatewayModel_resolveReconcileRequest_Call) Return(_a0 bool, _a1 error) *MockgatewayModel_resolveReconcileRequest_Call <span class="cov7" title="15">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockgatewayModel_resolveReconcileRequest_Call) RunAndReturn(run func(context.Context, reconcile.Request, *resolvedGatewayDetails) (bool, error)) *MockgatewayModel_resolveReconcileRequest_Call <span class="cov5" title="6">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockgatewayModel creates a new instance of MockgatewayModel. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockgatewayModel(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockgatewayModel <span class="cov10" title="37">{
        mock := &amp;MockgatewayModel{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="37">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="37">return mock</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package app

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
)

// MockhttpBackendModel is an autogenerated mock type for the httpBackendModel type
type MockhttpBackendModel struct {
        mock.Mock
}

type MockhttpBackendModel_Expecter struct {
        mock *mock.Mock
}

func (_m *MockhttpBackendModel) EXPECT() *MockhttpBackendModel_Expecter <span class="cov9" title="18">{
        return &amp;MockhttpBackendModel_Expecter{mock: &amp;_m.Mock}
}</span>

// identifyBackendsToUpdate provides a mock function with given fields: ctx, params
func (_m *MockhttpBackendModel) identifyBackendsToUpdate(ctx context.Context, params identifyBackendsToUpdateParams) (identifyBackendsToUpdateResult, error) <span class="cov2" title="2">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for identifyBackendsToUpdate")</span>
        }

        <span class="cov2" title="2">var r0 identifyBackendsToUpdateResult
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, identifyBackendsToUpdateParams) (identifyBackendsToUpdateResult, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov2" title="2">if rf, ok := ret.Get(0).(func(context.Context, identifyBackendsToUpdateParams) identifyBackendsToUpdateResult); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov2" title="2"> {
                r0 = ret.Get(0).(identifyBackendsToUpdateResult)
        }</span>

        <span class="cov2" title="2">if rf, ok := ret.Get(1).(func(context.Context, identifyBackendsToUpdateParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov2" title="2"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov2" title="2">return r0, r1</span>
}

// MockhttpBackendModel_identifyBackendsToUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'identifyBackendsToUpdate'
type MockhttpBackendModel_identifyBackendsToUpdate_Call struct {
        *mock.Call
}

// identifyBackendsToUpdate is a helper method to define mock.On call
//   - ctx context.Context
//   - params identifyBackendsToUpdateParams
func (_e *MockhttpBackendModel_Expecter) identifyBackendsToUpdate(ctx interface{}, params interface{}) *MockhttpBackendModel_identifyBackendsToUpdate_Call <span class="cov2" title="2">{
        return &amp;MockhttpBackendModel_identifyBackendsToUpdate_Call{Call: _e.mock.On("identifyBackendsToUpdate", ctx, params)}
}</span>

func (_c *MockhttpBackendModel_identifyBackendsToUpdate_Call) Run(run func(ctx context.Context, params identifyBackendsToUpdateParams)) *MockhttpBackendModel_identifyBackendsToUpdate_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(identifyBackendsToUpdateParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockhttpBackendModel_identifyBackendsToUpdate_Call) Return(_a0 identifyBackendsToUpdateResult, _a1 error) *MockhttpBackendModel_identifyBackendsToUpdate_Call <span class="cov2" title="2">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockhttpBackendModel_identifyBackendsToUpdate_Call) RunAndReturn(run func(context.Context, identifyBackendsToUpdateParams) (identifyBackendsToUpdateResult, error)) *MockhttpBackendModel_identifyBackendsToUpdate_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// syncRouteBackendRefEndpoints provides a mock function with given fields: ctx, params
func (_m *MockhttpBackendModel) syncRouteBackendRefEndpoints(ctx context.Context, params syncRouteBackendRefEndpointsParams) error <span class="cov8" title="13">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for syncRouteBackendRefEndpoints")</span>
        }

        <span class="cov8" title="13">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, syncRouteBackendRefEndpointsParams) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov8" title="13"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="13">return r0</span>
}

// MockhttpBackendModel_syncRouteBackendRefEndpoints_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'syncRouteBackendRefEndpoints'
type MockhttpBackendModel_syncRouteBackendRefEndpoints_Call struct {
        *mock.Call
}

// syncRouteBackendRefEndpoints is a helper method to define mock.On call
//   - ctx context.Context
//   - params syncRouteBackendRefEndpointsParams
func (_e *MockhttpBackendModel_Expecter) syncRouteBackendRefEndpoints(ctx interface{}, params interface{}) *MockhttpBackendModel_syncRouteBackendRefEndpoints_Call <span class="cov8" title="13">{
        return &amp;MockhttpBackendModel_syncRouteBackendRefEndpoints_Call{Call: _e.mock.On("syncRouteBackendRefEndpoints", ctx, params)}
}</span>

func (_c *MockhttpBackendModel_syncRouteBackendRefEndpoints_Call) Run(run func(ctx context.Context, params syncRouteBackendRefEndpointsParams)) *MockhttpBackendModel_syncRouteBackendRefEndpoints_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(syncRouteBackendRefEndpointsParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockhttpBackendModel_syncRouteBackendRefEndpoints_Call) Return(_a0 error) *MockhttpBackendModel_syncRouteBackendRefEndpoints_Call <span class="cov8" title="13">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockhttpBackendModel_syncRouteBackendRefEndpoints_Call) RunAndReturn(run func(context.Context, syncRouteBackendRefEndpointsParams) error) *MockhttpBackendModel_syncRouteBackendRefEndpoints_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// syncRouteEndpoints provides a mock function with given fields: ctx, params
func (_m *MockhttpBackendModel) syncRouteEndpoints(ctx context.Context, params syncRouteEndpointsParams) error <span class="cov4" title="3">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for syncRouteEndpoints")</span>
        }

        <span class="cov4" title="3">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, syncRouteEndpointsParams) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov4" title="3"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov4" title="3">return r0</span>
}

// MockhttpBackendModel_syncRouteEndpoints_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'syncRouteEndpoints'
type MockhttpBackendModel_syncRouteEndpoints_Call struct {
        *mock.Call
}

// syncRouteEndpoints is a helper method to define mock.On call
//   - ctx context.Context
//   - params syncRouteEndpointsParams
func (_e *MockhttpBackendModel_Expecter) syncRouteEndpoints(ctx interface{}, params interface{}) *MockhttpBackendModel_syncRouteEndpoints_Call <span class="cov4" title="3">{
        return &amp;MockhttpBackendModel_syncRouteEndpoints_Call{Call: _e.mock.On("syncRouteEndpoints", ctx, params)}
}</span>

func (_c *MockhttpBackendModel_syncRouteEndpoints_Call) Run(run func(ctx context.Context, params syncRouteEndpointsParams)) *MockhttpBackendModel_syncRouteEndpoints_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(syncRouteEndpointsParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockhttpBackendModel_syncRouteEndpoints_Call) Return(_a0 error) *MockhttpBackendModel_syncRouteEndpoints_Call <span class="cov4" title="3">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockhttpBackendModel_syncRouteEndpoints_Call) RunAndReturn(run func(context.Context, syncRouteEndpointsParams) error) *MockhttpBackendModel_syncRouteEndpoints_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockhttpBackendModel creates a new instance of MockhttpBackendModel. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockhttpBackendModel(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockhttpBackendModel <span class="cov10" title="24">{
        mock := &amp;MockhttpBackendModel{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="24">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="24">return mock</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package app

import (
        context "context"

        corev1 "k8s.io/api/core/v1"

        mock "github.com/stretchr/testify/mock"

        reconcile "sigs.k8s.io/controller-runtime/pkg/reconcile"

        types "k8s.io/apimachinery/pkg/types"

        v1 "sigs.k8s.io/gateway-api/apis/v1"
)

// MockhttpRouteModel is an autogenerated mock type for the httpRouteModel type
type MockhttpRouteModel struct {
        mock.Mock
}

type MockhttpRouteModel_Expecter struct {
        mock *mock.Mock
}

func (_m *MockhttpRouteModel) EXPECT() *MockhttpRouteModel_Expecter <span class="cov10" title="32">{
        return &amp;MockhttpRouteModel_Expecter{mock: &amp;_m.Mock}
}</span>

// acceptRoute provides a mock function with given fields: ctx, routeDetails
func (_m *MockhttpRouteModel) acceptRoute(ctx context.Context, routeDetails resolvedRouteDetails) (*v1.HTTPRoute, error) <span class="cov5" title="5">{
        ret := _m.Called(ctx, routeDetails)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for acceptRoute")</span>
        }

        <span class="cov5" title="5">var r0 *v1.HTTPRoute
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, resolvedRouteDetails) (*v1.HTTPRoute, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, routeDetails)
        }</span>
        <span class="cov5" title="5">if rf, ok := ret.Get(0).(func(context.Context, resolvedRouteDetails) *v1.HTTPRoute); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, routeDetails)
        }</span> else<span class="cov5" title="5"> {
                if ret.Get(0) != nil </span><span class="cov5" title="5">{
                        r0 = ret.Get(0).(*v1.HTTPRoute)
                }</span>
        }

        <span class="cov5" title="5">if rf, ok := ret.Get(1).(func(context.Context, resolvedRouteDetails) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, routeDetails)
        }</span> else<span class="cov5" title="5"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov5" title="5">return r0, r1</span>
}

// MockhttpRouteModel_acceptRoute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'acceptRoute'
type MockhttpRouteModel_acceptRoute_Call struct {
        *mock.Call
}

// acceptRoute is a helper method to define mock.On call
//   - ctx context.Context
//   - routeDetails resolvedRouteDetails
func (_e *MockhttpRouteModel_Expecter) acceptRoute(ctx interface{}, routeDetails interface{}) *MockhttpRouteModel_acceptRoute_Call <span class="cov5" title="5">{
        return &amp;MockhttpRouteModel_acceptRoute_Call{Call: _e.mock.On("acceptRoute", ctx, routeDetails)}
}</span>

func (_c *MockhttpRouteModel_acceptRoute_Call) Run(run func(ctx context.Context, routeDetails resolvedRouteDetails)) *MockhttpRouteModel_acceptRoute_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(resolvedRouteDetails))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockhttpRouteModel_acceptRoute_Call) Return(_a0 *v1.HTTPRoute, _a1 error) *MockhttpRouteModel_acceptRoute_Call <span class="cov5" title="5">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockhttpRouteModel_acceptRoute_Call) RunAndReturn(run func(context.Context, resolvedRouteDetails) (*v1.HTTPRoute, error)) *MockhttpRouteModel_acceptRoute_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// isProgrammingRequired provides a mock function with given fields: details
func (_m *MockhttpRouteModel) isProgrammingRequired(details resolvedRouteDetails) (bool, error) <span class="cov6" title="8">{
        ret := _m.Called(details)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for isProgrammingRequired")</span>
        }

        <span class="cov6" title="8">var r0 bool
        var r1 error
        if rf, ok := ret.Get(0).(func(resolvedRouteDetails) (bool, error)); ok </span><span class="cov0" title="0">{
                return rf(details)
        }</span>
        <span class="cov6" title="8">if rf, ok := ret.Get(0).(func(resolvedRouteDetails) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(details)
        }</span> else<span class="cov6" title="8"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov6" title="8">if rf, ok := ret.Get(1).(func(resolvedRouteDetails) error); ok </span><span class="cov0" title="0">{
                r1 = rf(details)
        }</span> else<span class="cov6" title="8"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov6" title="8">return r0, r1</span>
}

// MockhttpRouteModel_isProgrammingRequired_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'isProgrammingRequired'
type MockhttpRouteModel_isProgrammingRequired_Call struct {
        *mock.Call
}

// isProgrammingRequired is a helper method to define mock.On call
//   - details resolvedRouteDetails
func (_e *MockhttpRouteModel_Expecter) isProgrammingRequired(details interface{}) *MockhttpRouteModel_isProgrammingRequired_Call <span class="cov6" title="8">{
        return &amp;MockhttpRouteModel_isProgrammingRequired_Call{Call: _e.mock.On("isProgrammingRequired", details)}
}</span>

func (_c *MockhttpRouteModel_isProgrammingRequired_Call) Run(run func(details resolvedRouteDetails)) *MockhttpRouteModel_isProgrammingRequired_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(resolvedRouteDetails))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockhttpRouteModel_isProgrammingRequired_Call) Return(_a0 bool, _a1 error) *MockhttpRouteModel_isProgrammingRequired_Call <span class="cov6" title="8">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockhttpRouteModel_isProgrammingRequired_Call) RunAndReturn(run func(resolvedRouteDetails) (bool, error)) *MockhttpRouteModel_isProgrammingRequired_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// programRoute provides a mock function with given fields: ctx, params
func (_m *MockhttpRouteModel) programRoute(ctx context.Context, params programRouteParams) (programRouteResult, error) <span class="cov3" title="3">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for programRoute")</span>
        }

        <span class="cov3" title="3">var r0 programRouteResult
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, programRouteParams) (programRouteResult, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov3" title="3">if rf, ok := ret.Get(0).(func(context.Context, programRouteParams) programRouteResult); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                r0 = ret.Get(0).(programRouteResult)
        }</span>

        <span class="cov3" title="3">if rf, ok := ret.Get(1).(func(context.Context, programRouteParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov3" title="3">return r0, r1</span>
}

// MockhttpRouteModel_programRoute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'programRoute'
type MockhttpRouteModel_programRoute_Call struct {
        *mock.Call
}

// programRoute is a helper method to define mock.On call
//   - ctx context.Context
//   - params programRouteParams
func (_e *MockhttpRouteModel_Expecter) programRoute(ctx interface{}, params interface{}) *MockhttpRouteModel_programRoute_Call <span class="cov3" title="3">{
        return &amp;MockhttpRouteModel_programRoute_Call{Call: _e.mock.On("programRoute", ctx, params)}
}</span>

func (_c *MockhttpRouteModel_programRoute_Call) Run(run func(ctx context.Context, params programRouteParams)) *MockhttpRouteModel_programRoute_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(programRouteParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockhttpRouteModel_programRoute_Call) Return(_a0 programRouteResult, _a1 error) *MockhttpRouteModel_programRoute_Call <span class="cov3" title="3">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockhttpRouteModel_programRoute_Call) RunAndReturn(run func(context.Context, programRouteParams) (programRouteResult, error)) *MockhttpRouteModel_programRoute_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// resolveBackendRefs provides a mock function with given fields: ctx, params
func (_m *MockhttpRouteModel) resolveBackendRefs(ctx context.Context, params resolveBackendRefsParams) (map[string]corev1.Service, error) <span class="cov4" title="4">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for resolveBackendRefs")</span>
        }

        <span class="cov4" title="4">var r0 map[string]corev1.Service
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, resolveBackendRefsParams) (map[string]corev1.Service, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov4" title="4">if rf, ok := ret.Get(0).(func(context.Context, resolveBackendRefsParams) map[string]corev1.Service); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov4" title="4"> {
                if ret.Get(0) != nil </span><span class="cov4" title="4">{
                        r0 = ret.Get(0).(map[string]corev1.Service)
                }</span>
        }

        <span class="cov4" title="4">if rf, ok := ret.Get(1).(func(context.Context, resolveBackendRefsParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov4" title="4"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="4">return r0, r1</span>
}

// MockhttpRouteModel_resolveBackendRefs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'resolveBackendRefs'
type MockhttpRouteModel_resolveBackendRefs_Call struct {
        *mock.Call
}

// resolveBackendRefs is a helper method to define mock.On call
//   - ctx context.Context
//   - params resolveBackendRefsParams
func (_e *MockhttpRouteModel_Expecter) resolveBackendRefs(ctx interface{}, params interface{}) *MockhttpRouteModel_resolveBackendRefs_Call <span class="cov4" title="4">{
        return &amp;MockhttpRouteModel_resolveBackendRefs_Call{Call: _e.mock.On("resolveBackendRefs", ctx, params)}
}</span>

func (_c *MockhttpRouteModel_resolveBackendRefs_Call) Run(run func(ctx context.Context, params resolveBackendRefsParams)) *MockhttpRouteModel_resolveBackendRefs_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(resolveBackendRefsParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockhttpRouteModel_resolveBackendRefs_Call) Return(_a0 map[string]corev1.Service, _a1 error) *MockhttpRouteModel_resolveBackendRefs_Call <span class="cov4" title="4">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockhttpRouteModel_resolveBackendRefs_Call) RunAndReturn(run func(context.Context, resolveBackendRefsParams) (map[string]corev1.Service, error)) *MockhttpRouteModel_resolveBackendRefs_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// resolveRequest provides a mock function with given fields: ctx, req
func (_m *MockhttpRouteModel) resolveRequest(ctx context.Context, req reconcile.Request) (map[types.NamespacedName]resolvedRouteDetails, error) <span class="cov6" title="10">{
        ret := _m.Called(ctx, req)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for resolveRequest")</span>
        }

        <span class="cov6" title="10">var r0 map[types.NamespacedName]resolvedRouteDetails
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, reconcile.Request) (map[types.NamespacedName]resolvedRouteDetails, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, req)
        }</span>
        <span class="cov6" title="10">if rf, ok := ret.Get(0).(func(context.Context, reconcile.Request) map[types.NamespacedName]resolvedRouteDetails); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, req)
        }</span> else<span class="cov6" title="10"> {
                if ret.Get(0) != nil </span><span class="cov6" title="10">{
                        r0 = ret.Get(0).(map[types.NamespacedName]resolvedRouteDetails)
                }</span>
        }

        <span class="cov6" title="10">if rf, ok := ret.Get(1).(func(context.Context, reconcile.Request) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, req)
        }</span> else<span class="cov6" title="10"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov6" title="10">return r0, r1</span>
}

// MockhttpRouteModel_resolveRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'resolveRequest'
type MockhttpRouteModel_resolveRequest_Call struct {
        *mock.Call
}

// resolveRequest is a helper method to define mock.On call
//   - ctx context.Context
//   - req reconcile.Request
func (_e *MockhttpRouteModel_Expecter) resolveRequest(ctx interface{}, req interface{}) *MockhttpRouteModel_resolveRequest_Call <span class="cov6" title="10">{
        return &amp;MockhttpRouteModel_resolveRequest_Call{Call: _e.mock.On("resolveRequest", ctx, req)}
}</span>

func (_c *MockhttpRouteModel_resolveRequest_Call) Run(run func(ctx context.Context, req reconcile.Request)) *MockhttpRouteModel_resolveRequest_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(reconcile.Request))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockhttpRouteModel_resolveRequest_Call) Return(_a0 map[types.NamespacedName]resolvedRouteDetails, _a1 error) *MockhttpRouteModel_resolveRequest_Call <span class="cov6" title="10">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockhttpRouteModel_resolveRequest_Call) RunAndReturn(run func(context.Context, reconcile.Request) (map[types.NamespacedName]resolvedRouteDetails, error)) *MockhttpRouteModel_resolveRequest_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// setProgrammed provides a mock function with given fields: ctx, params
func (_m *MockhttpRouteModel) setProgrammed(ctx context.Context, params setProgrammedParams) error <span class="cov2" title="2">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for setProgrammed")</span>
        }

        <span class="cov2" title="2">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, setProgrammedParams) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov2" title="2"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov2" title="2">return r0</span>
}

// MockhttpRouteModel_setProgrammed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'setProgrammed'
type MockhttpRouteModel_setProgrammed_Call struct {
        *mock.Call
}

// setProgrammed is a helper method to define mock.On call
//   - ctx context.Context
//   - params setProgrammedParams
func (_e *MockhttpRouteModel_Expecter) setProgrammed(ctx interface{}, params interface{}) *MockhttpRouteModel_setProgrammed_Call <span class="cov2" title="2">{
        return &amp;MockhttpRouteModel_setProgrammed_Call{Call: _e.mock.On("setProgrammed", ctx, params)}
}</span>

func (_c *MockhttpRouteModel_setProgrammed_Call) Run(run func(ctx context.Context, params setProgrammedParams)) *MockhttpRouteModel_setProgrammed_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(setProgrammedParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockhttpRouteModel_setProgrammed_Call) Return(_a0 error) *MockhttpRouteModel_setProgrammed_Call <span class="cov2" title="2">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockhttpRouteModel_setProgrammed_Call) RunAndReturn(run func(context.Context, setProgrammedParams) error) *MockhttpRouteModel_setProgrammed_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockhttpRouteModel creates a new instance of MockhttpRouteModel. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockhttpRouteModel(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockhttpRouteModel <span class="cov6" title="10">{
        mock := &amp;MockhttpRouteModel{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov6" title="10">{ mock.AssertExpectations(t) }</span>)

        <span class="cov6" title="10">return mock</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package app

import (
        context "context"

        client "sigs.k8s.io/controller-runtime/pkg/client"

        mock "github.com/stretchr/testify/mock"

        types "k8s.io/apimachinery/pkg/types"
)

// Mockk8sClient is an autogenerated mock type for the k8sClient type
type Mockk8sClient struct {
        mock.Mock
}

type Mockk8sClient_Expecter struct {
        mock *mock.Mock
}

func (_m *Mockk8sClient) EXPECT() *Mockk8sClient_Expecter <span class="cov8" title="56">{
        return &amp;Mockk8sClient_Expecter{mock: &amp;_m.Mock}
}</span>

// Get provides a mock function with given fields: ctx, key, obj, opts
func (_m *Mockk8sClient) Get(ctx context.Context, key types.NamespacedName, obj client.Object, opts ...client.GetOption) error <span class="cov8" title="39">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov8" title="39">var _ca []interface{}
        _ca = append(_ca, ctx, key, obj)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Get")</span>
        }

        <span class="cov8" title="39">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, types.NamespacedName, client.Object, ...client.GetOption) error); ok </span><span class="cov7" title="32">{
                r0 = rf(ctx, key, obj, opts...)
        }</span> else<span class="cov4" title="7"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="39">return r0</span>
}

// Mockk8sClient_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type Mockk8sClient_Get_Call struct {
        *mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - key types.NamespacedName
//   - obj client.Object
//   - opts ...client.GetOption
func (_e *Mockk8sClient_Expecter) Get(ctx interface{}, key interface{}, obj interface{}, opts ...interface{}) *Mockk8sClient_Get_Call <span class="cov8" title="39">{
        return &amp;Mockk8sClient_Get_Call{Call: _e.mock.On("Get",
                append([]interface{}{ctx, key, obj}, opts...)...)}
}</span>

func (_c *Mockk8sClient_Get_Call) Run(run func(ctx context.Context, key types.NamespacedName, obj client.Object, opts ...client.GetOption)) *Mockk8sClient_Get_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]client.GetOption, len(args)-3)
                for i, a := range args[3:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(client.GetOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(types.NamespacedName), args[2].(client.Object), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *Mockk8sClient_Get_Call) Return(_a0 error) *Mockk8sClient_Get_Call <span class="cov4" title="7">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *Mockk8sClient_Get_Call) RunAndReturn(run func(context.Context, types.NamespacedName, client.Object, ...client.GetOption) error) *Mockk8sClient_Get_Call <span class="cov7" title="32">{
        _c.Call.Return(run)
        return _c
}</span>

// List provides a mock function with given fields: ctx, list, opts
func (_m *Mockk8sClient) List(ctx context.Context, list client.ObjectList, opts ...client.ListOption) error <span class="cov4" title="5">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov4" title="5">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov4" title="5">var _ca []interface{}
        _ca = append(_ca, ctx, list)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for List")</span>
        }

        <span class="cov4" title="5">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, client.ObjectList, ...client.ListOption) error); ok </span><span class="cov3" title="4">{
                r0 = rf(ctx, list, opts...)
        }</span> else<span class="cov1" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov4" title="5">return r0</span>
}

// Mockk8sClient_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type Mockk8sClient_List_Call struct {
        *mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - list client.ObjectList
//   - opts ...client.ListOption
func (_e *Mockk8sClient_Expecter) List(ctx interface{}, list interface{}, opts ...interface{}) *Mockk8sClient_List_Call <span class="cov4" title="5">{
        return &amp;Mockk8sClient_List_Call{Call: _e.mock.On("List",
                append([]interface{}{ctx, list}, opts...)...)}
}</span>

func (_c *Mockk8sClient_List_Call) Run(run func(ctx context.Context, list client.ObjectList, opts ...client.ListOption)) *Mockk8sClient_List_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]client.ListOption, len(args)-2)
                for i, a := range args[2:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(client.ListOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(client.ObjectList), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *Mockk8sClient_List_Call) Return(_a0 error) *Mockk8sClient_List_Call <span class="cov1" title="1">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *Mockk8sClient_List_Call) RunAndReturn(run func(context.Context, client.ObjectList, ...client.ListOption) error) *Mockk8sClient_List_Call <span class="cov3" title="4">{
        _c.Call.Return(run)
        return _c
}</span>

// Status provides a mock function with no fields
func (_m *Mockk8sClient) Status() client.SubResourceWriter <span class="cov5" title="8">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Status")</span>
        }

        <span class="cov5" title="8">var r0 client.SubResourceWriter
        if rf, ok := ret.Get(0).(func() client.SubResourceWriter); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov5" title="8"> {
                if ret.Get(0) != nil </span><span class="cov5" title="8">{
                        r0 = ret.Get(0).(client.SubResourceWriter)
                }</span>
        }

        <span class="cov5" title="8">return r0</span>
}

// Mockk8sClient_Status_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Status'
type Mockk8sClient_Status_Call struct {
        *mock.Call
}

// Status is a helper method to define mock.On call
func (_e *Mockk8sClient_Expecter) Status() *Mockk8sClient_Status_Call <span class="cov5" title="9">{
        return &amp;Mockk8sClient_Status_Call{Call: _e.mock.On("Status")}
}</span>

func (_c *Mockk8sClient_Status_Call) Run(run func()) *Mockk8sClient_Status_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *Mockk8sClient_Status_Call) Return(_a0 client.SubResourceWriter) *Mockk8sClient_Status_Call <span class="cov5" title="8">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *Mockk8sClient_Status_Call) RunAndReturn(run func() client.SubResourceWriter) *Mockk8sClient_Status_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Update provides a mock function with given fields: ctx, obj, opts
func (_m *Mockk8sClient) Update(ctx context.Context, obj client.Object, opts ...client.UpdateOption) error <span class="cov3" title="3">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov3" title="3">var _ca []interface{}
        _ca = append(_ca, ctx, obj)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Update")</span>
        }

        <span class="cov3" title="3">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, client.Object, ...client.UpdateOption) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, obj, opts...)
        }</span> else<span class="cov3" title="3"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov3" title="3">return r0</span>
}

// Mockk8sClient_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type Mockk8sClient_Update_Call struct {
        *mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - obj client.Object
//   - opts ...client.UpdateOption
func (_e *Mockk8sClient_Expecter) Update(ctx interface{}, obj interface{}, opts ...interface{}) *Mockk8sClient_Update_Call <span class="cov3" title="3">{
        return &amp;Mockk8sClient_Update_Call{Call: _e.mock.On("Update",
                append([]interface{}{ctx, obj}, opts...)...)}
}</span>

func (_c *Mockk8sClient_Update_Call) Run(run func(ctx context.Context, obj client.Object, opts ...client.UpdateOption)) *Mockk8sClient_Update_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]client.UpdateOption, len(args)-2)
                for i, a := range args[2:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(client.UpdateOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(client.Object), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *Mockk8sClient_Update_Call) Return(_a0 error) *Mockk8sClient_Update_Call <span class="cov3" title="3">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *Mockk8sClient_Update_Call) RunAndReturn(run func(context.Context, client.Object, ...client.UpdateOption) error) *Mockk8sClient_Update_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockk8sClient creates a new instance of Mockk8sClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockk8sClient(t interface {
        mock.TestingT
        Cleanup(func())
}) *Mockk8sClient <span class="cov10" title="94">{
        mock := &amp;Mockk8sClient{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="94">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="94">return mock</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package app

import (
        context "context"

        loadbalancer "github.com/oracle/oci-go-sdk/v65/loadbalancer"
        mock "github.com/stretchr/testify/mock"
)

// MockociLoadBalancerClient is an autogenerated mock type for the ociLoadBalancerClient type
type MockociLoadBalancerClient struct {
        mock.Mock
}

type MockociLoadBalancerClient_Expecter struct {
        mock *mock.Mock
}

func (_m *MockociLoadBalancerClient) EXPECT() *MockociLoadBalancerClient_Expecter <span class="cov9" title="44">{
        return &amp;MockociLoadBalancerClient_Expecter{mock: &amp;_m.Mock}
}</span>

// CreateBackend provides a mock function with given fields: ctx, request
func (_m *MockociLoadBalancerClient) CreateBackend(ctx context.Context, request loadbalancer.CreateBackendRequest) (loadbalancer.CreateBackendResponse, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, request)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateBackend")</span>
        }

        <span class="cov0" title="0">var r0 loadbalancer.CreateBackendResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.CreateBackendRequest) (loadbalancer.CreateBackendResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, request)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.CreateBackendRequest) loadbalancer.CreateBackendResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, request)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(loadbalancer.CreateBackendResponse)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, loadbalancer.CreateBackendRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, request)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockociLoadBalancerClient_CreateBackend_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBackend'
type MockociLoadBalancerClient_CreateBackend_Call struct {
        *mock.Call
}

// CreateBackend is a helper method to define mock.On call
//   - ctx context.Context
//   - request loadbalancer.CreateBackendRequest
func (_e *MockociLoadBalancerClient_Expecter) CreateBackend(ctx interface{}, request interface{}) *MockociLoadBalancerClient_CreateBackend_Call <span class="cov0" title="0">{
        return &amp;MockociLoadBalancerClient_CreateBackend_Call{Call: _e.mock.On("CreateBackend", ctx, request)}
}</span>

func (_c *MockociLoadBalancerClient_CreateBackend_Call) Run(run func(ctx context.Context, request loadbalancer.CreateBackendRequest)) *MockociLoadBalancerClient_CreateBackend_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(loadbalancer.CreateBackendRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerClient_CreateBackend_Call) Return(response loadbalancer.CreateBackendResponse, err error) *MockociLoadBalancerClient_CreateBackend_Call <span class="cov0" title="0">{
        _c.Call.Return(response, err)
        return _c
}</span>

func (_c *MockociLoadBalancerClient_CreateBackend_Call) RunAndReturn(run func(context.Context, loadbalancer.CreateBackendRequest) (loadbalancer.CreateBackendResponse, error)) *MockociLoadBalancerClient_CreateBackend_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// CreateBackendSet provides a mock function with given fields: ctx, request
func (_m *MockociLoadBalancerClient) CreateBackendSet(ctx context.Context, request loadbalancer.CreateBackendSetRequest) (loadbalancer.CreateBackendSetResponse, error) <span class="cov4" title="5">{
        ret := _m.Called(ctx, request)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateBackendSet")</span>
        }

        <span class="cov4" title="5">var r0 loadbalancer.CreateBackendSetResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.CreateBackendSetRequest) (loadbalancer.CreateBackendSetResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, request)
        }</span>
        <span class="cov4" title="5">if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.CreateBackendSetRequest) loadbalancer.CreateBackendSetResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, request)
        }</span> else<span class="cov4" title="5"> {
                r0 = ret.Get(0).(loadbalancer.CreateBackendSetResponse)
        }</span>

        <span class="cov4" title="5">if rf, ok := ret.Get(1).(func(context.Context, loadbalancer.CreateBackendSetRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, request)
        }</span> else<span class="cov4" title="5"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="5">return r0, r1</span>
}

// MockociLoadBalancerClient_CreateBackendSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBackendSet'
type MockociLoadBalancerClient_CreateBackendSet_Call struct {
        *mock.Call
}

// CreateBackendSet is a helper method to define mock.On call
//   - ctx context.Context
//   - request loadbalancer.CreateBackendSetRequest
func (_e *MockociLoadBalancerClient_Expecter) CreateBackendSet(ctx interface{}, request interface{}) *MockociLoadBalancerClient_CreateBackendSet_Call <span class="cov4" title="5">{
        return &amp;MockociLoadBalancerClient_CreateBackendSet_Call{Call: _e.mock.On("CreateBackendSet", ctx, request)}
}</span>

func (_c *MockociLoadBalancerClient_CreateBackendSet_Call) Run(run func(ctx context.Context, request loadbalancer.CreateBackendSetRequest)) *MockociLoadBalancerClient_CreateBackendSet_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(loadbalancer.CreateBackendSetRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerClient_CreateBackendSet_Call) Return(response loadbalancer.CreateBackendSetResponse, err error) *MockociLoadBalancerClient_CreateBackendSet_Call <span class="cov4" title="5">{
        _c.Call.Return(response, err)
        return _c
}</span>

func (_c *MockociLoadBalancerClient_CreateBackendSet_Call) RunAndReturn(run func(context.Context, loadbalancer.CreateBackendSetRequest) (loadbalancer.CreateBackendSetResponse, error)) *MockociLoadBalancerClient_CreateBackendSet_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// CreateHostname provides a mock function with given fields: ctx, request
func (_m *MockociLoadBalancerClient) CreateHostname(ctx context.Context, request loadbalancer.CreateHostnameRequest) (loadbalancer.CreateHostnameResponse, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, request)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateHostname")</span>
        }

        <span class="cov0" title="0">var r0 loadbalancer.CreateHostnameResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.CreateHostnameRequest) (loadbalancer.CreateHostnameResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, request)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.CreateHostnameRequest) loadbalancer.CreateHostnameResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, request)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(loadbalancer.CreateHostnameResponse)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, loadbalancer.CreateHostnameRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, request)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockociLoadBalancerClient_CreateHostname_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateHostname'
type MockociLoadBalancerClient_CreateHostname_Call struct {
        *mock.Call
}

// CreateHostname is a helper method to define mock.On call
//   - ctx context.Context
//   - request loadbalancer.CreateHostnameRequest
func (_e *MockociLoadBalancerClient_Expecter) CreateHostname(ctx interface{}, request interface{}) *MockociLoadBalancerClient_CreateHostname_Call <span class="cov0" title="0">{
        return &amp;MockociLoadBalancerClient_CreateHostname_Call{Call: _e.mock.On("CreateHostname", ctx, request)}
}</span>

func (_c *MockociLoadBalancerClient_CreateHostname_Call) Run(run func(ctx context.Context, request loadbalancer.CreateHostnameRequest)) *MockociLoadBalancerClient_CreateHostname_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(loadbalancer.CreateHostnameRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerClient_CreateHostname_Call) Return(response loadbalancer.CreateHostnameResponse, err error) *MockociLoadBalancerClient_CreateHostname_Call <span class="cov0" title="0">{
        _c.Call.Return(response, err)
        return _c
}</span>

func (_c *MockociLoadBalancerClient_CreateHostname_Call) RunAndReturn(run func(context.Context, loadbalancer.CreateHostnameRequest) (loadbalancer.CreateHostnameResponse, error)) *MockociLoadBalancerClient_CreateHostname_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// CreateListener provides a mock function with given fields: ctx, request
func (_m *MockociLoadBalancerClient) CreateListener(ctx context.Context, request loadbalancer.CreateListenerRequest) (loadbalancer.CreateListenerResponse, error) <span class="cov3" title="3">{
        ret := _m.Called(ctx, request)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateListener")</span>
        }

        <span class="cov3" title="3">var r0 loadbalancer.CreateListenerResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.CreateListenerRequest) (loadbalancer.CreateListenerResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, request)
        }</span>
        <span class="cov3" title="3">if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.CreateListenerRequest) loadbalancer.CreateListenerResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, request)
        }</span> else<span class="cov3" title="3"> {
                r0 = ret.Get(0).(loadbalancer.CreateListenerResponse)
        }</span>

        <span class="cov3" title="3">if rf, ok := ret.Get(1).(func(context.Context, loadbalancer.CreateListenerRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, request)
        }</span> else<span class="cov3" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov3" title="3">return r0, r1</span>
}

// MockociLoadBalancerClient_CreateListener_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateListener'
type MockociLoadBalancerClient_CreateListener_Call struct {
        *mock.Call
}

// CreateListener is a helper method to define mock.On call
//   - ctx context.Context
//   - request loadbalancer.CreateListenerRequest
func (_e *MockociLoadBalancerClient_Expecter) CreateListener(ctx interface{}, request interface{}) *MockociLoadBalancerClient_CreateListener_Call <span class="cov3" title="3">{
        return &amp;MockociLoadBalancerClient_CreateListener_Call{Call: _e.mock.On("CreateListener", ctx, request)}
}</span>

func (_c *MockociLoadBalancerClient_CreateListener_Call) Run(run func(ctx context.Context, request loadbalancer.CreateListenerRequest)) *MockociLoadBalancerClient_CreateListener_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(loadbalancer.CreateListenerRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerClient_CreateListener_Call) Return(response loadbalancer.CreateListenerResponse, err error) *MockociLoadBalancerClient_CreateListener_Call <span class="cov3" title="3">{
        _c.Call.Return(response, err)
        return _c
}</span>

func (_c *MockociLoadBalancerClient_CreateListener_Call) RunAndReturn(run func(context.Context, loadbalancer.CreateListenerRequest) (loadbalancer.CreateListenerResponse, error)) *MockociLoadBalancerClient_CreateListener_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// CreateRoutingPolicy provides a mock function with given fields: ctx, request
func (_m *MockociLoadBalancerClient) CreateRoutingPolicy(ctx context.Context, request loadbalancer.CreateRoutingPolicyRequest) (loadbalancer.CreateRoutingPolicyResponse, error) <span class="cov4" title="5">{
        ret := _m.Called(ctx, request)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateRoutingPolicy")</span>
        }

        <span class="cov4" title="5">var r0 loadbalancer.CreateRoutingPolicyResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.CreateRoutingPolicyRequest) (loadbalancer.CreateRoutingPolicyResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, request)
        }</span>
        <span class="cov4" title="5">if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.CreateRoutingPolicyRequest) loadbalancer.CreateRoutingPolicyResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, request)
        }</span> else<span class="cov4" title="5"> {
                r0 = ret.Get(0).(loadbalancer.CreateRoutingPolicyResponse)
        }</span>

        <span class="cov4" title="5">if rf, ok := ret.Get(1).(func(context.Context, loadbalancer.CreateRoutingPolicyRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, request)
        }</span> else<span class="cov4" title="5"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="5">return r0, r1</span>
}

// MockociLoadBalancerClient_CreateRoutingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRoutingPolicy'
type MockociLoadBalancerClient_CreateRoutingPolicy_Call struct {
        *mock.Call
}

// CreateRoutingPolicy is a helper method to define mock.On call
//   - ctx context.Context
//   - request loadbalancer.CreateRoutingPolicyRequest
func (_e *MockociLoadBalancerClient_Expecter) CreateRoutingPolicy(ctx interface{}, request interface{}) *MockociLoadBalancerClient_CreateRoutingPolicy_Call <span class="cov4" title="5">{
        return &amp;MockociLoadBalancerClient_CreateRoutingPolicy_Call{Call: _e.mock.On("CreateRoutingPolicy", ctx, request)}
}</span>

func (_c *MockociLoadBalancerClient_CreateRoutingPolicy_Call) Run(run func(ctx context.Context, request loadbalancer.CreateRoutingPolicyRequest)) *MockociLoadBalancerClient_CreateRoutingPolicy_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(loadbalancer.CreateRoutingPolicyRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerClient_CreateRoutingPolicy_Call) Return(response loadbalancer.CreateRoutingPolicyResponse, err error) *MockociLoadBalancerClient_CreateRoutingPolicy_Call <span class="cov4" title="5">{
        _c.Call.Return(response, err)
        return _c
}</span>

func (_c *MockociLoadBalancerClient_CreateRoutingPolicy_Call) RunAndReturn(run func(context.Context, loadbalancer.CreateRoutingPolicyRequest) (loadbalancer.CreateRoutingPolicyResponse, error)) *MockociLoadBalancerClient_CreateRoutingPolicy_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// DeleteListener provides a mock function with given fields: ctx, request
func (_m *MockociLoadBalancerClient) DeleteListener(ctx context.Context, request loadbalancer.DeleteListenerRequest) (loadbalancer.DeleteListenerResponse, error) <span class="cov5" title="9">{
        ret := _m.Called(ctx, request)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeleteListener")</span>
        }

        <span class="cov5" title="9">var r0 loadbalancer.DeleteListenerResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.DeleteListenerRequest) (loadbalancer.DeleteListenerResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, request)
        }</span>
        <span class="cov5" title="9">if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.DeleteListenerRequest) loadbalancer.DeleteListenerResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, request)
        }</span> else<span class="cov5" title="9"> {
                r0 = ret.Get(0).(loadbalancer.DeleteListenerResponse)
        }</span>

        <span class="cov5" title="9">if rf, ok := ret.Get(1).(func(context.Context, loadbalancer.DeleteListenerRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, request)
        }</span> else<span class="cov5" title="9"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov5" title="9">return r0, r1</span>
}

// MockociLoadBalancerClient_DeleteListener_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteListener'
type MockociLoadBalancerClient_DeleteListener_Call struct {
        *mock.Call
}

// DeleteListener is a helper method to define mock.On call
//   - ctx context.Context
//   - request loadbalancer.DeleteListenerRequest
func (_e *MockociLoadBalancerClient_Expecter) DeleteListener(ctx interface{}, request interface{}) *MockociLoadBalancerClient_DeleteListener_Call <span class="cov5" title="9">{
        return &amp;MockociLoadBalancerClient_DeleteListener_Call{Call: _e.mock.On("DeleteListener", ctx, request)}
}</span>

func (_c *MockociLoadBalancerClient_DeleteListener_Call) Run(run func(ctx context.Context, request loadbalancer.DeleteListenerRequest)) *MockociLoadBalancerClient_DeleteListener_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(loadbalancer.DeleteListenerRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerClient_DeleteListener_Call) Return(response loadbalancer.DeleteListenerResponse, err error) *MockociLoadBalancerClient_DeleteListener_Call <span class="cov5" title="9">{
        _c.Call.Return(response, err)
        return _c
}</span>

func (_c *MockociLoadBalancerClient_DeleteListener_Call) RunAndReturn(run func(context.Context, loadbalancer.DeleteListenerRequest) (loadbalancer.DeleteListenerResponse, error)) *MockociLoadBalancerClient_DeleteListener_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// DeleteRoutingPolicy provides a mock function with given fields: ctx, request
func (_m *MockociLoadBalancerClient) DeleteRoutingPolicy(ctx context.Context, request loadbalancer.DeleteRoutingPolicyRequest) (loadbalancer.DeleteRoutingPolicyResponse, error) <span class="cov2" title="2">{
        ret := _m.Called(ctx, request)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeleteRoutingPolicy")</span>
        }

        <span class="cov2" title="2">var r0 loadbalancer.DeleteRoutingPolicyResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.DeleteRoutingPolicyRequest) (loadbalancer.DeleteRoutingPolicyResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, request)
        }</span>
        <span class="cov2" title="2">if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.DeleteRoutingPolicyRequest) loadbalancer.DeleteRoutingPolicyResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, request)
        }</span> else<span class="cov2" title="2"> {
                r0 = ret.Get(0).(loadbalancer.DeleteRoutingPolicyResponse)
        }</span>

        <span class="cov2" title="2">if rf, ok := ret.Get(1).(func(context.Context, loadbalancer.DeleteRoutingPolicyRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, request)
        }</span> else<span class="cov2" title="2"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov2" title="2">return r0, r1</span>
}

// MockociLoadBalancerClient_DeleteRoutingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRoutingPolicy'
type MockociLoadBalancerClient_DeleteRoutingPolicy_Call struct {
        *mock.Call
}

// DeleteRoutingPolicy is a helper method to define mock.On call
//   - ctx context.Context
//   - request loadbalancer.DeleteRoutingPolicyRequest
func (_e *MockociLoadBalancerClient_Expecter) DeleteRoutingPolicy(ctx interface{}, request interface{}) *MockociLoadBalancerClient_DeleteRoutingPolicy_Call <span class="cov2" title="2">{
        return &amp;MockociLoadBalancerClient_DeleteRoutingPolicy_Call{Call: _e.mock.On("DeleteRoutingPolicy", ctx, request)}
}</span>

func (_c *MockociLoadBalancerClient_DeleteRoutingPolicy_Call) Run(run func(ctx context.Context, request loadbalancer.DeleteRoutingPolicyRequest)) *MockociLoadBalancerClient_DeleteRoutingPolicy_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(loadbalancer.DeleteRoutingPolicyRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerClient_DeleteRoutingPolicy_Call) Return(response loadbalancer.DeleteRoutingPolicyResponse, err error) *MockociLoadBalancerClient_DeleteRoutingPolicy_Call <span class="cov2" title="2">{
        _c.Call.Return(response, err)
        return _c
}</span>

func (_c *MockociLoadBalancerClient_DeleteRoutingPolicy_Call) RunAndReturn(run func(context.Context, loadbalancer.DeleteRoutingPolicyRequest) (loadbalancer.DeleteRoutingPolicyResponse, error)) *MockociLoadBalancerClient_DeleteRoutingPolicy_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetBackendSet provides a mock function with given fields: ctx, request
func (_m *MockociLoadBalancerClient) GetBackendSet(ctx context.Context, request loadbalancer.GetBackendSetRequest) (loadbalancer.GetBackendSetResponse, error) <span class="cov5" title="6">{
        ret := _m.Called(ctx, request)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetBackendSet")</span>
        }

        <span class="cov5" title="6">var r0 loadbalancer.GetBackendSetResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.GetBackendSetRequest) (loadbalancer.GetBackendSetResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, request)
        }</span>
        <span class="cov5" title="6">if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.GetBackendSetRequest) loadbalancer.GetBackendSetResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, request)
        }</span> else<span class="cov5" title="6"> {
                r0 = ret.Get(0).(loadbalancer.GetBackendSetResponse)
        }</span>

        <span class="cov5" title="6">if rf, ok := ret.Get(1).(func(context.Context, loadbalancer.GetBackendSetRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, request)
        }</span> else<span class="cov5" title="6"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov5" title="6">return r0, r1</span>
}

// MockociLoadBalancerClient_GetBackendSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBackendSet'
type MockociLoadBalancerClient_GetBackendSet_Call struct {
        *mock.Call
}

// GetBackendSet is a helper method to define mock.On call
//   - ctx context.Context
//   - request loadbalancer.GetBackendSetRequest
func (_e *MockociLoadBalancerClient_Expecter) GetBackendSet(ctx interface{}, request interface{}) *MockociLoadBalancerClient_GetBackendSet_Call <span class="cov5" title="6">{
        return &amp;MockociLoadBalancerClient_GetBackendSet_Call{Call: _e.mock.On("GetBackendSet", ctx, request)}
}</span>

func (_c *MockociLoadBalancerClient_GetBackendSet_Call) Run(run func(ctx context.Context, request loadbalancer.GetBackendSetRequest)) *MockociLoadBalancerClient_GetBackendSet_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(loadbalancer.GetBackendSetRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerClient_GetBackendSet_Call) Return(response loadbalancer.GetBackendSetResponse, err error) *MockociLoadBalancerClient_GetBackendSet_Call <span class="cov5" title="6">{
        _c.Call.Return(response, err)
        return _c
}</span>

func (_c *MockociLoadBalancerClient_GetBackendSet_Call) RunAndReturn(run func(context.Context, loadbalancer.GetBackendSetRequest) (loadbalancer.GetBackendSetResponse, error)) *MockociLoadBalancerClient_GetBackendSet_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetHostname provides a mock function with given fields: ctx, request
func (_m *MockociLoadBalancerClient) GetHostname(ctx context.Context, request loadbalancer.GetHostnameRequest) (loadbalancer.GetHostnameResponse, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, request)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetHostname")</span>
        }

        <span class="cov0" title="0">var r0 loadbalancer.GetHostnameResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.GetHostnameRequest) (loadbalancer.GetHostnameResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, request)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.GetHostnameRequest) loadbalancer.GetHostnameResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, request)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(loadbalancer.GetHostnameResponse)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, loadbalancer.GetHostnameRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, request)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockociLoadBalancerClient_GetHostname_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHostname'
type MockociLoadBalancerClient_GetHostname_Call struct {
        *mock.Call
}

// GetHostname is a helper method to define mock.On call
//   - ctx context.Context
//   - request loadbalancer.GetHostnameRequest
func (_e *MockociLoadBalancerClient_Expecter) GetHostname(ctx interface{}, request interface{}) *MockociLoadBalancerClient_GetHostname_Call <span class="cov0" title="0">{
        return &amp;MockociLoadBalancerClient_GetHostname_Call{Call: _e.mock.On("GetHostname", ctx, request)}
}</span>

func (_c *MockociLoadBalancerClient_GetHostname_Call) Run(run func(ctx context.Context, request loadbalancer.GetHostnameRequest)) *MockociLoadBalancerClient_GetHostname_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(loadbalancer.GetHostnameRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerClient_GetHostname_Call) Return(response loadbalancer.GetHostnameResponse, err error) *MockociLoadBalancerClient_GetHostname_Call <span class="cov0" title="0">{
        _c.Call.Return(response, err)
        return _c
}</span>

func (_c *MockociLoadBalancerClient_GetHostname_Call) RunAndReturn(run func(context.Context, loadbalancer.GetHostnameRequest) (loadbalancer.GetHostnameResponse, error)) *MockociLoadBalancerClient_GetHostname_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetLoadBalancer provides a mock function with given fields: ctx, request
func (_m *MockociLoadBalancerClient) GetLoadBalancer(ctx context.Context, request loadbalancer.GetLoadBalancerRequest) (loadbalancer.GetLoadBalancerResponse, error) <span class="cov4" title="4">{
        ret := _m.Called(ctx, request)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetLoadBalancer")</span>
        }

        <span class="cov4" title="4">var r0 loadbalancer.GetLoadBalancerResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.GetLoadBalancerRequest) (loadbalancer.GetLoadBalancerResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, request)
        }</span>
        <span class="cov4" title="4">if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.GetLoadBalancerRequest) loadbalancer.GetLoadBalancerResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, request)
        }</span> else<span class="cov4" title="4"> {
                r0 = ret.Get(0).(loadbalancer.GetLoadBalancerResponse)
        }</span>

        <span class="cov4" title="4">if rf, ok := ret.Get(1).(func(context.Context, loadbalancer.GetLoadBalancerRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, request)
        }</span> else<span class="cov4" title="4"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="4">return r0, r1</span>
}

// MockociLoadBalancerClient_GetLoadBalancer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLoadBalancer'
type MockociLoadBalancerClient_GetLoadBalancer_Call struct {
        *mock.Call
}

// GetLoadBalancer is a helper method to define mock.On call
//   - ctx context.Context
//   - request loadbalancer.GetLoadBalancerRequest
func (_e *MockociLoadBalancerClient_Expecter) GetLoadBalancer(ctx interface{}, request interface{}) *MockociLoadBalancerClient_GetLoadBalancer_Call <span class="cov4" title="4">{
        return &amp;MockociLoadBalancerClient_GetLoadBalancer_Call{Call: _e.mock.On("GetLoadBalancer", ctx, request)}
}</span>

func (_c *MockociLoadBalancerClient_GetLoadBalancer_Call) Run(run func(ctx context.Context, request loadbalancer.GetLoadBalancerRequest)) *MockociLoadBalancerClient_GetLoadBalancer_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(loadbalancer.GetLoadBalancerRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerClient_GetLoadBalancer_Call) Return(response loadbalancer.GetLoadBalancerResponse, err error) *MockociLoadBalancerClient_GetLoadBalancer_Call <span class="cov4" title="4">{
        _c.Call.Return(response, err)
        return _c
}</span>

func (_c *MockociLoadBalancerClient_GetLoadBalancer_Call) RunAndReturn(run func(context.Context, loadbalancer.GetLoadBalancerRequest) (loadbalancer.GetLoadBalancerResponse, error)) *MockociLoadBalancerClient_GetLoadBalancer_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetRoutingPolicy provides a mock function with given fields: ctx, request
func (_m *MockociLoadBalancerClient) GetRoutingPolicy(ctx context.Context, request loadbalancer.GetRoutingPolicyRequest) (loadbalancer.GetRoutingPolicyResponse, error) <span class="cov4" title="5">{
        ret := _m.Called(ctx, request)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetRoutingPolicy")</span>
        }

        <span class="cov4" title="5">var r0 loadbalancer.GetRoutingPolicyResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.GetRoutingPolicyRequest) (loadbalancer.GetRoutingPolicyResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, request)
        }</span>
        <span class="cov4" title="5">if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.GetRoutingPolicyRequest) loadbalancer.GetRoutingPolicyResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, request)
        }</span> else<span class="cov4" title="5"> {
                r0 = ret.Get(0).(loadbalancer.GetRoutingPolicyResponse)
        }</span>

        <span class="cov4" title="5">if rf, ok := ret.Get(1).(func(context.Context, loadbalancer.GetRoutingPolicyRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, request)
        }</span> else<span class="cov4" title="5"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="5">return r0, r1</span>
}

// MockociLoadBalancerClient_GetRoutingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRoutingPolicy'
type MockociLoadBalancerClient_GetRoutingPolicy_Call struct {
        *mock.Call
}

// GetRoutingPolicy is a helper method to define mock.On call
//   - ctx context.Context
//   - request loadbalancer.GetRoutingPolicyRequest
func (_e *MockociLoadBalancerClient_Expecter) GetRoutingPolicy(ctx interface{}, request interface{}) *MockociLoadBalancerClient_GetRoutingPolicy_Call <span class="cov4" title="5">{
        return &amp;MockociLoadBalancerClient_GetRoutingPolicy_Call{Call: _e.mock.On("GetRoutingPolicy", ctx, request)}
}</span>

func (_c *MockociLoadBalancerClient_GetRoutingPolicy_Call) Run(run func(ctx context.Context, request loadbalancer.GetRoutingPolicyRequest)) *MockociLoadBalancerClient_GetRoutingPolicy_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(loadbalancer.GetRoutingPolicyRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerClient_GetRoutingPolicy_Call) Return(response loadbalancer.GetRoutingPolicyResponse, err error) *MockociLoadBalancerClient_GetRoutingPolicy_Call <span class="cov4" title="5">{
        _c.Call.Return(response, err)
        return _c
}</span>

func (_c *MockociLoadBalancerClient_GetRoutingPolicy_Call) RunAndReturn(run func(context.Context, loadbalancer.GetRoutingPolicyRequest) (loadbalancer.GetRoutingPolicyResponse, error)) *MockociLoadBalancerClient_GetRoutingPolicy_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetRuleSet provides a mock function with given fields: ctx, request
func (_m *MockociLoadBalancerClient) GetRuleSet(ctx context.Context, request loadbalancer.GetRuleSetRequest) (loadbalancer.GetRuleSetResponse, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, request)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetRuleSet")</span>
        }

        <span class="cov0" title="0">var r0 loadbalancer.GetRuleSetResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.GetRuleSetRequest) (loadbalancer.GetRuleSetResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, request)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.GetRuleSetRequest) loadbalancer.GetRuleSetResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, request)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(loadbalancer.GetRuleSetResponse)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, loadbalancer.GetRuleSetRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, request)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockociLoadBalancerClient_GetRuleSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRuleSet'
type MockociLoadBalancerClient_GetRuleSet_Call struct {
        *mock.Call
}

// GetRuleSet is a helper method to define mock.On call
//   - ctx context.Context
//   - request loadbalancer.GetRuleSetRequest
func (_e *MockociLoadBalancerClient_Expecter) GetRuleSet(ctx interface{}, request interface{}) *MockociLoadBalancerClient_GetRuleSet_Call <span class="cov0" title="0">{
        return &amp;MockociLoadBalancerClient_GetRuleSet_Call{Call: _e.mock.On("GetRuleSet", ctx, request)}
}</span>

func (_c *MockociLoadBalancerClient_GetRuleSet_Call) Run(run func(ctx context.Context, request loadbalancer.GetRuleSetRequest)) *MockociLoadBalancerClient_GetRuleSet_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(loadbalancer.GetRuleSetRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerClient_GetRuleSet_Call) Return(response loadbalancer.GetRuleSetResponse, err error) *MockociLoadBalancerClient_GetRuleSet_Call <span class="cov0" title="0">{
        _c.Call.Return(response, err)
        return _c
}</span>

func (_c *MockociLoadBalancerClient_GetRuleSet_Call) RunAndReturn(run func(context.Context, loadbalancer.GetRuleSetRequest) (loadbalancer.GetRuleSetResponse, error)) *MockociLoadBalancerClient_GetRuleSet_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// UpdateBackendSet provides a mock function with given fields: ctx, request
func (_m *MockociLoadBalancerClient) UpdateBackendSet(ctx context.Context, request loadbalancer.UpdateBackendSetRequest) (loadbalancer.UpdateBackendSetResponse, error) <span class="cov1" title="1">{
        ret := _m.Called(ctx, request)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateBackendSet")</span>
        }

        <span class="cov1" title="1">var r0 loadbalancer.UpdateBackendSetResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.UpdateBackendSetRequest) (loadbalancer.UpdateBackendSetResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, request)
        }</span>
        <span class="cov1" title="1">if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.UpdateBackendSetRequest) loadbalancer.UpdateBackendSetResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, request)
        }</span> else<span class="cov1" title="1"> {
                r0 = ret.Get(0).(loadbalancer.UpdateBackendSetResponse)
        }</span>

        <span class="cov1" title="1">if rf, ok := ret.Get(1).(func(context.Context, loadbalancer.UpdateBackendSetRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, request)
        }</span> else<span class="cov1" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov1" title="1">return r0, r1</span>
}

// MockociLoadBalancerClient_UpdateBackendSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateBackendSet'
type MockociLoadBalancerClient_UpdateBackendSet_Call struct {
        *mock.Call
}

// UpdateBackendSet is a helper method to define mock.On call
//   - ctx context.Context
//   - request loadbalancer.UpdateBackendSetRequest
func (_e *MockociLoadBalancerClient_Expecter) UpdateBackendSet(ctx interface{}, request interface{}) *MockociLoadBalancerClient_UpdateBackendSet_Call <span class="cov1" title="1">{
        return &amp;MockociLoadBalancerClient_UpdateBackendSet_Call{Call: _e.mock.On("UpdateBackendSet", ctx, request)}
}</span>

func (_c *MockociLoadBalancerClient_UpdateBackendSet_Call) Run(run func(ctx context.Context, request loadbalancer.UpdateBackendSetRequest)) *MockociLoadBalancerClient_UpdateBackendSet_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(loadbalancer.UpdateBackendSetRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerClient_UpdateBackendSet_Call) Return(response loadbalancer.UpdateBackendSetResponse, err error) *MockociLoadBalancerClient_UpdateBackendSet_Call <span class="cov1" title="1">{
        _c.Call.Return(response, err)
        return _c
}</span>

func (_c *MockociLoadBalancerClient_UpdateBackendSet_Call) RunAndReturn(run func(context.Context, loadbalancer.UpdateBackendSetRequest) (loadbalancer.UpdateBackendSetResponse, error)) *MockociLoadBalancerClient_UpdateBackendSet_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// UpdateRoutingPolicy provides a mock function with given fields: ctx, request
func (_m *MockociLoadBalancerClient) UpdateRoutingPolicy(ctx context.Context, request loadbalancer.UpdateRoutingPolicyRequest) (loadbalancer.UpdateRoutingPolicyResponse, error) <span class="cov4" title="4">{
        ret := _m.Called(ctx, request)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateRoutingPolicy")</span>
        }

        <span class="cov4" title="4">var r0 loadbalancer.UpdateRoutingPolicyResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.UpdateRoutingPolicyRequest) (loadbalancer.UpdateRoutingPolicyResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, request)
        }</span>
        <span class="cov4" title="4">if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.UpdateRoutingPolicyRequest) loadbalancer.UpdateRoutingPolicyResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, request)
        }</span> else<span class="cov4" title="4"> {
                r0 = ret.Get(0).(loadbalancer.UpdateRoutingPolicyResponse)
        }</span>

        <span class="cov4" title="4">if rf, ok := ret.Get(1).(func(context.Context, loadbalancer.UpdateRoutingPolicyRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, request)
        }</span> else<span class="cov4" title="4"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="4">return r0, r1</span>
}

// MockociLoadBalancerClient_UpdateRoutingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRoutingPolicy'
type MockociLoadBalancerClient_UpdateRoutingPolicy_Call struct {
        *mock.Call
}

// UpdateRoutingPolicy is a helper method to define mock.On call
//   - ctx context.Context
//   - request loadbalancer.UpdateRoutingPolicyRequest
func (_e *MockociLoadBalancerClient_Expecter) UpdateRoutingPolicy(ctx interface{}, request interface{}) *MockociLoadBalancerClient_UpdateRoutingPolicy_Call <span class="cov4" title="4">{
        return &amp;MockociLoadBalancerClient_UpdateRoutingPolicy_Call{Call: _e.mock.On("UpdateRoutingPolicy", ctx, request)}
}</span>

func (_c *MockociLoadBalancerClient_UpdateRoutingPolicy_Call) Run(run func(ctx context.Context, request loadbalancer.UpdateRoutingPolicyRequest)) *MockociLoadBalancerClient_UpdateRoutingPolicy_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(loadbalancer.UpdateRoutingPolicyRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerClient_UpdateRoutingPolicy_Call) Return(response loadbalancer.UpdateRoutingPolicyResponse, err error) *MockociLoadBalancerClient_UpdateRoutingPolicy_Call <span class="cov4" title="4">{
        _c.Call.Return(response, err)
        return _c
}</span>

func (_c *MockociLoadBalancerClient_UpdateRoutingPolicy_Call) RunAndReturn(run func(context.Context, loadbalancer.UpdateRoutingPolicyRequest) (loadbalancer.UpdateRoutingPolicyResponse, error)) *MockociLoadBalancerClient_UpdateRoutingPolicy_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// UpdateRuleSet provides a mock function with given fields: ctx, request
func (_m *MockociLoadBalancerClient) UpdateRuleSet(ctx context.Context, request loadbalancer.UpdateRuleSetRequest) (loadbalancer.UpdateRuleSetResponse, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, request)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateRuleSet")</span>
        }

        <span class="cov0" title="0">var r0 loadbalancer.UpdateRuleSetResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.UpdateRuleSetRequest) (loadbalancer.UpdateRuleSetResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, request)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.UpdateRuleSetRequest) loadbalancer.UpdateRuleSetResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, request)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(loadbalancer.UpdateRuleSetResponse)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, loadbalancer.UpdateRuleSetRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, request)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockociLoadBalancerClient_UpdateRuleSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRuleSet'
type MockociLoadBalancerClient_UpdateRuleSet_Call struct {
        *mock.Call
}

// UpdateRuleSet is a helper method to define mock.On call
//   - ctx context.Context
//   - request loadbalancer.UpdateRuleSetRequest
func (_e *MockociLoadBalancerClient_Expecter) UpdateRuleSet(ctx interface{}, request interface{}) *MockociLoadBalancerClient_UpdateRuleSet_Call <span class="cov0" title="0">{
        return &amp;MockociLoadBalancerClient_UpdateRuleSet_Call{Call: _e.mock.On("UpdateRuleSet", ctx, request)}
}</span>

func (_c *MockociLoadBalancerClient_UpdateRuleSet_Call) Run(run func(ctx context.Context, request loadbalancer.UpdateRuleSetRequest)) *MockociLoadBalancerClient_UpdateRuleSet_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(loadbalancer.UpdateRuleSetRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerClient_UpdateRuleSet_Call) Return(response loadbalancer.UpdateRuleSetResponse, err error) *MockociLoadBalancerClient_UpdateRuleSet_Call <span class="cov0" title="0">{
        _c.Call.Return(response, err)
        return _c
}</span>

func (_c *MockociLoadBalancerClient_UpdateRuleSet_Call) RunAndReturn(run func(context.Context, loadbalancer.UpdateRuleSetRequest) (loadbalancer.UpdateRuleSetResponse, error)) *MockociLoadBalancerClient_UpdateRuleSet_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockociLoadBalancerClient creates a new instance of MockociLoadBalancerClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockociLoadBalancerClient(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockociLoadBalancerClient <span class="cov10" title="53">{
        mock := &amp;MockociLoadBalancerClient{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="53">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="53">return mock</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package app

import (
        context "context"

        loadbalancer "github.com/oracle/oci-go-sdk/v65/loadbalancer"
        mock "github.com/stretchr/testify/mock"
)

// MockociLoadBalancerModel is an autogenerated mock type for the ociLoadBalancerModel type
type MockociLoadBalancerModel struct {
        mock.Mock
}

type MockociLoadBalancerModel_Expecter struct {
        mock *mock.Mock
}

func (_m *MockociLoadBalancerModel) EXPECT() *MockociLoadBalancerModel_Expecter <span class="cov9" title="32">{
        return &amp;MockociLoadBalancerModel_Expecter{mock: &amp;_m.Mock}
}</span>

// commitRoutingPolicy provides a mock function with given fields: ctx, params
func (_m *MockociLoadBalancerModel) commitRoutingPolicy(ctx context.Context, params commitRoutingPolicyParams) error <span class="cov6" title="8">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for commitRoutingPolicy")</span>
        }

        <span class="cov6" title="8">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, commitRoutingPolicyParams) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov6" title="8"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov6" title="8">return r0</span>
}

// MockociLoadBalancerModel_commitRoutingPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'commitRoutingPolicy'
type MockociLoadBalancerModel_commitRoutingPolicy_Call struct {
        *mock.Call
}

// commitRoutingPolicy is a helper method to define mock.On call
//   - ctx context.Context
//   - params commitRoutingPolicyParams
func (_e *MockociLoadBalancerModel_Expecter) commitRoutingPolicy(ctx interface{}, params interface{}) *MockociLoadBalancerModel_commitRoutingPolicy_Call <span class="cov6" title="8">{
        return &amp;MockociLoadBalancerModel_commitRoutingPolicy_Call{Call: _e.mock.On("commitRoutingPolicy", ctx, params)}
}</span>

func (_c *MockociLoadBalancerModel_commitRoutingPolicy_Call) Run(run func(ctx context.Context, params commitRoutingPolicyParams)) *MockociLoadBalancerModel_commitRoutingPolicy_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(commitRoutingPolicyParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerModel_commitRoutingPolicy_Call) Return(_a0 error) *MockociLoadBalancerModel_commitRoutingPolicy_Call <span class="cov6" title="8">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockociLoadBalancerModel_commitRoutingPolicy_Call) RunAndReturn(run func(context.Context, commitRoutingPolicyParams) error) *MockociLoadBalancerModel_commitRoutingPolicy_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// makeRoutingRule provides a mock function with given fields: ctx, params
func (_m *MockociLoadBalancerModel) makeRoutingRule(ctx context.Context, params makeRoutingRuleParams) (loadbalancer.RoutingRule, error) <span class="cov5" title="6">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for makeRoutingRule")</span>
        }

        <span class="cov5" title="6">var r0 loadbalancer.RoutingRule
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, makeRoutingRuleParams) (loadbalancer.RoutingRule, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov5" title="6">if rf, ok := ret.Get(0).(func(context.Context, makeRoutingRuleParams) loadbalancer.RoutingRule); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov5" title="6"> {
                r0 = ret.Get(0).(loadbalancer.RoutingRule)
        }</span>

        <span class="cov5" title="6">if rf, ok := ret.Get(1).(func(context.Context, makeRoutingRuleParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov5" title="6"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov5" title="6">return r0, r1</span>
}

// MockociLoadBalancerModel_makeRoutingRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'makeRoutingRule'
type MockociLoadBalancerModel_makeRoutingRule_Call struct {
        *mock.Call
}

// makeRoutingRule is a helper method to define mock.On call
//   - ctx context.Context
//   - params makeRoutingRuleParams
func (_e *MockociLoadBalancerModel_Expecter) makeRoutingRule(ctx interface{}, params interface{}) *MockociLoadBalancerModel_makeRoutingRule_Call <span class="cov5" title="6">{
        return &amp;MockociLoadBalancerModel_makeRoutingRule_Call{Call: _e.mock.On("makeRoutingRule", ctx, params)}
}</span>

func (_c *MockociLoadBalancerModel_makeRoutingRule_Call) Run(run func(ctx context.Context, params makeRoutingRuleParams)) *MockociLoadBalancerModel_makeRoutingRule_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(makeRoutingRuleParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerModel_makeRoutingRule_Call) Return(_a0 loadbalancer.RoutingRule, _a1 error) *MockociLoadBalancerModel_makeRoutingRule_Call <span class="cov5" title="6">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockociLoadBalancerModel_makeRoutingRule_Call) RunAndReturn(run func(context.Context, makeRoutingRuleParams) (loadbalancer.RoutingRule, error)) *MockociLoadBalancerModel_makeRoutingRule_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// reconcileBackendSet provides a mock function with given fields: ctx, params
func (_m *MockociLoadBalancerModel) reconcileBackendSet(ctx context.Context, params reconcileBackendSetParams) error <span class="cov6" title="9">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for reconcileBackendSet")</span>
        }

        <span class="cov6" title="9">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, reconcileBackendSetParams) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov6" title="9"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov6" title="9">return r0</span>
}

// MockociLoadBalancerModel_reconcileBackendSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'reconcileBackendSet'
type MockociLoadBalancerModel_reconcileBackendSet_Call struct {
        *mock.Call
}

// reconcileBackendSet is a helper method to define mock.On call
//   - ctx context.Context
//   - params reconcileBackendSetParams
func (_e *MockociLoadBalancerModel_Expecter) reconcileBackendSet(ctx interface{}, params interface{}) *MockociLoadBalancerModel_reconcileBackendSet_Call <span class="cov6" title="9">{
        return &amp;MockociLoadBalancerModel_reconcileBackendSet_Call{Call: _e.mock.On("reconcileBackendSet", ctx, params)}
}</span>

func (_c *MockociLoadBalancerModel_reconcileBackendSet_Call) Run(run func(ctx context.Context, params reconcileBackendSetParams)) *MockociLoadBalancerModel_reconcileBackendSet_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(reconcileBackendSetParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerModel_reconcileBackendSet_Call) Return(_a0 error) *MockociLoadBalancerModel_reconcileBackendSet_Call <span class="cov6" title="9">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockociLoadBalancerModel_reconcileBackendSet_Call) RunAndReturn(run func(context.Context, reconcileBackendSetParams) error) *MockociLoadBalancerModel_reconcileBackendSet_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// reconcileDefaultBackendSet provides a mock function with given fields: ctx, params
func (_m *MockociLoadBalancerModel) reconcileDefaultBackendSet(ctx context.Context, params reconcileDefaultBackendParams) (loadbalancer.BackendSet, error) <span class="cov3" title="3">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for reconcileDefaultBackendSet")</span>
        }

        <span class="cov3" title="3">var r0 loadbalancer.BackendSet
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, reconcileDefaultBackendParams) (loadbalancer.BackendSet, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov3" title="3">if rf, ok := ret.Get(0).(func(context.Context, reconcileDefaultBackendParams) loadbalancer.BackendSet); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                r0 = ret.Get(0).(loadbalancer.BackendSet)
        }</span>

        <span class="cov3" title="3">if rf, ok := ret.Get(1).(func(context.Context, reconcileDefaultBackendParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov3" title="3">return r0, r1</span>
}

// MockociLoadBalancerModel_reconcileDefaultBackendSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'reconcileDefaultBackendSet'
type MockociLoadBalancerModel_reconcileDefaultBackendSet_Call struct {
        *mock.Call
}

// reconcileDefaultBackendSet is a helper method to define mock.On call
//   - ctx context.Context
//   - params reconcileDefaultBackendParams
func (_e *MockociLoadBalancerModel_Expecter) reconcileDefaultBackendSet(ctx interface{}, params interface{}) *MockociLoadBalancerModel_reconcileDefaultBackendSet_Call <span class="cov3" title="3">{
        return &amp;MockociLoadBalancerModel_reconcileDefaultBackendSet_Call{Call: _e.mock.On("reconcileDefaultBackendSet", ctx, params)}
}</span>

func (_c *MockociLoadBalancerModel_reconcileDefaultBackendSet_Call) Run(run func(ctx context.Context, params reconcileDefaultBackendParams)) *MockociLoadBalancerModel_reconcileDefaultBackendSet_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(reconcileDefaultBackendParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerModel_reconcileDefaultBackendSet_Call) Return(_a0 loadbalancer.BackendSet, _a1 error) *MockociLoadBalancerModel_reconcileDefaultBackendSet_Call <span class="cov3" title="3">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockociLoadBalancerModel_reconcileDefaultBackendSet_Call) RunAndReturn(run func(context.Context, reconcileDefaultBackendParams) (loadbalancer.BackendSet, error)) *MockociLoadBalancerModel_reconcileDefaultBackendSet_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// reconcileHTTPListener provides a mock function with given fields: ctx, params
func (_m *MockociLoadBalancerModel) reconcileHTTPListener(ctx context.Context, params reconcileHTTPListenerParams) error <span class="cov4" title="5">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for reconcileHTTPListener")</span>
        }

        <span class="cov4" title="5">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, reconcileHTTPListenerParams) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov4" title="5"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov4" title="5">return r0</span>
}

// MockociLoadBalancerModel_reconcileHTTPListener_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'reconcileHTTPListener'
type MockociLoadBalancerModel_reconcileHTTPListener_Call struct {
        *mock.Call
}

// reconcileHTTPListener is a helper method to define mock.On call
//   - ctx context.Context
//   - params reconcileHTTPListenerParams
func (_e *MockociLoadBalancerModel_Expecter) reconcileHTTPListener(ctx interface{}, params interface{}) *MockociLoadBalancerModel_reconcileHTTPListener_Call <span class="cov4" title="5">{
        return &amp;MockociLoadBalancerModel_reconcileHTTPListener_Call{Call: _e.mock.On("reconcileHTTPListener", ctx, params)}
}</span>

func (_c *MockociLoadBalancerModel_reconcileHTTPListener_Call) Run(run func(ctx context.Context, params reconcileHTTPListenerParams)) *MockociLoadBalancerModel_reconcileHTTPListener_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(reconcileHTTPListenerParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerModel_reconcileHTTPListener_Call) Return(_a0 error) *MockociLoadBalancerModel_reconcileHTTPListener_Call <span class="cov4" title="5">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockociLoadBalancerModel_reconcileHTTPListener_Call) RunAndReturn(run func(context.Context, reconcileHTTPListenerParams) error) *MockociLoadBalancerModel_reconcileHTTPListener_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// removeMissingListeners provides a mock function with given fields: ctx, params
func (_m *MockociLoadBalancerModel) removeMissingListeners(ctx context.Context, params removeMissingListenersParams) error <span class="cov1" title="1">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for removeMissingListeners")</span>
        }

        <span class="cov1" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, removeMissingListenersParams) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov1" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov1" title="1">return r0</span>
}

// MockociLoadBalancerModel_removeMissingListeners_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'removeMissingListeners'
type MockociLoadBalancerModel_removeMissingListeners_Call struct {
        *mock.Call
}

// removeMissingListeners is a helper method to define mock.On call
//   - ctx context.Context
//   - params removeMissingListenersParams
func (_e *MockociLoadBalancerModel_Expecter) removeMissingListeners(ctx interface{}, params interface{}) *MockociLoadBalancerModel_removeMissingListeners_Call <span class="cov1" title="1">{
        return &amp;MockociLoadBalancerModel_removeMissingListeners_Call{Call: _e.mock.On("removeMissingListeners", ctx, params)}
}</span>

func (_c *MockociLoadBalancerModel_removeMissingListeners_Call) Run(run func(ctx context.Context, params removeMissingListenersParams)) *MockociLoadBalancerModel_removeMissingListeners_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(removeMissingListenersParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerModel_removeMissingListeners_Call) Return(_a0 error) *MockociLoadBalancerModel_removeMissingListeners_Call <span class="cov1" title="1">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockociLoadBalancerModel_removeMissingListeners_Call) RunAndReturn(run func(context.Context, removeMissingListenersParams) error) *MockociLoadBalancerModel_removeMissingListeners_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockociLoadBalancerModel creates a new instance of MockociLoadBalancerModel. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockociLoadBalancerModel(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockociLoadBalancerModel <span class="cov10" title="41">{
        mock := &amp;MockociLoadBalancerModel{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="41">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="41">return mock</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package app

import (
        mock "github.com/stretchr/testify/mock"
        v1 "sigs.k8s.io/gateway-api/apis/v1"
)

// MockociLoadBalancerRoutingRulesMapper is an autogenerated mock type for the ociLoadBalancerRoutingRulesMapper type
type MockociLoadBalancerRoutingRulesMapper struct {
        mock.Mock
}

type MockociLoadBalancerRoutingRulesMapper_Expecter struct {
        mock *mock.Mock
}

func (_m *MockociLoadBalancerRoutingRulesMapper) EXPECT() *MockociLoadBalancerRoutingRulesMapper_Expecter <span class="cov2" title="2">{
        return &amp;MockociLoadBalancerRoutingRulesMapper_Expecter{mock: &amp;_m.Mock}
}</span>

// mapHTTPRouteMatchToCondition provides a mock function with given fields: match
func (_m *MockociLoadBalancerRoutingRulesMapper) mapHTTPRouteMatchToCondition(match v1.HTTPRouteMatch) (string, error) <span class="cov0" title="0">{
        ret := _m.Called(match)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for mapHTTPRouteMatchToCondition")</span>
        }

        <span class="cov0" title="0">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(v1.HTTPRouteMatch) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(match)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(v1.HTTPRouteMatch) string); ok </span><span class="cov0" title="0">{
                r0 = rf(match)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(v1.HTTPRouteMatch) error); ok </span><span class="cov0" title="0">{
                r1 = rf(match)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockociLoadBalancerRoutingRulesMapper_mapHTTPRouteMatchToCondition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'mapHTTPRouteMatchToCondition'
type MockociLoadBalancerRoutingRulesMapper_mapHTTPRouteMatchToCondition_Call struct {
        *mock.Call
}

// mapHTTPRouteMatchToCondition is a helper method to define mock.On call
//   - match v1.HTTPRouteMatch
func (_e *MockociLoadBalancerRoutingRulesMapper_Expecter) mapHTTPRouteMatchToCondition(match interface{}) *MockociLoadBalancerRoutingRulesMapper_mapHTTPRouteMatchToCondition_Call <span class="cov0" title="0">{
        return &amp;MockociLoadBalancerRoutingRulesMapper_mapHTTPRouteMatchToCondition_Call{Call: _e.mock.On("mapHTTPRouteMatchToCondition", match)}
}</span>

func (_c *MockociLoadBalancerRoutingRulesMapper_mapHTTPRouteMatchToCondition_Call) Run(run func(match v1.HTTPRouteMatch)) *MockociLoadBalancerRoutingRulesMapper_mapHTTPRouteMatchToCondition_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(v1.HTTPRouteMatch))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerRoutingRulesMapper_mapHTTPRouteMatchToCondition_Call) Return(_a0 string, _a1 error) *MockociLoadBalancerRoutingRulesMapper_mapHTTPRouteMatchToCondition_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockociLoadBalancerRoutingRulesMapper_mapHTTPRouteMatchToCondition_Call) RunAndReturn(run func(v1.HTTPRouteMatch) (string, error)) *MockociLoadBalancerRoutingRulesMapper_mapHTTPRouteMatchToCondition_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// mapHTTPRouteMatchesToCondition provides a mock function with given fields: matches
func (_m *MockociLoadBalancerRoutingRulesMapper) mapHTTPRouteMatchesToCondition(matches []v1.HTTPRouteMatch) (string, error) <span class="cov2" title="2">{
        ret := _m.Called(matches)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for mapHTTPRouteMatchesToCondition")</span>
        }

        <span class="cov2" title="2">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func([]v1.HTTPRouteMatch) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(matches)
        }</span>
        <span class="cov2" title="2">if rf, ok := ret.Get(0).(func([]v1.HTTPRouteMatch) string); ok </span><span class="cov0" title="0">{
                r0 = rf(matches)
        }</span> else<span class="cov2" title="2"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov2" title="2">if rf, ok := ret.Get(1).(func([]v1.HTTPRouteMatch) error); ok </span><span class="cov0" title="0">{
                r1 = rf(matches)
        }</span> else<span class="cov2" title="2"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov2" title="2">return r0, r1</span>
}

// MockociLoadBalancerRoutingRulesMapper_mapHTTPRouteMatchesToCondition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'mapHTTPRouteMatchesToCondition'
type MockociLoadBalancerRoutingRulesMapper_mapHTTPRouteMatchesToCondition_Call struct {
        *mock.Call
}

// mapHTTPRouteMatchesToCondition is a helper method to define mock.On call
//   - matches []v1.HTTPRouteMatch
func (_e *MockociLoadBalancerRoutingRulesMapper_Expecter) mapHTTPRouteMatchesToCondition(matches interface{}) *MockociLoadBalancerRoutingRulesMapper_mapHTTPRouteMatchesToCondition_Call <span class="cov2" title="2">{
        return &amp;MockociLoadBalancerRoutingRulesMapper_mapHTTPRouteMatchesToCondition_Call{Call: _e.mock.On("mapHTTPRouteMatchesToCondition", matches)}
}</span>

func (_c *MockociLoadBalancerRoutingRulesMapper_mapHTTPRouteMatchesToCondition_Call) Run(run func(matches []v1.HTTPRouteMatch)) *MockociLoadBalancerRoutingRulesMapper_mapHTTPRouteMatchesToCondition_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].([]v1.HTTPRouteMatch))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockociLoadBalancerRoutingRulesMapper_mapHTTPRouteMatchesToCondition_Call) Return(_a0 string, _a1 error) *MockociLoadBalancerRoutingRulesMapper_mapHTTPRouteMatchesToCondition_Call <span class="cov2" title="2">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockociLoadBalancerRoutingRulesMapper_mapHTTPRouteMatchesToCondition_Call) RunAndReturn(run func([]v1.HTTPRouteMatch) (string, error)) *MockociLoadBalancerRoutingRulesMapper_mapHTTPRouteMatchesToCondition_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockociLoadBalancerRoutingRulesMapper creates a new instance of MockociLoadBalancerRoutingRulesMapper. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockociLoadBalancerRoutingRulesMapper(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockociLoadBalancerRoutingRulesMapper <span class="cov10" title="26">{
        mock := &amp;MockociLoadBalancerRoutingRulesMapper{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="26">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="26">return mock</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package app

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
)

// MockresourcesModel is an autogenerated mock type for the resourcesModel type
type MockresourcesModel struct {
        mock.Mock
}

type MockresourcesModel_Expecter struct {
        mock *mock.Mock
}

func (_m *MockresourcesModel) EXPECT() *MockresourcesModel_Expecter <span class="cov8" title="24">{
        return &amp;MockresourcesModel_Expecter{mock: &amp;_m.Mock}
}</span>

// isConditionSet provides a mock function with given fields: params
func (_m *MockresourcesModel) isConditionSet(params isConditionSetParams) bool <span class="cov7" title="14">{
        ret := _m.Called(params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for isConditionSet")</span>
        }

        <span class="cov7" title="14">var r0 bool
        if rf, ok := ret.Get(0).(func(isConditionSetParams) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(params)
        }</span> else<span class="cov7" title="14"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov7" title="14">return r0</span>
}

// MockresourcesModel_isConditionSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'isConditionSet'
type MockresourcesModel_isConditionSet_Call struct {
        *mock.Call
}

// isConditionSet is a helper method to define mock.On call
//   - params isConditionSetParams
func (_e *MockresourcesModel_Expecter) isConditionSet(params interface{}) *MockresourcesModel_isConditionSet_Call <span class="cov7" title="14">{
        return &amp;MockresourcesModel_isConditionSet_Call{Call: _e.mock.On("isConditionSet", params)}
}</span>

func (_c *MockresourcesModel_isConditionSet_Call) Run(run func(params isConditionSetParams)) *MockresourcesModel_isConditionSet_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(isConditionSetParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockresourcesModel_isConditionSet_Call) Return(_a0 bool) *MockresourcesModel_isConditionSet_Call <span class="cov7" title="14">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockresourcesModel_isConditionSet_Call) RunAndReturn(run func(isConditionSetParams) bool) *MockresourcesModel_isConditionSet_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// setCondition provides a mock function with given fields: ctx, params
func (_m *MockresourcesModel) setCondition(ctx context.Context, params setConditionParams) error <span class="cov6" title="10">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for setCondition")</span>
        }

        <span class="cov6" title="10">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, setConditionParams) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov6" title="10"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov6" title="10">return r0</span>
}

// MockresourcesModel_setCondition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'setCondition'
type MockresourcesModel_setCondition_Call struct {
        *mock.Call
}

// setCondition is a helper method to define mock.On call
//   - ctx context.Context
//   - params setConditionParams
func (_e *MockresourcesModel_Expecter) setCondition(ctx interface{}, params interface{}) *MockresourcesModel_setCondition_Call <span class="cov6" title="10">{
        return &amp;MockresourcesModel_setCondition_Call{Call: _e.mock.On("setCondition", ctx, params)}
}</span>

func (_c *MockresourcesModel_setCondition_Call) Run(run func(ctx context.Context, params setConditionParams)) *MockresourcesModel_setCondition_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(setConditionParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockresourcesModel_setCondition_Call) Return(_a0 error) *MockresourcesModel_setCondition_Call <span class="cov6" title="10">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockresourcesModel_setCondition_Call) RunAndReturn(run func(context.Context, setConditionParams) error) *MockresourcesModel_setCondition_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockresourcesModel creates a new instance of MockresourcesModel. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockresourcesModel(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockresourcesModel <span class="cov10" title="43">{
        mock := &amp;MockresourcesModel{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="43">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="43">return mock</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package app

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
)

// MockworkRequestsWatcher is an autogenerated mock type for the workRequestsWatcher type
type MockworkRequestsWatcher struct {
        mock.Mock
}

type MockworkRequestsWatcher_Expecter struct {
        mock *mock.Mock
}

func (_m *MockworkRequestsWatcher) EXPECT() *MockworkRequestsWatcher_Expecter <span class="cov8" title="23">{
        return &amp;MockworkRequestsWatcher_Expecter{mock: &amp;_m.Mock}
}</span>

// WaitFor provides a mock function with given fields: ctx, workRequestID
func (_m *MockworkRequestsWatcher) WaitFor(ctx context.Context, workRequestID string) error <span class="cov8" title="23">{
        ret := _m.Called(ctx, workRequestID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for WaitFor")</span>
        }

        <span class="cov8" title="23">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, workRequestID)
        }</span> else<span class="cov8" title="23"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="23">return r0</span>
}

// MockworkRequestsWatcher_WaitFor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WaitFor'
type MockworkRequestsWatcher_WaitFor_Call struct {
        *mock.Call
}

// WaitFor is a helper method to define mock.On call
//   - ctx context.Context
//   - workRequestID string
func (_e *MockworkRequestsWatcher_Expecter) WaitFor(ctx interface{}, workRequestID interface{}) *MockworkRequestsWatcher_WaitFor_Call <span class="cov8" title="23">{
        return &amp;MockworkRequestsWatcher_WaitFor_Call{Call: _e.mock.On("WaitFor", ctx, workRequestID)}
}</span>

func (_c *MockworkRequestsWatcher_WaitFor_Call) Run(run func(ctx context.Context, workRequestID string)) *MockworkRequestsWatcher_WaitFor_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockworkRequestsWatcher_WaitFor_Call) Return(_a0 error) *MockworkRequestsWatcher_WaitFor_Call <span class="cov8" title="23">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockworkRequestsWatcher_WaitFor_Call) RunAndReturn(run func(context.Context, string) error) *MockworkRequestsWatcher_WaitFor_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockworkRequestsWatcher creates a new instance of MockworkRequestsWatcher. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockworkRequestsWatcher(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockworkRequestsWatcher <span class="cov10" title="40">{
        mock := &amp;MockworkRequestsWatcher{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="40">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="40">return mock</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package app

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "net/http"
        "regexp"
        "sort"

        "github.com/gemyago/oke-gateway-api/internal/diag"
        "github.com/gemyago/oke-gateway-api/internal/services/ociapi"
        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/loadbalancer"
        "github.com/samber/lo"
        "go.uber.org/dig"
        v1 "k8s.io/api/core/v1"
        gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
)

const defaultBackendSetPort = 80
const defaultCatchAllRuleName = "default_catch_all"
const maxBackendSetNameLength = 32
const maxListenerPolicyNameLength = 32

type reconcileDefaultBackendParams struct {
        loadBalancerID   string
        knownBackendSets map[string]loadbalancer.BackendSet
        gateway          *gatewayv1.Gateway
}

type reconcileBackendSetParams struct {
        loadBalancerID string
        service        v1.Service
}

type reconcileHTTPListenerParams struct {
        loadBalancerID        string
        knownListeners        map[string]loadbalancer.Listener
        defaultBackendSetName string
        listenerSpec          *gatewayv1.Listener
}

type makeRoutingRuleParams struct {
        httpRoute          gatewayv1.HTTPRoute
        httpRouteRuleIndex int
}

type commitRoutingPolicyParams struct {
        loadBalancerID string
        listenerName   string
        policyRules    []loadbalancer.RoutingRule

        // Previously programmed policy rules. This parameter helps to detect
        // rules that are not programmed anymore and needs to be removed. They are no
        // longer in the policyRules so there is no way to detect them otherwise.
        prevPolicyRules []string
}

type removeMissingListenersParams struct {
        loadBalancerID   string
        knownListeners   map[string]loadbalancer.Listener
        gatewayListeners []gatewayv1.Listener
}

type ociLoadBalancerModel interface {
        reconcileDefaultBackendSet(
                ctx context.Context,
                params reconcileDefaultBackendParams,
        ) (loadbalancer.BackendSet, error)
        reconcileHTTPListener(
                ctx context.Context,
                params reconcileHTTPListenerParams,
        ) error

        reconcileBackendSet(
                ctx context.Context,
                params reconcileBackendSetParams,
        ) error

        // makeRoutingRule appends a new routing rule to the routing policy.
        makeRoutingRule(
                ctx context.Context,
                params makeRoutingRuleParams,
        ) (loadbalancer.RoutingRule, error)

        commitRoutingPolicy(
                ctx context.Context,
                params commitRoutingPolicyParams,
        ) error

        // removeMissingListeners removes listeners from the load balancer that are not present in the gateway spec.
        removeMissingListeners(ctx context.Context, params removeMissingListenersParams) error
}

type ociLoadBalancerModelImpl struct {
        ociClient           ociLoadBalancerClient
        logger              *slog.Logger
        workRequestsWatcher workRequestsWatcher
        routingRulesMapper  ociLoadBalancerRoutingRulesMapper
}

func (m *ociLoadBalancerModelImpl) reconcileDefaultBackendSet(
        ctx context.Context,
        params reconcileDefaultBackendParams,
) (loadbalancer.BackendSet, error) <span class="cov5" title="5">{
        defaultBackendSetName := params.gateway.Name + "-default"
        if _, ok := params.knownBackendSets[defaultBackendSetName]; ok </span><span class="cov1" title="1">{
                m.logger.DebugContext(ctx, "Default backend set already exists",
                        slog.String("loadBalancerId", params.loadBalancerID),
                        slog.String("backendName", defaultBackendSetName),
                )
                return params.knownBackendSets[defaultBackendSetName], nil
        }</span>

        <span class="cov4" title="4">m.logger.InfoContext(ctx, "Default backend set not found, creating",
                slog.String("loadBalancerId", params.loadBalancerID),
                slog.String("name", defaultBackendSetName),
        )
        createRes, err := m.ociClient.CreateBackendSet(ctx, loadbalancer.CreateBackendSetRequest{
                LoadBalancerId: &amp;params.loadBalancerID,
                CreateBackendSetDetails: loadbalancer.CreateBackendSetDetails{
                        Name:   &amp;defaultBackendSetName,
                        Policy: lo.ToPtr("ROUND_ROBIN"),
                        HealthChecker: &amp;loadbalancer.HealthCheckerDetails{
                                Protocol: lo.ToPtr("TCP"),
                                Port:     lo.ToPtr(int(defaultBackendSetPort)),
                        },
                },
        })
        if err != nil </span><span class="cov1" title="1">{
                return loadbalancer.BackendSet{},
                        fmt.Errorf("failed to create default backend set %s: %w", defaultBackendSetName, err)
        }</span>

        <span class="cov3" title="3">if err = m.workRequestsWatcher.WaitFor(
                ctx,
                *createRes.OpcWorkRequestId,
        ); err != nil </span><span class="cov1" title="1">{
                return loadbalancer.BackendSet{},
                        fmt.Errorf("failed to wait for default backend set %s: %w", defaultBackendSetName, err)
        }</span>

        <span class="cov2" title="2">res, err := m.ociClient.GetBackendSet(ctx, loadbalancer.GetBackendSetRequest{
                BackendSetName: &amp;defaultBackendSetName,
                LoadBalancerId: lo.ToPtr(params.loadBalancerID),
        })
        if err != nil </span><span class="cov1" title="1">{
                return loadbalancer.BackendSet{}, fmt.Errorf("failed to get default backend set %s: %w", defaultBackendSetName, err)
        }</span>

        <span class="cov1" title="1">return res.BackendSet, nil</span>
}

func (m *ociLoadBalancerModelImpl) reconcileHTTPListener(
        ctx context.Context,
        params reconcileHTTPListenerParams,
) error <span class="cov5" title="6">{
        listenerName := string(params.listenerSpec.Name)
        if _, ok := params.knownListeners[listenerName]; ok </span><span class="cov1" title="1">{
                m.logger.DebugContext(ctx, "Listener already exists",
                        slog.String("loadBalancerId", params.loadBalancerID),
                        slog.String("listenerName", listenerName),
                )
                return nil
        }</span>

        <span class="cov5" title="5">m.logger.InfoContext(ctx, "Listener not found, creating",
                slog.String("loadBalancerId", params.loadBalancerID),
                slog.String("name", listenerName),
        )

        // Create a routing policy first
        routingPolicyName := listenerPolicyName(listenerName)
        m.logger.InfoContext(ctx, "Creating routing policy for listener",
                slog.String("loadBalancerId", params.loadBalancerID),
                slog.String("routingPolicyName", routingPolicyName),
                slog.String("listenerName", listenerName),
        )

        createRoutingPolicyRes, err := m.ociClient.CreateRoutingPolicy(ctx, loadbalancer.CreateRoutingPolicyRequest{
                LoadBalancerId: &amp;params.loadBalancerID,
                CreateRoutingPolicyDetails: loadbalancer.CreateRoutingPolicyDetails{
                        Name:                     lo.ToPtr(routingPolicyName),
                        ConditionLanguageVersion: loadbalancer.CreateRoutingPolicyDetailsConditionLanguageVersionV1,
                        Rules: []loadbalancer.RoutingRule{
                                // We're creating routing policy to have it available when reconciling routes
                                // It's not possible to create an empty routing policy, so we're adding a default rule.
                                // Alternative could be to create and attach routing policy when reconciling routes, but
                                // it may be a bit more complex on the route reconciler side.
                                {
                                        Name:      lo.ToPtr(defaultCatchAllRuleName),
                                        Condition: lo.ToPtr("any(http.request.url.path sw '/')"),
                                        Actions: []loadbalancer.Action{
                                                loadbalancer.ForwardToBackendSet{
                                                        BackendSetName: lo.ToPtr(params.defaultBackendSetName),
                                                },
                                        },
                                },
                        },
                },
        })
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to create routing policy %s: %w", routingPolicyName, err)
        }</span>

        <span class="cov4" title="4">if err = m.workRequestsWatcher.WaitFor(
                ctx,
                *createRoutingPolicyRes.OpcWorkRequestId,
        ); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to wait for routing policy %s: %w", routingPolicyName, err)
        }</span>

        // Now create the listener with the routing policy
        <span class="cov3" title="3">createRes, err := m.ociClient.CreateListener(ctx, loadbalancer.CreateListenerRequest{
                LoadBalancerId: &amp;params.loadBalancerID,
                CreateListenerDetails: loadbalancer.CreateListenerDetails{
                        Name:                  lo.ToPtr(listenerName),
                        DefaultBackendSetName: lo.ToPtr(params.defaultBackendSetName),
                        Port:                  lo.ToPtr(int(params.listenerSpec.Port)),
                        Protocol:              lo.ToPtr(string(params.listenerSpec.Protocol)),
                        RoutingPolicyName:     lo.ToPtr(routingPolicyName),
                },
        })
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to create listener %s: %w", listenerName, err)
        }</span>

        <span class="cov2" title="2">if err = m.workRequestsWatcher.WaitFor(
                ctx,
                *createRes.OpcWorkRequestId,
        ); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to wait for listener %s: %w", listenerName, err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (m *ociLoadBalancerModelImpl) reconcileBackendSet(
        ctx context.Context,
        params reconcileBackendSetParams,
) error <span class="cov2" title="2">{
        backendSetName := ociBackendSetNameFromService(params.service)

        _, err := m.ociClient.GetBackendSet(ctx, loadbalancer.GetBackendSetRequest{
                BackendSetName: &amp;backendSetName,
                LoadBalancerId: &amp;params.loadBalancerID,
        })
        if err != nil </span><span class="cov1" title="1">{
                serviceErr, ok := common.IsServiceError(err)
                if !ok || serviceErr.GetHTTPStatusCode() != http.StatusNotFound </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get backend set %s: %w", backendSetName, err)
                }</span>
        } else<span class="cov1" title="1"> {
                m.logger.DebugContext(ctx, "Backend set found, skipping creation",
                        slog.String("loadBalancerId", params.loadBalancerID),
                        slog.String("backendSetName", backendSetName),
                )
                return nil
        }</span>

        <span class="cov1" title="1">m.logger.InfoContext(ctx, "Backend set not found, creating",
                slog.String("loadBalancerId", params.loadBalancerID),
                slog.String("backendSetName", backendSetName),
        )

        createRes, err := m.ociClient.CreateBackendSet(ctx, loadbalancer.CreateBackendSetRequest{
                LoadBalancerId: &amp;params.loadBalancerID,
                CreateBackendSetDetails: loadbalancer.CreateBackendSetDetails{
                        Name:   &amp;backendSetName,
                        Policy: lo.ToPtr("ROUND_ROBIN"),
                        HealthChecker: &amp;loadbalancer.HealthCheckerDetails{
                                Protocol: lo.ToPtr("TCP"),
                                Port:     lo.ToPtr(int(params.service.Spec.Ports[0].Port)),
                        },
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create backend set %s: %w", backendSetName, err)
        }</span>

        <span class="cov1" title="1">if err = m.workRequestsWatcher.WaitFor(
                ctx,
                *createRes.OpcWorkRequestId,
        ); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to wait for backend set %s: %w", backendSetName, err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (m *ociLoadBalancerModelImpl) makeRoutingRule(
        ctx context.Context,
        params makeRoutingRuleParams,
) (loadbalancer.RoutingRule, error) <span class="cov2" title="2">{
        ruleName := ociListerPolicyRuleName(params.httpRoute, params.httpRouteRuleIndex)
        rule := params.httpRoute.Spec.Rules[params.httpRouteRuleIndex]

        targetBackends := lo.Map(rule.BackendRefs, func(backendRef gatewayv1.HTTPBackendRef, _ int) string </span><span class="cov2" title="2">{
                return ociBackendSetNameFromBackendRef(params.httpRoute, backendRef)
        }</span>)

        <span class="cov2" title="2">condition, err := m.routingRulesMapper.mapHTTPRouteMatchesToCondition(rule.Matches)
        if err != nil </span><span class="cov1" title="1">{
                return loadbalancer.RoutingRule{}, fmt.Errorf("failed to map http route matches to condition: %w", err)
        }</span>

        <span class="cov1" title="1">m.logger.DebugContext(ctx, "Building OCI routing rule",
                slog.String("httpRoute", fmt.Sprintf("%s/%s", params.httpRoute.Namespace, params.httpRoute.Name)),
                slog.Int("httpRouteRuleIndex", params.httpRouteRuleIndex),
                slog.String("ruleName", ruleName),
                slog.Any("targetBackends", targetBackends),
        )

        return loadbalancer.RoutingRule{
                Name:      lo.ToPtr(ruleName),
                Condition: lo.ToPtr(condition),
                Actions: lo.Map(targetBackends, func(backendSetName string, _ int) loadbalancer.Action </span><span class="cov2" title="2">{
                        return loadbalancer.ForwardToBackendSet{
                                BackendSetName: lo.ToPtr(backendSetName),
                        }
                }</span>),
        }, nil
}

func (m *ociLoadBalancerModelImpl) deleteMissingListener(
        ctx context.Context,
        loadBalancerID string,
        listener loadbalancer.Listener,
) error <span class="cov6" title="9">{
        m.logger.InfoContext(ctx, "Removing listener not found in gateway spec",
                slog.String("listenerName", lo.FromPtr(listener.Name)),
                slog.String("loadBalancerId", loadBalancerID),
                slog.String("routingPolicyName", lo.FromPtr(listener.RoutingPolicyName)),
        )
        resp, err := m.ociClient.DeleteListener(ctx, loadbalancer.DeleteListenerRequest{
                LoadBalancerId: &amp;loadBalancerID,
                ListenerName:   listener.Name,
        })
        if err != nil </span><span class="cov2" title="2">{
                m.logger.WarnContext(ctx,
                        "Listener deletion failed, will try with others",
                        diag.ErrAttr(err),
                        slog.String("listenerName", lo.FromPtr(listener.Name)),
                        slog.String("loadBalancerId", loadBalancerID),
                )
                return fmt.Errorf("failed to delete listener %s: %w", lo.FromPtr(listener.Name), err)
        }</span>

        <span class="cov5" title="7">if err = m.workRequestsWatcher.WaitFor(ctx, *resp.OpcWorkRequestId); err != nil </span><span class="cov2" title="2">{
                return fmt.Errorf("failed to wait for listener %s deletion: %w", lo.FromPtr(listener.Name), err)
        }</span>

        <span class="cov5" title="5">return nil</span>
}

func (m *ociLoadBalancerModelImpl) deleteMissingRoutingPolicy(
        ctx context.Context,
        loadBalancerID string,
        listener loadbalancer.Listener,
) error <span class="cov5" title="5">{
        if listener.RoutingPolicyName != nil </span><span class="cov2" title="2">{
                m.logger.DebugContext(ctx, "Deleting routing policy",
                        slog.String("routingPolicyName", *listener.RoutingPolicyName),
                        slog.String("loadBalancerId", loadBalancerID),
                )
                var deletePolicyRes loadbalancer.DeleteRoutingPolicyResponse
                deletePolicyRes, err := m.ociClient.DeleteRoutingPolicy(ctx, loadbalancer.DeleteRoutingPolicyRequest{
                        LoadBalancerId:    &amp;loadBalancerID,
                        RoutingPolicyName: listener.RoutingPolicyName,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete routing policy %s: %w", *listener.RoutingPolicyName, err)
                }</span>

                <span class="cov2" title="2">if err = m.workRequestsWatcher.WaitFor(ctx, *deletePolicyRes.OpcWorkRequestId); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to wait for routing policy %s deletion: %w", *listener.RoutingPolicyName, err)
                }</span>
        }

        <span class="cov5" title="5">return nil</span>
}

func (m *ociLoadBalancerModelImpl) removeMissingListeners(
        ctx context.Context,
        params removeMissingListenersParams,
) error <span class="cov5" title="6">{
        // TODO: Investigate desired behavior when attempting to delete listeners
        // that have rules associated with them.

        gatewayListenerNames := lo.SliceToMap(params.gatewayListeners, func(l gatewayv1.Listener) (string, struct{}) </span><span class="cov5" title="6">{
                return string(l.Name), struct{}{}
        }</span>)

        <span class="cov5" title="6">var errs []error
        for listenerName, listener := range params.knownListeners </span><span class="cov7" title="15">{
                if _, existsInGateway := gatewayListenerNames[listenerName]; !existsInGateway </span><span class="cov6" title="9">{
                        if err := m.deleteMissingListener(ctx, params.loadBalancerID, listener); err != nil </span><span class="cov4" title="4">{
                                m.logger.WarnContext(ctx, "Failed to delete listener, will try with others",
                                        diag.ErrAttr(err),
                                        slog.String("listenerName", listenerName),
                                        slog.String("loadBalancerId", params.loadBalancerID),
                                )
                                errs = append(errs, err)
                                continue</span>
                        }

                        <span class="cov5" title="5">if err := m.deleteMissingRoutingPolicy(ctx, params.loadBalancerID, listener); err != nil </span><span class="cov0" title="0">{
                                m.logger.WarnContext(ctx, "Failed to delete routing policy, will try with others",
                                        diag.ErrAttr(err),
                                        slog.String("listenerName", listenerName),
                                        slog.String("loadBalancerId", params.loadBalancerID),
                                )
                                errs = append(errs, err)
                                continue</span>
                        }

                        <span class="cov5" title="5">m.logger.DebugContext(ctx, "Completed listener removal", slog.String("listenerName", listenerName))</span>
                }
        }

        <span class="cov5" title="6">return errors.Join(errs...)</span>
}

func (m *ociLoadBalancerModelImpl) commitRoutingPolicy(
        ctx context.Context,
        params commitRoutingPolicyParams,
) error <span class="cov5" title="5">{
        policyName := listenerPolicyName(params.listenerName)

        policyResponse, err := m.ociClient.GetRoutingPolicy(ctx, loadbalancer.GetRoutingPolicyRequest{
                RoutingPolicyName: &amp;policyName,
                LoadBalancerId:    &amp;params.loadBalancerID,
        })
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to get routing policy %s: %w", policyName, err)
        }</span>

        <span class="cov4" title="4">currentRulesByName := lo.SliceToMap(
                policyResponse.RoutingPolicy.Rules,
                func(rule loadbalancer.RoutingRule) (string, loadbalancer.RoutingRule) </span><span class="cov8" title="17">{
                        return lo.FromPtr(rule.Name), rule
                }</span>,
        )

        <span class="cov4" title="4">policyRulesNames := make(map[string]struct{})
        for _, newRule := range params.policyRules </span><span class="cov8" title="18">{
                ruleName := lo.FromPtr(newRule.Name)
                currentRulesByName[ruleName] = newRule
                policyRulesNames[ruleName] = struct{}{}
        }</span>

        <span class="cov4" title="4">for _, prevRuleName := range params.prevPolicyRules </span><span class="cov3" title="3">{
                if _, ok := policyRulesNames[prevRuleName]; !ok </span><span class="cov3" title="3">{
                        m.logger.InfoContext(ctx, "Deleting previous policy rule",
                                slog.String("ruleName", prevRuleName),
                                slog.String("loadBalancerId", params.loadBalancerID),
                                slog.String("policyName", policyName),
                        )
                        delete(currentRulesByName, prevRuleName)
                }</span>
        }

        <span class="cov4" title="4">mergedRules := lo.Values(currentRulesByName)

        // Sort the rules: defaultCatchAllRuleName should be at the end
        sort.Slice(mergedRules, func(i, j int) bool </span><span class="cov10" title="35">{
                ruleI := lo.FromPtr(mergedRules[i].Name)
                ruleJ := lo.FromPtr(mergedRules[j].Name)
                if ruleI == defaultCatchAllRuleName </span><span class="cov2" title="2">{
                        return false
                }</span>
                <span class="cov9" title="33">if ruleJ == defaultCatchAllRuleName </span><span class="cov4" title="4">{
                        return true
                }</span>
                <span class="cov9" title="29">return ruleI &lt; ruleJ</span>
        })

        <span class="cov4" title="4">updateRes, err := m.ociClient.UpdateRoutingPolicy(ctx, loadbalancer.UpdateRoutingPolicyRequest{
                LoadBalancerId:    &amp;params.loadBalancerID,
                RoutingPolicyName: &amp;policyName,
                UpdateRoutingPolicyDetails: loadbalancer.UpdateRoutingPolicyDetails{
                        ConditionLanguageVersion: loadbalancer.UpdateRoutingPolicyDetailsConditionLanguageVersionEnum(
                                policyResponse.RoutingPolicy.ConditionLanguageVersion,
                        ),
                        Rules: mergedRules,
                },
        })
        if err != nil </span><span class="cov1" title="1">{
                m.logger.WarnContext(ctx, "Failed to update routing policy",
                        diag.ErrAttr(err),
                        slog.String("loadBalancerId", params.loadBalancerID),
                        slog.String("policyName", policyName),
                        slog.Any("policyRules", mergedRules),
                )
                return fmt.Errorf("failed to update routing policy %s: %w", policyName, err)
        }</span>

        <span class="cov3" title="3">if err = m.workRequestsWatcher.WaitFor(
                ctx,
                *updateRes.OpcWorkRequestId,
        ); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to wait for routing policy %s update: %w", policyName, err)
        }</span>

        <span class="cov2" title="2">m.logger.InfoContext(ctx, "Successfully committed routing policy changes",
                slog.String("loadBalancerId", params.loadBalancerID),
                slog.String("routingPolicyName", policyName),
        )
        return nil</span>
}

func listenerPolicyName(listenerName string) string <span class="cov7" title="15">{
        // TODO: Sanitize the name, investigate docs for allowed characters
        return listenerName + "_policy"
}</span>

/*
Name for the routing policy rule set. A name is required. The name must be unique,
and can't be changed. The name can't begin with a period and can't contain any of
these characters: ; ? # / % \ ] [. The name must start with an lower- or upper- case
letter or an underscore, and the rest of the name can contain numbers, underscores,
and upper- or lowercase letters.
*/
var invalidCharsForPolicyNamePattern = regexp.MustCompile(`[^a-zA-Z0-9_]`)

// ociListerPolicyRuleName returns the name of the routing rule for the listener policy.
// It's expected that the rule name is unique within the listener policy for every route.
// Names should also be sortable, so we're using a 4 digit index.
func ociListerPolicyRuleName(route gatewayv1.HTTPRoute, ruleIndex int) string <span class="cov5" title="7">{
        // TODO: This may probably need to have namespace
        // Also check if namespace is populated in the route if it's not in the spec
        // Also mention in docs that policy is per listener and rules for different
        // services best to have something unique like host matching

        rule := route.Spec.Rules[ruleIndex]

        var resultingName string
        if rule.Name != nil </span><span class="cov2" title="2">{
                resultingName = fmt.Sprintf("p%04d_%s_%s", ruleIndex, route.Name, string(*rule.Name))
        }</span> else<span class="cov5" title="5"> {
                resultingName = fmt.Sprintf("p%04d_%s", ruleIndex, route.Name)
        }</span>

        <span class="cov5" title="7">return ociapi.ConstructOCIResourceName(resultingName, ociapi.OCIResourceNameConfig{
                MaxLength:           maxListenerPolicyNameLength,
                InvalidCharsPattern: invalidCharsForPolicyNamePattern,
        })</span>
}

// ociBackendSetName returns the name of the backend set for the route.
// It's expected that the backend set name is unique within the load balancer for every route.
// Sorting is not required, but keeping padding for consistency and readability.
func ociBackendSetNameFromBackendRef(httpRoute gatewayv1.HTTPRoute, backendRef gatewayv1.HTTPBackendRef) string <span class="cov7" title="11">{
        // TODO: Check if namespace is populated in the route if it's not in the spec
        refName := string(backendRef.Name)
        refNamespace := string(lo.FromPtr(backendRef.Namespace))
        if refNamespace == "" </span><span class="cov1" title="1">{
                refNamespace = httpRoute.Namespace
        }</span>

        <span class="cov7" title="11">originalName := refNamespace + "-" + refName

        return ociapi.ConstructOCIResourceName(originalName, ociapi.OCIResourceNameConfig{
                MaxLength: maxBackendSetNameLength,
        })</span>
}

func ociBackendSetNameFromService(service v1.Service) string <span class="cov5" title="6">{
        originalName := service.Namespace + "-" + service.Name
        return ociapi.ConstructOCIResourceName(originalName, ociapi.OCIResourceNameConfig{
                MaxLength: maxBackendSetNameLength,
        })
}</span>

type ociLoadBalancerModelDeps struct {
        dig.In

        RootLogger          *slog.Logger
        OciClient           ociLoadBalancerClient
        WorkRequestsWatcher workRequestsWatcher
        RoutingRulesMapper  ociLoadBalancerRoutingRulesMapper
}

func newOciLoadBalancerModel(deps ociLoadBalancerModelDeps) ociLoadBalancerModel <span class="cov9" title="27">{
        return &amp;ociLoadBalancerModelImpl{
                logger:              deps.RootLogger.WithGroup("oci-load-balancer-model"),
                ociClient:           deps.OciClient,
                workRequestsWatcher: deps.WorkRequestsWatcher,
                routingRulesMapper:  deps.RoutingRulesMapper,
        }
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package app

import (
        "errors"
        "fmt"
        "strings"

        gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
)

var errUnsupportedMatch = errors.New("unsupported match type")

type ociLoadBalancerRoutingRulesMapper interface {
        // mapHTTPRouteMatchToCondition translates a Gateway API HTTPRouteMatch
        // into an OCI Load Balancer condition string.
        // Returns an empty string if the match is nil or empty.
        // Returns errUnsupportedMatch if any part of the match uses features
        // not supported by OCI Load Balancer rules (e.g., regex, query params, method).
        mapHTTPRouteMatchToCondition(match gatewayv1.HTTPRouteMatch) (string, error)

        // mapHTTPRouteMatchesToCondition translates a Gateway API HTTPRouteMatches
        // to a list of OCI Load Balancer conditions as a string..
        mapHTTPRouteMatchesToCondition(matches []gatewayv1.HTTPRouteMatch) (string, error)
}

type ociLoadBalancerRoutingRulesMapperImpl struct{}

func newOciLoadBalancerRoutingRulesMapper() ociLoadBalancerRoutingRulesMapper <span class="cov10" title="19">{
        return &amp;ociLoadBalancerRoutingRulesMapperImpl{}
}</span>

// mapHTTPRouteMatchToCondition translates Gateway API match rules into OCI condition strings.
func (r *ociLoadBalancerRoutingRulesMapperImpl) mapHTTPRouteMatchToCondition(
        match gatewayv1.HTTPRouteMatch,
) (string, error) <span class="cov10" title="19">{
        var conditions []string

        // --- Unsupported Checks First ---
        if len(match.QueryParams) &gt; 0 </span><span class="cov1" title="1">{
                return "", fmt.Errorf("%w: query parameter matching", errUnsupportedMatch)
        }</span>
        <span class="cov9" title="18">if match.Method != nil </span><span class="cov3" title="2">{
                return "", fmt.Errorf("%w: method matching", errUnsupportedMatch)
        }</span>

        // --- Path Matching ---
        <span class="cov9" title="16">if match.Path != nil </span><span class="cov8" title="11">{
                if match.Path.Value == nil </span><span class="cov1" title="1">{
                        return "", errors.New("path match value cannot be nil")
                }</span>
                <span class="cov8" title="10">pathValue := *match.Path.Value
                pathType := gatewayv1.PathMatchPathPrefix // Default type if not specified
                if match.Path.Type != nil </span><span class="cov7" title="9">{
                        pathType = *match.Path.Type
                }</span>

                <span class="cov8" title="10">switch pathType </span>{
                case gatewayv1.PathMatchExact:<span class="cov5" title="5">
                        // TODO: Handle escaping single quotes in pathValue if necessary
                        conditions = append(conditions, fmt.Sprintf(`http.request.url.path eq '%s'`, pathValue))</span>
                case gatewayv1.PathMatchPathPrefix:<span class="cov5" title="4">
                        // TODO: Handle escaping single quotes in pathValue if necessary
                        conditions = append(conditions, fmt.Sprintf(`http.request.url.path sw '%s'`, pathValue))</span>
                case gatewayv1.PathMatchRegularExpression:<span class="cov1" title="1">
                        return "", fmt.Errorf("%w: regex path matching", errUnsupportedMatch)</span>
                default:<span class="cov0" title="0">
                        return "", fmt.Errorf("%w: unknown path match type '%s'", errUnsupportedMatch, pathType)</span>
                }
        }

        // --- Header Matching ---
        <span class="cov9" title="14">for _, headerMatch := range match.Headers </span><span class="cov7" title="8">{
                headerType := gatewayv1.HeaderMatchExact // Default type
                if headerMatch.Type != nil </span><span class="cov6" title="7">{
                        headerType = *headerMatch.Type
                }</span>

                <span class="cov7" title="8">switch headerType </span>{
                case gatewayv1.HeaderMatchExact:<span class="cov6" title="7">
                        // TODO: Handle escaping single quotes in headerMatch.Value if necessary
                        // Header names are case-insensitive in HTTP, but OCI conditions might be case-sensitive.
                        // Assuming case-sensitive match for now based on Gateway API spec.
                        conditions = append(
                                conditions,
                                fmt.Sprintf(`http.request.headers['%s'] eq '%s'`, headerMatch.Name, headerMatch.Value),
                        )</span>
                case gatewayv1.HeaderMatchRegularExpression:<span class="cov1" title="1">
                        return "", fmt.Errorf("%w: regex header matching for header '%s'", errUnsupportedMatch, headerMatch.Name)</span>
                default:<span class="cov0" title="0">
                        return "", fmt.Errorf("%w: unknown header match type '%s' for header '%s'",
                                errUnsupportedMatch,
                                headerType,
                                headerMatch.Name,
                        )</span>
                }
        }

        // --- Combine conditions ---
        <span class="cov8" title="13">return strings.Join(conditions, " and "), nil</span>
}

func (r *ociLoadBalancerRoutingRulesMapperImpl) mapHTTPRouteMatchesToCondition(
        matches []gatewayv1.HTTPRouteMatch,
) (string, error) <span class="cov5" title="4">{
        if len(matches) == 0 </span><span class="cov1" title="1">{
                return "", nil
        }</span>

        <span class="cov4" title="3">var conditions []string
        for _, match := range matches </span><span class="cov5" title="5">{
                condition, err := r.mapHTTPRouteMatchToCondition(match)
                if err != nil </span><span class="cov1" title="1">{
                        return "", err // Propagate error if any single match fails
                }</span>
                <span class="cov5" title="4">if condition != "" </span><span class="cov5" title="4">{
                        conditions = append(conditions, condition)
                }</span>
        }

        <span class="cov3" title="2">if len(conditions) == 0 </span><span class="cov0" title="0">{
                // TODO: Investigate if empty is possible, if no - return error here
                return "", nil
        }</span>

        <span class="cov3" title="2">return fmt.Sprintf("any(%s)", strings.Join(conditions, ", ")), nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package app

import (
        "github.com/gemyago/oke-gateway-api/internal/di"
        "github.com/gemyago/oke-gateway-api/internal/services/ociapi"
        "github.com/oracle/oci-go-sdk/v65/loadbalancer"
        "go.uber.org/dig"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

func Register(container *dig.Container) error <span class="cov8" title="1">{
        return di.ProvideAll(container,
                func(c client.Client) k8sClient </span><span class="cov8" title="1">{ return c }</span>,
                func(c loadbalancer.LoadBalancerClient) ociLoadBalancerClient <span class="cov8" title="1">{ return c }</span>,
                func(w *ociapi.WorkRequestsWatcher) workRequestsWatcher <span class="cov8" title="1">{ return w }</span>,
                NewGatewayClassController,
                NewGatewayController,
                NewHTTPRouteController,
                newResourcesModel,
                newGatewayModel,
                newHTTPRouteModel,
                newOciLoadBalancerModel,
                newOciLoadBalancerRoutingRulesMapper,
                newHTTPBackendModel,
                NewWatchesModel,
        )
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package app

import (
        "context"
        "fmt"
        "log/slog"

        "go.uber.org/dig"
        "k8s.io/apimachinery/pkg/api/meta"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

type setConditionParams struct {
        resource      client.Object
        conditions    *[]metav1.Condition
        conditionType string
        status        metav1.ConditionStatus
        reason        string
        message       string
        annotations   map[string]string
}

type isConditionSetParams struct {
        resource      client.Object
        conditions    []metav1.Condition
        conditionType string
        annotations   map[string]string
}

type resourcesModel interface {
        // setCondition sets a condition on a given resource.
        setCondition(ctx context.Context, params setConditionParams) error

        // isConditionSet checks if a specific condition is already set, true, and observed at the correct generation.
        isConditionSet(params isConditionSetParams) bool
}

type resourcesModelImpl struct {
        client k8sClient
        logger *slog.Logger
}

func (m *resourcesModelImpl) setCondition(ctx context.Context, params setConditionParams) error <span class="cov6" title="5">{
        if len(params.annotations) &gt; 0 </span><span class="cov4" title="3">{
                m.logger.DebugContext(ctx, "Updating resource annotations before setting condition",
                        slog.String("resource", params.resource.GetName()),
                        slog.Any("annotations", params.annotations))
                currentAnnotations := params.resource.GetAnnotations()
                if currentAnnotations == nil </span><span class="cov1" title="1">{
                        currentAnnotations = make(map[string]string)
                }</span>
                <span class="cov4" title="3">for k, v := range params.annotations </span><span class="cov6" title="5">{
                        currentAnnotations[k] = v
                }</span>
                <span class="cov4" title="3">params.resource.SetAnnotations(currentAnnotations)
                if err := m.client.Update(ctx, params.resource); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("failed to update resource %s with annotations: %w", params.resource.GetName(), err)
                }</span>
        }

        <span class="cov5" title="4">m.logger.DebugContext(ctx,
                fmt.Sprintf("Setting %s condition", params.conditionType),
                slog.String("resource", params.resource.GetName()),
                slog.String("status", string(params.status)),
                slog.String("reason", params.reason),
                slog.String("message", params.message),
        )

        generation := params.resource.GetGeneration()

        acceptedCondition := metav1.Condition{
                Type:               params.conditionType,
                Status:             params.status,
                Reason:             params.reason,
                Message:            params.message,
                ObservedGeneration: generation,
                LastTransitionTime: metav1.Now(),
        }

        meta.SetStatusCondition(params.conditions, acceptedCondition)

        if err := m.client.Status().Update(ctx, params.resource); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to update status for %s: %w", params.resource.GetName(), err)
        }</span>

        <span class="cov4" title="3">return nil</span>
}

func (m *resourcesModelImpl) isConditionSet(params isConditionSetParams) bool <span class="cov8" title="8">{
        if len(params.annotations) &gt; 0 </span><span class="cov5" title="4">{
                resourceAnnotations := params.resource.GetAnnotations()
                if resourceAnnotations == nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov5" title="4">for key, expectedValue := range params.annotations </span><span class="cov6" title="5">{
                        actualValue, found := resourceAnnotations[key]
                        if !found || actualValue != expectedValue </span><span class="cov3" title="2">{
                                return false
                        }</span>
                }
        }

        <span class="cov7" title="6">existingCondition := meta.FindStatusCondition(params.conditions, params.conditionType)
        if existingCondition != nil &amp;&amp;
                existingCondition.ObservedGeneration == params.resource.GetGeneration() </span><span class="cov4" title="3">{
                return true
        }</span>
        <span class="cov4" title="3">return false</span>
}

type resourcesModelDeps struct {
        dig.In

        K8sClient  k8sClient
        RootLogger *slog.Logger
}

func newResourcesModel(deps resourcesModelDeps) resourcesModel <span class="cov10" title="14">{
        return &amp;resourcesModelImpl{
                client: deps.K8sClient,
                logger: deps.RootLogger.WithGroup("resources-model"),
        }
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package app

import (
        "context"
        "fmt"
        "log/slog"
        "path"

        "github.com/gemyago/oke-gateway-api/internal/diag"
        "github.com/samber/lo"
        "go.uber.org/dig"
        discoveryv1 "k8s.io/api/discovery/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
)

const httpRouteBackendServiceIndexKey = ".metadata.backendRefs.serviceName" // Virtual field name, indexed

// WatchesModel implements the WatchesModel interface.
type WatchesModel struct {
        k8sClient k8sClient
        logger    *slog.Logger
}

type WatchesModelDeps struct {
        dig.In

        K8sClient k8sClient
        Logger    *slog.Logger
}

// NewWatchesModel creates a new watchesModel.
func NewWatchesModel(deps WatchesModelDeps) *WatchesModel <span class="cov8" title="12">{
        return &amp;WatchesModel{
                k8sClient: deps.K8sClient,
                logger:    deps.Logger.WithGroup("watches-model"),
        }
}</span>

// RegisterFieldIndexers registers the indexers for the watches model.
func (m *WatchesModel) RegisterFieldIndexers(ctx context.Context, indexer client.FieldIndexer) error <span class="cov3" title="2">{
        if err := indexer.IndexField(ctx,
                &amp;gatewayv1.HTTPRoute{},
                httpRouteBackendServiceIndexKey,
                func(o client.Object) []string </span><span class="cov0" title="0">{
                        return m.indexHTTPRouteByBackendService(ctx, o)
                }</span>,
        ); err != nil <span class="cov1" title="1">{
                return fmt.Errorf("failed to index HTTPRoute by backend service: %w", err)
        }</span>
        <span class="cov1" title="1">m.logger.DebugContext(ctx, "Field indexers registered",
                slog.String("indexKey", httpRouteBackendServiceIndexKey),
        )
        return nil</span>
}

// indexHTTPRouteByBackendService extracts the namespaced names of Services referenced
// in an HTTPRoute's backendRefs. This is used to create an index for efficient
// lookup when an EndpointSlice changes.
func (m *WatchesModel) indexHTTPRouteByBackendService(ctx context.Context, obj client.Object) []string <span class="cov5" title="4">{
        httpRoute, isRoute := obj.(*gatewayv1.HTTPRoute)
        if !isRoute </span><span class="cov1" title="1">{
                m.logger.WarnContext(ctx, "Received non-HTTPRoute object", slog.Any("object", obj))
                return nil
        }</span>

        <span class="cov4" title="3">uniqueServiceKeys := make(map[string]struct{})
        for _, rule := range httpRoute.Spec.Rules </span><span class="cov6" title="6">{
                for _, backendRef := range rule.BackendRefs </span><span class="cov10" title="17">{
                        ns := httpRoute.Namespace
                        if backendRef.BackendObjectReference.Namespace != nil </span><span class="cov9" title="15">{
                                ns = string(*backendRef.BackendObjectReference.Namespace)
                        }</span>
                        <span class="cov10" title="17">namespacedName := path.Join(
                                ns,
                                string(backendRef.BackendObjectReference.Name),
                        )
                        if _, ok := uniqueServiceKeys[namespacedName]; !ok </span><span class="cov9" title="14">{
                                uniqueServiceKeys[namespacedName] = struct{}{}
                        }</span>
                }
        }

        <span class="cov4" title="3">serviceKeys := lo.Keys(uniqueServiceKeys)
        m.logger.DebugContext(ctx, "Indexed HTTPRoute by backend service",
                slog.String("httpRoute", client.ObjectKeyFromObject(httpRoute).String()),
                slog.String("indexKey", httpRouteBackendServiceIndexKey),
                slog.Any("serviceKeys", serviceKeys),
        )

        return serviceKeys</span>
}

// MapEndpointSliceToHTTPRoute maps EndpointSlice events to HTTPRoute reconcile requests.
// Its signature matches handler.MapFunc.
func (m *WatchesModel) MapEndpointSliceToHTTPRoute(ctx context.Context, obj client.Object) []reconcile.Request <span class="cov6" title="5">{
        epSlice, ok := obj.(*discoveryv1.EndpointSlice)
        if !ok </span><span class="cov1" title="1">{
                m.logger.WarnContext(ctx, "Received non-EndpointSlice object", slog.Any("object", obj))
                return nil
        }</span>

        <span class="cov5" title="4">svcName, ok := epSlice.Labels[discoveryv1.LabelServiceName]
        if !ok </span><span class="cov1" title="1">{
                m.logger.WarnContext(ctx, "EndpointSlice missing service name label", slog.Any("endpointSlice", epSlice))
                return nil
        }</span>

        <span class="cov4" title="3">ns := epSlice.Namespace
        indexKey := path.Join(ns, svcName)

        var routeList gatewayv1.HTTPRouteList
        // TODO: Fetch all pages?
        if err := m.k8sClient.List(
                ctx,
                &amp;routeList,
                client.MatchingFields{httpRouteBackendServiceIndexKey: indexKey},
        ); err != nil </span><span class="cov1" title="1">{
                m.logger.ErrorContext(ctx,
                        "Failed to list HTTPRoutes for service",
                        slog.String("indexKey", indexKey),
                        diag.ErrAttr(err),
                )
                return nil
        }</span>

        <span class="cov3" title="2">if len(routeList.Items) == 0 </span><span class="cov1" title="1">{
                m.logger.DebugContext(
                        ctx,
                        "No HTTPRoutes found for service",
                        slog.String("service", svcName),
                        slog.String("indexKey", indexKey),
                )
                return nil
        }</span>

        <span class="cov1" title="1">requests := make([]reconcile.Request, len(routeList.Items))
        for i, route := range routeList.Items </span><span class="cov3" title="2">{
                requests[i] = reconcile.Request{
                        NamespacedName: client.ObjectKeyFromObject(&amp;route),
                }
                m.logger.InfoContext(ctx,
                        "Queueing HTTPRoute for reconciliation due to EndpointSlice change",
                        slog.String("httpRoute", client.ObjectKeyFromObject(&amp;route).String()),
                        slog.String("endpointSlice", client.ObjectKeyFromObject(epSlice).String()),
                )
        }</span>

        <span class="cov1" title="1">return requests</span>
}

// Note: indexHTTPRouteByBackendService and httpRouteBackendServiceIndexKey removed as part of stubbing.
</pre>
		
		<pre class="file" id="file34" style="display: none">package config

import (
        "embed"
        "fmt"
        "strings"

        "github.com/spf13/viper"
)

//go:embed *.json
var resources embed.FS

func mergeResourceCfg(cfg *viper.Viper, resourceName string) error <span class="cov10" title="19">{
        resourceStream, err := resources.Open(resourceName)
        if err != nil </span><span class="cov5" title="4">{
                return fmt.Errorf("failed to read config %v: %w", resourceName, err)
        }</span>
        <span class="cov9" title="15">defer resourceStream.Close()

        if err = cfg.MergeConfig(resourceStream); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config %v: %w", resourceName, err)
        }</span>
        <span class="cov9" title="15">return nil</span>
}

type LoadOpts struct {
        env                   string
        defaultConfigFileName string
}

func (opts *LoadOpts) WithEnv(val string) *LoadOpts <span class="cov7" title="8">{
        if val != "" </span><span class="cov5" title="4">{
                opts.env = val
        }</span>
        <span class="cov7" title="8">return opts</span>
}

func NewLoadOpts() *LoadOpts <span class="cov8" title="10">{
        return &amp;LoadOpts{
                env:                   "local",
                defaultConfigFileName: "default.json",
        }
}</span>

func New() *viper.Viper <span class="cov8" title="10">{
        v := viper.New()
        v.SetEnvPrefix("APP")
        v.SetConfigType("json")
        v.SetEnvKeyReplacer(
                strings.NewReplacer("-", "_", ".", "_"),
        )
        v.AutomaticEnv()
        return v
}</span>

func Load(cfg *viper.Viper, opts *LoadOpts) error <span class="cov8" title="10">{
        if err := mergeResourceCfg(cfg, opts.defaultConfigFileName); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov7" title="9">if err := mergeResourceCfg(cfg, opts.env+".json"); err != nil </span><span class="cov4" title="3">{
                return err
        }</span>

        // Some common aliases to have cli params with the same name as config keys
        <span class="cov6" title="6">cfg.RegisterAlias("defaultLogLevel", "log-level")
        cfg.RegisterAlias("jsonLogs", "json-logs")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package config

import (
        "fmt"

        "github.com/gemyago/oke-gateway-api/internal/di"
        "github.com/spf13/viper"
        "go.uber.org/dig"
)

type configValueProvider struct {
        cfg        *viper.Viper
        configPath string
        diPath     string
}

func provideConfigValue(cfg *viper.Viper, path string) configValueProvider <span class="cov10" title="30">{
        if !cfg.IsSet(path) </span><span class="cov1" title="1">{
                panic(fmt.Errorf("config key not found: %s", path))</span>
        }
        <span class="cov9" title="29">return configValueProvider{cfg, path, "config." + path}</span>
}

func (p configValueProvider) asInt() di.ConstructorWithOpts <span class="cov3" title="3">{
        return di.ProvideValue(p.cfg.GetInt(p.configPath), dig.Name(p.diPath))
}</span>

func (p configValueProvider) asInt32() di.ConstructorWithOpts <span class="cov1" title="1">{
        return di.ProvideValue(p.cfg.GetInt32(p.configPath), dig.Name(p.diPath))
}</span>

func (p configValueProvider) asString() di.ConstructorWithOpts <span class="cov6" title="7">{
        return di.ProvideValue(p.cfg.GetString(p.configPath), dig.Name(p.diPath))
}</span>

func (p configValueProvider) asBool() di.ConstructorWithOpts <span class="cov6" title="7">{
        return di.ProvideValue(p.cfg.GetBool(p.configPath), dig.Name(p.diPath))
}</span>

func (p configValueProvider) asDuration() di.ConstructorWithOpts <span class="cov7" title="11">{
        return di.ProvideValue(p.cfg.GetDuration(p.configPath), dig.Name(p.diPath))
}</span>

func Provide(container *dig.Container, cfg *viper.Viper) error <span class="cov2" title="2">{
        return di.ProvideAll(container,
                provideConfigValue(cfg, "gracefulShutdownTimeout").asDuration(),

                // http server config
                provideConfigValue(cfg, "httpServer.host").asString(),
                provideConfigValue(cfg, "httpServer.port").asInt(),
                provideConfigValue(cfg, "httpServer.idleTimeout").asDuration(),
                provideConfigValue(cfg, "httpServer.readHeaderTimeout").asDuration(),
                provideConfigValue(cfg, "httpServer.readTimeout").asDuration(),
                provideConfigValue(cfg, "httpServer.writeTimeout").asDuration(),
                provideConfigValue(cfg, "httpServer.mode").asString(),
                provideConfigValue(cfg, "httpServer.accessLogsLevel").asString(),

                // k8sapi config
                provideConfigValue(cfg, "k8sapi.noop").asBool(),
                provideConfigValue(cfg, "k8sapi.inCluster").asBool(),
                // ociapi config
                provideConfigValue(cfg, "ociapi.noop").asBool(),
        )
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package di

import (
        "fmt"
        "reflect"

        "go.uber.org/dig"
)

// Dig is used as DI toolkit https://pkg.go.dev/go.uber.org/dig
// we are not creating any abstraction over it, but we do have a set of tools to make it easier to use

type ConstructorWithOpts struct {
        Constructor interface{}
        Options     []dig.ProvideOption
}

func ProvideAll(container *dig.Container, providers ...interface{}) error <span class="cov7" title="23">{
        for i, provider := range providers </span><span class="cov10" title="74">{
                switch p := provider.(type) </span>{
                case ConstructorWithOpts:<span class="cov8" title="38">
                        if err := container.Provide(p.Constructor, p.Options...); err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to provide %d-th dependency: %w", i, err)
                        }</span>
                default:<span class="cov8" title="36">
                        if err := container.Provide(provider); err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to provide %d-th dependency: %w", i, err)
                        }</span>
                }
        }
        <span class="cov7" title="21">return nil</span>
}

// ProvideValue will create a constructor (e.g func) from a given value.
func ProvideValue[T any](val T, opts ...dig.ProvideOption) ConstructorWithOpts <span class="cov8" title="39">{
        return ConstructorWithOpts{
                Constructor: func() T </span><span class="cov7" title="24">{ return val }</span>,
                Options:     opts,
        }
}

// ProvideWithArg will create a constructor with a first arg explicitly provided
// supposed return no error.
func ProvideWithArg[
        TArg any,
        TConstructorArg any,
        TRes any,
](
        arg TArg,
        constructor func(arg TArg, cArg TConstructorArg) TRes,
) func(TConstructorArg) TRes <span class="cov1" title="1">{
        return func(cArg TConstructorArg) TRes </span><span class="cov1" title="1">{
                return constructor(arg, cArg)
        }</span>
}

// ProvideWithArgErr will create a constructor with a first arg explicitly provided
// supposed return an error.
func ProvideWithArgErr[
        TArg any,
        TConstructorArg any,
        TDep any,
](
        arg TArg,
        constructor func(arg TArg, cArg TConstructorArg) (TDep, error),
) func(TConstructorArg) (TDep, error) <span class="cov1" title="1">{
        return func(cArg TConstructorArg) (TDep, error) </span><span class="cov1" title="1">{
                return constructor(arg, cArg)
        }</span>
}

// ProvideAs is used to provide one type as another, typically
// used to provide implementation struct as particular interface.
func ProvideAs[TSource any, TTarget any](source TSource) (TTarget, error) <span class="cov2" title="2">{
        target, ok := any(source).(TTarget)
        if !ok </span><span class="cov1" title="1">{
                var src TSource
                var tgt TTarget
                return target, fmt.Errorf("failed to cast %s to %s", reflect.TypeOf(src), reflect.TypeOf(tgt))
        }</span>
        <span class="cov1" title="1">return target, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package diag

import "log/slog"

func ErrAttr(err error) slog.Attr <span class="cov10" title="12">{
        return slog.Any("err", err)
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package diag

import (
        context "context"
        slog "log/slog"

        mock "github.com/stretchr/testify/mock"
)

// MockSlogHandler is an autogenerated mock type for the Handler type
type MockSlogHandler struct {
        mock.Mock
}

type MockSlogHandler_Expecter struct {
        mock *mock.Mock
}

func (_m *MockSlogHandler) EXPECT() *MockSlogHandler_Expecter <span class="cov8" title="3">{
        return &amp;MockSlogHandler_Expecter{mock: &amp;_m.Mock}
}</span>

// Enabled provides a mock function with given fields: _a0, _a1
func (_m *MockSlogHandler) Enabled(_a0 context.Context, _a1 slog.Level) bool <span class="cov0" title="0">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Enabled")</span>
        }

        <span class="cov0" title="0">var r0 bool
        if rf, ok := ret.Get(0).(func(context.Context, slog.Level) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockSlogHandler_Enabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Enabled'
type MockSlogHandler_Enabled_Call struct {
        *mock.Call
}

// Enabled is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 slog.Level
func (_e *MockSlogHandler_Expecter) Enabled(_a0 interface{}, _a1 interface{}) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        return &amp;MockSlogHandler_Enabled_Call{Call: _e.mock.On("Enabled", _a0, _a1)}
}</span>

func (_c *MockSlogHandler_Enabled_Call) Run(run func(_a0 context.Context, _a1 slog.Level)) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(slog.Level))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_Enabled_Call) Return(_a0 bool) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_Enabled_Call) RunAndReturn(run func(context.Context, slog.Level) bool) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Handle provides a mock function with given fields: _a0, _a1
func (_m *MockSlogHandler) Handle(_a0 context.Context, _a1 slog.Record) error <span class="cov5" title="2">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Handle")</span>
        }

        <span class="cov5" title="2">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, slog.Record) error); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov5" title="2"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov5" title="2">return r0</span>
}

// MockSlogHandler_Handle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Handle'
type MockSlogHandler_Handle_Call struct {
        *mock.Call
}

// Handle is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 slog.Record
func (_e *MockSlogHandler_Expecter) Handle(_a0 interface{}, _a1 interface{}) *MockSlogHandler_Handle_Call <span class="cov5" title="2">{
        return &amp;MockSlogHandler_Handle_Call{Call: _e.mock.On("Handle", _a0, _a1)}
}</span>

func (_c *MockSlogHandler_Handle_Call) Run(run func(_a0 context.Context, _a1 slog.Record)) *MockSlogHandler_Handle_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(slog.Record))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_Handle_Call) Return(_a0 error) *MockSlogHandler_Handle_Call <span class="cov5" title="2">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_Handle_Call) RunAndReturn(run func(context.Context, slog.Record) error) *MockSlogHandler_Handle_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// WithAttrs provides a mock function with given fields: attrs
func (_m *MockSlogHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov1" title="1">{
        ret := _m.Called(attrs)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for WithAttrs")</span>
        }

        <span class="cov1" title="1">var r0 slog.Handler
        if rf, ok := ret.Get(0).(func([]slog.Attr) slog.Handler); ok </span><span class="cov0" title="0">{
                r0 = rf(attrs)
        }</span> else<span class="cov1" title="1"> {
                if ret.Get(0) != nil </span><span class="cov1" title="1">{
                        r0 = ret.Get(0).(slog.Handler)
                }</span>
        }

        <span class="cov1" title="1">return r0</span>
}

// MockSlogHandler_WithAttrs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithAttrs'
type MockSlogHandler_WithAttrs_Call struct {
        *mock.Call
}

// WithAttrs is a helper method to define mock.On call
//   - attrs []slog.Attr
func (_e *MockSlogHandler_Expecter) WithAttrs(attrs interface{}) *MockSlogHandler_WithAttrs_Call <span class="cov1" title="1">{
        return &amp;MockSlogHandler_WithAttrs_Call{Call: _e.mock.On("WithAttrs", attrs)}
}</span>

func (_c *MockSlogHandler_WithAttrs_Call) Run(run func(attrs []slog.Attr)) *MockSlogHandler_WithAttrs_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].([]slog.Attr))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_WithAttrs_Call) Return(_a0 slog.Handler) *MockSlogHandler_WithAttrs_Call <span class="cov1" title="1">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_WithAttrs_Call) RunAndReturn(run func([]slog.Attr) slog.Handler) *MockSlogHandler_WithAttrs_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// WithGroup provides a mock function with given fields: name
func (_m *MockSlogHandler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        ret := _m.Called(name)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for WithGroup")</span>
        }

        <span class="cov0" title="0">var r0 slog.Handler
        if rf, ok := ret.Get(0).(func(string) slog.Handler); ok </span><span class="cov0" title="0">{
                r0 = rf(name)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(slog.Handler)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// MockSlogHandler_WithGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithGroup'
type MockSlogHandler_WithGroup_Call struct {
        *mock.Call
}

// WithGroup is a helper method to define mock.On call
//   - name string
func (_e *MockSlogHandler_Expecter) WithGroup(name interface{}) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        return &amp;MockSlogHandler_WithGroup_Call{Call: _e.mock.On("WithGroup", name)}
}</span>

func (_c *MockSlogHandler_WithGroup_Call) Run(run func(name string)) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_WithGroup_Call) Return(_a0 slog.Handler) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_WithGroup_Call) RunAndReturn(run func(string) slog.Handler) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockSlogHandler creates a new instance of MockSlogHandler. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSlogHandler(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockSlogHandler <span class="cov10" title="4">{
        mock := &amp;MockSlogHandler{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="4">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="4">return mock</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package diag

import (
        "context"
        "io"
        "log/slog"
        "os"
)

type contextKey string

const (
        contextDiagAttrs = contextKey("diag.context-key.log-attribs")
)

type LogAttributes struct {
        CorrelationID slog.Value
}

func GetLogAttributesFromContext(ctx context.Context) LogAttributes <span class="cov4" title="9">{
        res, _ := ctx.Value(contextDiagAttrs).(LogAttributes)
        return res
}</span>

func SetLogAttributesToContext(ctx context.Context, attributes LogAttributes) context.Context <span class="cov4" title="6">{
        return context.WithValue(ctx, contextDiagAttrs, attributes)
}</span>

type diagLogHandler struct {
        target slog.Handler
}

func (h *diagLogHandler) Enabled(ctx context.Context, lvl slog.Level) bool <span class="cov10" title="205">{
        return h.target.Enabled(ctx, lvl)
}</span>

func (h *diagLogHandler) Handle(ctx context.Context, rec slog.Record) error <span class="cov9" title="117">{
        if diagAttributes, ok := ctx.Value(contextDiagAttrs).(LogAttributes); ok </span><span class="cov2" title="2">{
                rec.AddAttrs(
                        slog.Attr{Key: "correlationId", Value: diagAttributes.CorrelationID},
                )
        }</span>

        <span class="cov9" title="117">return h.target.Handle(ctx, rec)</span>
}

func (h *diagLogHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov9" title="159">{
        return &amp;diagLogHandler{target: h.target.WithAttrs(attrs)}
}</span>

func (h *diagLogHandler) WithGroup(name string) slog.Handler <span class="cov9" title="158">{
        // Using WithAttrs here since group will nest all the attributes
        // inside of it (including correlationId), which makes it harder to
        // filter logs by the correlationId.
        // Consumers can use slog.Group if some attributes needs to be grouped
        return h.WithAttrs([]slog.Attr{slog.String("group", name)})
}</span>

var _ slog.Handler = &amp;diagLogHandler{}

type RootLoggerOpts struct {
        output io.Writer

        jsonLogs bool

        // Info is default (zero)
        logLevel slog.Level
}

func (opts *RootLoggerOpts) WithJSONLogs(value bool) *RootLoggerOpts <span class="cov2" title="3">{
        opts.jsonLogs = value
        return opts
}</span>

func (opts *RootLoggerOpts) WithLogLevel(logLevel slog.Level) *RootLoggerOpts <span class="cov2" title="3">{
        opts.logLevel = logLevel
        return opts
}</span>

func (opts *RootLoggerOpts) WithOutput(output io.Writer) *RootLoggerOpts <span class="cov9" title="152">{
        opts.output = output
        return opts
}</span>

func (opts *RootLoggerOpts) WithOptionalOutputFile(outputFile string) *RootLoggerOpts <span class="cov2" title="3">{
        if outputFile == "" </span><span class="cov1" title="1">{
                return opts
        }</span>
        <span class="cov2" title="2">f, err := os.OpenFile(outputFile, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0o666)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov2" title="2">opts.output = f
        return opts</span>
}

func NewRootLoggerOpts() *RootLoggerOpts <span class="cov9" title="156">{
        return &amp;RootLoggerOpts{
                output: os.Stdout,
        }
}</span>

func SetupRootLogger(opts *RootLoggerOpts) *slog.Logger <span class="cov9" title="156">{
        logHandlerOpts := &amp;slog.HandlerOptions{Level: opts.logLevel}
        var logHandler slog.Handler
        if opts.jsonLogs </span><span class="cov1" title="1">{
                logHandler = slog.NewJSONHandler(opts.output, logHandlerOpts)
        }</span> else<span class="cov9" title="155"> {
                logHandler = slog.NewTextHandler(opts.output, logHandlerOpts)
        }</span>
        <span class="cov9" title="156">return slog.New(&amp;diagLogHandler{target: logHandler})</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">//go:build !release

// TODO: generated code should include "//go:build !release" tags
//go:generate mockgen -typed -package diag -destination mock_slog_handler_test.go log/slog Handler

package diag

import (
        "fmt"
        "log/slog"
        "os"
        "path/filepath"
        "runtime"
)

// openTestLogFile will open a log file in a project root directory.
func openTestLogFile() *os.File <span class="cov5" title="10">{
        _, filename, _, _ := runtime.Caller(0) // Will be current file
        testFilePath := filepath.Join(filename, "..", "..", "..", "test.log")
        f, err := os.OpenFile(testFilePath, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0o666)
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("fail to open log file %q for test logging: %w", testFilePath, err)
                panic(err)</span>
        }
        <span class="cov5" title="10">return f</span>
}

var testOutput = openTestLogFile() //nolint:gochecknoglobals //it's ok for tests

func RootTestLogger() *slog.Logger <span class="cov10" title="151">{
        return SetupRootLogger(
                NewRootLoggerOpts().WithOutput(testOutput),
        )
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package k8s

import (
        "context"
        "errors"
        "log/slog"

        "github.com/gemyago/oke-gateway-api/internal/app"
        "github.com/gemyago/oke-gateway-api/internal/diag"
        "github.com/google/uuid"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

type controllerMiddleware[request comparable] func(
        next reconcile.TypedReconciler[request],
) reconcile.TypedReconciler[request]

func newTracingMiddleware() controllerMiddleware[reconcile.Request] <span class="cov1" title="1">{
        return func(next reconcile.TypedReconciler[reconcile.Request]) reconcile.TypedReconciler[reconcile.Request] </span><span class="cov1" title="1">{
                return reconcile.TypedFunc[reconcile.Request](
                        func(ctx context.Context, req reconcile.Request) (reconcile.Result, error) </span><span class="cov1" title="1">{
                                diagCtx := diag.SetLogAttributesToContext(ctx, diag.LogAttributes{
                                        CorrelationID: slog.StringValue(uuid.New().String()),
                                })
                                return next.Reconcile(diagCtx, req)
                        }</span>,
                )
        }
}

func newErrorHandlingMiddleware(
        logger *slog.Logger,
) controllerMiddleware[reconcile.Request] <span class="cov10" title="3">{
        return func(next reconcile.TypedReconciler[reconcile.Request]) reconcile.TypedReconciler[reconcile.Request] </span><span class="cov10" title="3">{
                // TODO: Handle and do not requeue some errors
                // like 4xx errors from OCI

                return reconcile.TypedFunc[reconcile.Request](
                        func(ctx context.Context, req reconcile.Request) (reconcile.Result, error) </span><span class="cov10" title="3">{
                                res, err := next.Reconcile(ctx, req)
                                if err != nil </span><span class="cov6" title="2">{
                                        var reconcileErr *app.ReconcileError
                                        if errors.As(err, &amp;reconcileErr) &amp;&amp; !reconcileErr.IsRetriable() </span><span class="cov1" title="1">{
                                                // Non-retriable error, do not requeue
                                                logger.ErrorContext(ctx, "Non-retriable reconcile error, skipping requeue",
                                                        slog.Any("request", req),
                                                        diag.ErrAttr(err),
                                                )
                                                return reconcile.Result{}, nil // Return nil error to stop reconciliation
                                        }</span>

                                        <span class="cov1" title="1">logger.ErrorContext(ctx, "Reconcile failed",
                                                slog.Any("request", req),
                                                diag.ErrAttr(err),
                                        )</span>
                                }
                                <span class="cov6" title="2">return res, err</span>
                        })
        }
}

func wireupReconciler(
        ctrl reconcile.TypedReconciler[reconcile.Request],
        middlewares ...controllerMiddleware[reconcile.Request],
) reconcile.TypedReconciler[reconcile.Request] <span class="cov6" title="2">{
        for i := len(middlewares) - 1; i &gt;= 0; i-- </span><span class="cov6" title="2">{
                ctrl = middlewares[i](ctrl)
        }</span>
        <span class="cov6" title="2">return ctrl</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package k8s

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/gemyago/oke-gateway-api/internal/app"
        "github.com/go-logr/logr"
        "go.uber.org/dig"
        discoveryv1 "k8s.io/api/discovery/v1"
        "k8s.io/client-go/rest"
        "sigs.k8s.io/controller-runtime/pkg/builder"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/manager"
        "sigs.k8s.io/controller-runtime/pkg/predicate"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
)

// StartManagerDeps contains the dependencies for the controller manager.
type StartManagerDeps struct {
        dig.In

        RootLogger       *slog.Logger
        Manager          manager.Manager
        GatewayClassCtrl *app.GatewayClassController
        GatewayCtrl      *app.GatewayController
        HTTPRouteCtrl    *app.HTTPRouteController
        WatchesModel     *app.WatchesModel
        Config           *rest.Config
}

// StartManager starts the controller manager.
func StartManager(ctx context.Context, deps StartManagerDeps) error <span class="cov0" title="0">{ // coverage-ignore -- challenging to test
        logger := deps.RootLogger.WithGroup("k8s")

        rlogLogger := logr.FromSlogHandler(logger.Handler())
        loggerCtx := logr.NewContext(ctx, rlogLogger)
        log.SetLogger(rlogLogger)

        mgr := deps.Manager

        if err := deps.WatchesModel.RegisterFieldIndexers(ctx, mgr.GetFieldIndexer()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register field indexers: %w", err)
        }</span>

        <span class="cov0" title="0">middlewares := []controllerMiddleware[reconcile.Request]{
                newTracingMiddleware(),
                newErrorHandlingMiddleware(deps.RootLogger),
        }

        if err := builder.ControllerManagedBy(mgr).
                For(&amp;gatewayv1.Gateway{}).
                WithEventFilter(predicate.Or(predicate.GenerationChangedPredicate{}, predicate.LabelChangedPredicate{})).
                Complete(wireupReconciler(deps.GatewayCtrl, middlewares...)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to setup Gateway controller: %w", err)
        }</span>

        <span class="cov0" title="0">if err := builder.ControllerManagedBy(mgr).
                For(&amp;gatewayv1.GatewayClass{}).
                WithEventFilter(predicate.Or(predicate.GenerationChangedPredicate{}, predicate.LabelChangedPredicate{})).
                Complete(wireupReconciler(deps.GatewayClassCtrl, middlewares...)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to setup GatewayClass controller: %w", err)
        }</span>

        <span class="cov0" title="0">if err := builder.ControllerManagedBy(mgr).
                For(&amp;gatewayv1.HTTPRoute{}).
                Watches(
                        &amp;discoveryv1.EndpointSlice{},
                        handler.EnqueueRequestsFromMapFunc(deps.WatchesModel.MapEndpointSliceToHTTPRoute),
                ).
                WithEventFilter(predicate.Or(predicate.GenerationChangedPredicate{}, predicate.LabelChangedPredicate{})).
                Complete(wireupReconciler(deps.HTTPRouteCtrl, middlewares...)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to setup HTTPRoute controller: %w", err)
        }</span>

        <span class="cov0" title="0">logger.InfoContext(loggerCtx, "Starting controller manager")
        return mgr.Start(loggerCtx)</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// coverage-ignore

package k8sapi

import (
        "fmt"
        "log/slog"
        "os"
        "path/filepath"

        "github.com/gemyago/oke-gateway-api/internal/types"
        "go.uber.org/dig"
        "k8s.io/apimachinery/pkg/runtime"
        clientgoscheme "k8s.io/client-go/kubernetes/scheme"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/client-go/util/homedir"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/manager"
        gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
)

type ConfigDeps struct {
        dig.In

        RootLogger *slog.Logger

        // This can be set via APP_K8SAPI_NOOP env variable
        Noop      bool `name:"config.k8sapi.noop"`
        InCluster bool `name:"config.k8sapi.inCluster"`
}

func newConfig(deps ConfigDeps) (*rest.Config, error) <span class="cov8" title="1">{
        if deps.Noop </span><span class="cov8" title="1">{
                deps.RootLogger.Warn("Kubernetes API client is in noop mode")
                return &amp;rest.Config{}, nil
        }</span>

        <span class="cov0" title="0">if deps.InCluster </span><span class="cov0" title="0">{
                cfg, err := rest.InClusterConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get in-cluster config: %w", err)
                }</span>
                <span class="cov0" title="0">return cfg, nil</span>
        }

        <span class="cov0" title="0">kubeconfig := os.Getenv("KUBECONFIG")

        if kubeconfig == "" </span><span class="cov0" title="0">{
                if home := homedir.HomeDir(); home != "" </span><span class="cov0" title="0">{
                        kubeconfig = filepath.Join(home, ".kube", "config")
                }</span>
        }

        <span class="cov0" title="0">return clientcmd.BuildConfigFromFlags("", kubeconfig)</span>
}

func newManager(config *rest.Config) (manager.Manager, error) <span class="cov8" title="1">{
        scheme := runtime.NewScheme()

        if err := clientgoscheme.AddToScheme(scheme); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add kubernetes scheme: %w", err)
        }</span>

        <span class="cov8" title="1">if err := types.AddKnownTypes(scheme); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add gateway api scheme: %w", err)
        }</span>

        <span class="cov8" title="1">if err := gatewayv1.Install(scheme); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add gateway api scheme: %w", err)
        }</span>

        <span class="cov8" title="1">return manager.New(config, manager.Options{
                Scheme: scheme,
        })</span>
}

func newClient(manager manager.Manager) (client.Client, error) <span class="cov8" title="1">{
        return manager.GetClient(), nil
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package k8sapi

import (
        context "context"

        client "sigs.k8s.io/controller-runtime/pkg/client"

        mock "github.com/stretchr/testify/mock"
)

// MockFieldIndexer is an autogenerated mock type for the FieldIndexer type
type MockFieldIndexer struct {
        mock.Mock
}

type MockFieldIndexer_Expecter struct {
        mock *mock.Mock
}

func (_m *MockFieldIndexer) EXPECT() *MockFieldIndexer_Expecter <span class="cov10" title="2">{
        return &amp;MockFieldIndexer_Expecter{mock: &amp;_m.Mock}
}</span>

// IndexField provides a mock function with given fields: ctx, obj, field, extractValue
func (_m *MockFieldIndexer) IndexField(ctx context.Context, obj client.Object, field string, extractValue client.IndexerFunc) error <span class="cov10" title="2">{
        ret := _m.Called(ctx, obj, field, extractValue)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for IndexField")</span>
        }

        <span class="cov10" title="2">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, client.Object, string, client.IndexerFunc) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, obj, field, extractValue)
        }</span> else<span class="cov10" title="2"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov10" title="2">return r0</span>
}

// MockFieldIndexer_IndexField_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IndexField'
type MockFieldIndexer_IndexField_Call struct {
        *mock.Call
}

// IndexField is a helper method to define mock.On call
//   - ctx context.Context
//   - obj client.Object
//   - field string
//   - extractValue client.IndexerFunc
func (_e *MockFieldIndexer_Expecter) IndexField(ctx interface{}, obj interface{}, field interface{}, extractValue interface{}) *MockFieldIndexer_IndexField_Call <span class="cov10" title="2">{
        return &amp;MockFieldIndexer_IndexField_Call{Call: _e.mock.On("IndexField", ctx, obj, field, extractValue)}
}</span>

func (_c *MockFieldIndexer_IndexField_Call) Run(run func(ctx context.Context, obj client.Object, field string, extractValue client.IndexerFunc)) *MockFieldIndexer_IndexField_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(client.Object), args[2].(string), args[3].(client.IndexerFunc))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockFieldIndexer_IndexField_Call) Return(_a0 error) *MockFieldIndexer_IndexField_Call <span class="cov10" title="2">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockFieldIndexer_IndexField_Call) RunAndReturn(run func(context.Context, client.Object, string, client.IndexerFunc) error) *MockFieldIndexer_IndexField_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockFieldIndexer creates a new instance of MockFieldIndexer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockFieldIndexer(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockFieldIndexer <span class="cov10" title="2">{
        mock := &amp;MockFieldIndexer{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="2">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="2">return mock</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package k8sapi

import (
        context "context"

        client "sigs.k8s.io/controller-runtime/pkg/client"

        mock "github.com/stretchr/testify/mock"
)

// MockSubResourceWriter is an autogenerated mock type for the SubResourceWriter type
type MockSubResourceWriter struct {
        mock.Mock
}

type MockSubResourceWriter_Expecter struct {
        mock *mock.Mock
}

func (_m *MockSubResourceWriter) EXPECT() *MockSubResourceWriter_Expecter <span class="cov10" title="8">{
        return &amp;MockSubResourceWriter_Expecter{mock: &amp;_m.Mock}
}</span>

// Create provides a mock function with given fields: ctx, obj, subResource, opts
func (_m *MockSubResourceWriter) Create(ctx context.Context, obj client.Object, subResource client.Object, opts ...client.SubResourceCreateOption) error <span class="cov0" title="0">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, ctx, obj, subResource)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Create")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, client.Object, client.Object, ...client.SubResourceCreateOption) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, obj, subResource, opts...)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockSubResourceWriter_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockSubResourceWriter_Create_Call struct {
        *mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - obj client.Object
//   - subResource client.Object
//   - opts ...client.SubResourceCreateOption
func (_e *MockSubResourceWriter_Expecter) Create(ctx interface{}, obj interface{}, subResource interface{}, opts ...interface{}) *MockSubResourceWriter_Create_Call <span class="cov0" title="0">{
        return &amp;MockSubResourceWriter_Create_Call{Call: _e.mock.On("Create",
                append([]interface{}{ctx, obj, subResource}, opts...)...)}
}</span>

func (_c *MockSubResourceWriter_Create_Call) Run(run func(ctx context.Context, obj client.Object, subResource client.Object, opts ...client.SubResourceCreateOption)) *MockSubResourceWriter_Create_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]client.SubResourceCreateOption, len(args)-3)
                for i, a := range args[3:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(client.SubResourceCreateOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(client.Object), args[2].(client.Object), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSubResourceWriter_Create_Call) Return(_a0 error) *MockSubResourceWriter_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSubResourceWriter_Create_Call) RunAndReturn(run func(context.Context, client.Object, client.Object, ...client.SubResourceCreateOption) error) *MockSubResourceWriter_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Patch provides a mock function with given fields: ctx, obj, patch, opts
func (_m *MockSubResourceWriter) Patch(ctx context.Context, obj client.Object, patch client.Patch, opts ...client.SubResourcePatchOption) error <span class="cov0" title="0">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov0" title="0">var _ca []interface{}
        _ca = append(_ca, ctx, obj, patch)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Patch")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, client.Object, client.Patch, ...client.SubResourcePatchOption) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, obj, patch, opts...)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockSubResourceWriter_Patch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Patch'
type MockSubResourceWriter_Patch_Call struct {
        *mock.Call
}

// Patch is a helper method to define mock.On call
//   - ctx context.Context
//   - obj client.Object
//   - patch client.Patch
//   - opts ...client.SubResourcePatchOption
func (_e *MockSubResourceWriter_Expecter) Patch(ctx interface{}, obj interface{}, patch interface{}, opts ...interface{}) *MockSubResourceWriter_Patch_Call <span class="cov0" title="0">{
        return &amp;MockSubResourceWriter_Patch_Call{Call: _e.mock.On("Patch",
                append([]interface{}{ctx, obj, patch}, opts...)...)}
}</span>

func (_c *MockSubResourceWriter_Patch_Call) Run(run func(ctx context.Context, obj client.Object, patch client.Patch, opts ...client.SubResourcePatchOption)) *MockSubResourceWriter_Patch_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]client.SubResourcePatchOption, len(args)-3)
                for i, a := range args[3:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(client.SubResourcePatchOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(client.Object), args[2].(client.Patch), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSubResourceWriter_Patch_Call) Return(_a0 error) *MockSubResourceWriter_Patch_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSubResourceWriter_Patch_Call) RunAndReturn(run func(context.Context, client.Object, client.Patch, ...client.SubResourcePatchOption) error) *MockSubResourceWriter_Patch_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Update provides a mock function with given fields: ctx, obj, opts
func (_m *MockSubResourceWriter) Update(ctx context.Context, obj client.Object, opts ...client.SubResourceUpdateOption) error <span class="cov10" title="8">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov0" title="0">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov10" title="8">var _ca []interface{}
        _ca = append(_ca, ctx, obj)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Update")</span>
        }

        <span class="cov10" title="8">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, client.Object, ...client.SubResourceUpdateOption) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, obj, opts...)
        }</span> else<span class="cov10" title="8"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov10" title="8">return r0</span>
}

// MockSubResourceWriter_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockSubResourceWriter_Update_Call struct {
        *mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - obj client.Object
//   - opts ...client.SubResourceUpdateOption
func (_e *MockSubResourceWriter_Expecter) Update(ctx interface{}, obj interface{}, opts ...interface{}) *MockSubResourceWriter_Update_Call <span class="cov10" title="8">{
        return &amp;MockSubResourceWriter_Update_Call{Call: _e.mock.On("Update",
                append([]interface{}{ctx, obj}, opts...)...)}
}</span>

func (_c *MockSubResourceWriter_Update_Call) Run(run func(ctx context.Context, obj client.Object, opts ...client.SubResourceUpdateOption)) *MockSubResourceWriter_Update_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]client.SubResourceUpdateOption, len(args)-2)
                for i, a := range args[2:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(client.SubResourceUpdateOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(client.Object), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSubResourceWriter_Update_Call) Return(_a0 error) *MockSubResourceWriter_Update_Call <span class="cov10" title="8">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSubResourceWriter_Update_Call) RunAndReturn(run func(context.Context, client.Object, ...client.SubResourceUpdateOption) error) *MockSubResourceWriter_Update_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockSubResourceWriter creates a new instance of MockSubResourceWriter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSubResourceWriter(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockSubResourceWriter <span class="cov10" title="8">{
        mock := &amp;MockSubResourceWriter{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="8">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="8">return mock</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package k8sapi

import (
        "github.com/gemyago/oke-gateway-api/internal/di"
        "go.uber.org/dig"
)

func Register(container *dig.Container) error <span class="cov8" title="1">{
        return di.ProvideAll(container,
                newConfig,
                newManager,
                newClient,
        )
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package ociapi

import (
        "fmt"
        "log/slog"

        "github.com/oracle/oci-go-sdk/v65/common"
        "github.com/oracle/oci-go-sdk/v65/loadbalancer"
        "go.uber.org/dig"
)

type LoadBalancerConfigDeps struct {
        dig.In

        RootLogger *slog.Logger

        ConfigProvider common.ConfigurationProvider

        // This can be set via APP_OCIAPI_NOOP env variable
        Noop bool `name:"config.ociapi.noop"`
}

func newLoadBalancerClient(
        deps LoadBalancerConfigDeps,
) (loadbalancer.LoadBalancerClient, error) <span class="cov8" title="1">{
        if deps.Noop </span><span class="cov8" title="1">{
                deps.RootLogger.Warn("OCI API client is in noop mode")
                return loadbalancer.LoadBalancerClient{}, nil
        }</span>

        <span class="cov0" title="0">client, err := loadbalancer.NewLoadBalancerClientWithConfigurationProvider(deps.ConfigProvider)
        if err != nil </span><span class="cov0" title="0">{
                return loadbalancer.LoadBalancerClient{}, fmt.Errorf("failed to create load balancer client: %w", err)
        }</span>
        <span class="cov0" title="0">return client, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package ociapi

import (
        "github.com/oracle/oci-go-sdk/v65/common"
)

func newConfigProvider() (common.ConfigurationProvider, error) <span class="cov8" title="1">{
        // TODO: This needs more advanced setup and support in cluster config
        configProvider := common.DefaultConfigProvider()
        return configProvider, nil
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package ociapi

import (
        context "context"

        loadbalancer "github.com/oracle/oci-go-sdk/v65/loadbalancer"
        mock "github.com/stretchr/testify/mock"
)

// MockworkRequestsClient is an autogenerated mock type for the workRequestsClient type
type MockworkRequestsClient struct {
        mock.Mock
}

type MockworkRequestsClient_Expecter struct {
        mock *mock.Mock
}

func (_m *MockworkRequestsClient) EXPECT() *MockworkRequestsClient_Expecter <span class="cov10" title="10">{
        return &amp;MockworkRequestsClient_Expecter{mock: &amp;_m.Mock}
}</span>

// GetWorkRequest provides a mock function with given fields: ctx, request
func (_m *MockworkRequestsClient) GetWorkRequest(ctx context.Context, request loadbalancer.GetWorkRequestRequest) (loadbalancer.GetWorkRequestResponse, error) <span class="cov10" title="10">{
        ret := _m.Called(ctx, request)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetWorkRequest")</span>
        }

        <span class="cov10" title="10">var r0 loadbalancer.GetWorkRequestResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.GetWorkRequestRequest) (loadbalancer.GetWorkRequestResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, request)
        }</span>
        <span class="cov10" title="10">if rf, ok := ret.Get(0).(func(context.Context, loadbalancer.GetWorkRequestRequest) loadbalancer.GetWorkRequestResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, request)
        }</span> else<span class="cov10" title="10"> {
                r0 = ret.Get(0).(loadbalancer.GetWorkRequestResponse)
        }</span>

        <span class="cov10" title="10">if rf, ok := ret.Get(1).(func(context.Context, loadbalancer.GetWorkRequestRequest) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, request)
        }</span> else<span class="cov10" title="10"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov10" title="10">return r0, r1</span>
}

// MockworkRequestsClient_GetWorkRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkRequest'
type MockworkRequestsClient_GetWorkRequest_Call struct {
        *mock.Call
}

// GetWorkRequest is a helper method to define mock.On call
//   - ctx context.Context
//   - request loadbalancer.GetWorkRequestRequest
func (_e *MockworkRequestsClient_Expecter) GetWorkRequest(ctx interface{}, request interface{}) *MockworkRequestsClient_GetWorkRequest_Call <span class="cov10" title="10">{
        return &amp;MockworkRequestsClient_GetWorkRequest_Call{Call: _e.mock.On("GetWorkRequest", ctx, request)}
}</span>

func (_c *MockworkRequestsClient_GetWorkRequest_Call) Run(run func(ctx context.Context, request loadbalancer.GetWorkRequestRequest)) *MockworkRequestsClient_GetWorkRequest_Call <span class="cov1" title="1">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov1" title="1">{
                run(args[0].(context.Context), args[1].(loadbalancer.GetWorkRequestRequest))
        }</span>)
        <span class="cov1" title="1">return _c</span>
}

func (_c *MockworkRequestsClient_GetWorkRequest_Call) Return(_a0 loadbalancer.GetWorkRequestResponse, _a1 error) *MockworkRequestsClient_GetWorkRequest_Call <span class="cov10" title="10">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockworkRequestsClient_GetWorkRequest_Call) RunAndReturn(run func(context.Context, loadbalancer.GetWorkRequestRequest) (loadbalancer.GetWorkRequestResponse, error)) *MockworkRequestsClient_GetWorkRequest_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockworkRequestsClient creates a new instance of MockworkRequestsClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockworkRequestsClient(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockworkRequestsClient <span class="cov6" title="4">{
        mock := &amp;MockworkRequestsClient{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov6" title="4">{ mock.AssertExpectations(t) }</span>)

        <span class="cov6" title="4">return mock</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package ociapi

import (
        "fmt"
        "hash/crc32"
        "regexp"
)

const (
        ociResourceNameHashPartDivider = 2
)

// OCIResourceNameConfig holds configuration for generating OCI resource names.
type OCIResourceNameConfig struct {
        MaxLength           int
        InvalidCharsPattern *regexp.Regexp
        sanitizeFunc        func(string, *regexp.Regexp) string
        hashFunc            func(string) string
}

// defaultHashFunc calculates a CRC32 checksum and returns it as an 8-character lowercase hexadecimal string.
func defaultHashFunc(input string) string <span class="cov5" title="7">{
        checksum := crc32.ChecksumIEEE([]byte(input))
        return fmt.Sprintf("%08x", checksum)
}</span>

// defaultSanitizeFunc replaces characters matching the provided pattern with an underscore.
// If no pattern is provided, or name is empty, it returns the name as is.
func defaultSanitizeFunc(name string, pattern *regexp.Regexp) string <span class="cov6" title="11">{
        if name == "" || pattern == nil </span><span class="cov1" title="1">{
                return name
        }</span>
        <span class="cov6" title="10">return pattern.ReplaceAllString(name, "_")</span>
}

// ConstructOCIResourceName generates a resource name string based on the originalName and configuration.
// If a sanitization pattern is provided in the config, originalName is first sanitized.
// If the resulting name is within MaxLength (and MaxLength &gt; 0), it's returned.
// If MaxLength &lt;=0, the sanitized name is returned without length restriction.
// Otherwise (name too long and MaxLength &gt; 0), the *original* originalName is hashed, and the name is constructed as:
// &lt;start_of_sanitized_name&gt; + &lt;hash_of_original_name&gt; + &lt;end_of_sanitized_name&gt;,
// ensuring the total length does not exceed MaxLength.
func ConstructOCIResourceName(originalName string, config OCIResourceNameConfig) string <span class="cov10" title="41">{
        if config.hashFunc == nil </span><span class="cov9" title="33">{
                config.hashFunc = defaultHashFunc
        }</span>

        <span class="cov10" title="41">if config.sanitizeFunc == nil </span><span class="cov9" title="39">{
                config.sanitizeFunc = defaultSanitizeFunc
        }</span>

        <span class="cov10" title="41">resultingName := originalName
        if config.InvalidCharsPattern != nil </span><span class="cov6" title="11">{
                resultingName = config.sanitizeFunc(originalName, config.InvalidCharsPattern)
        }</span>

        <span class="cov10" title="41">if config.MaxLength &gt; 0 &amp;&amp; len(resultingName) &gt; config.MaxLength </span><span class="cov7" title="13">{
                hash := config.hashFunc(originalName)
                if len(hash) &gt;= config.MaxLength </span><span class="cov2" title="2">{
                        return hash[:config.MaxLength]
                }</span>
                <span class="cov6" title="11">originalLength := len(resultingName)
                hashStarts := originalLength/ociResourceNameHashPartDivider - len(hash)/ociResourceNameHashPartDivider
                hashEnds := hashStarts + len(hash)
                remainingLength := config.MaxLength - hashEnds
                resultingName = resultingName[:hashStarts] + hash + resultingName[originalLength-remainingLength:]</span>
        }

        <span class="cov9" title="39">return resultingName</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package ociapi

import (
        "github.com/gemyago/oke-gateway-api/internal/di"
        "github.com/oracle/oci-go-sdk/v65/loadbalancer"
        "go.uber.org/dig"
)

func Register(container *dig.Container) error <span class="cov8" title="1">{
        return di.ProvideAll(container,
                newConfigProvider,
                newLoadBalancerClient,
                NewWorkRequestsWatcher,
                func(c loadbalancer.LoadBalancerClient) workRequestsClient </span><span class="cov8" title="1">{ return c }</span>,
        )
}
</pre>
		
		<pre class="file" id="file52" style="display: none">//go:build !release

package ociapi

import (
        "fmt"
        "math/rand/v2"

        "github.com/go-faker/faker/v4"
        "github.com/oracle/oci-go-sdk/v65/common"
)

type MockServiceError struct {
        statusCode   int
        message      string
        code         string
        opcRequestID string
}

func (m *MockServiceError) GetHTTPStatusCode() int <span class="cov8" title="1">{
        return m.statusCode
}</span>

func (m *MockServiceError) GetMessage() string <span class="cov0" title="0">{
        return m.message
}</span>

func (m *MockServiceError) GetCode() string <span class="cov0" title="0">{
        return m.code
}</span>

func (m *MockServiceError) GetOpcRequestID() string <span class="cov0" title="0">{
        return m.opcRequestID
}</span>

func (m *MockServiceError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("mock service error statusCode: %d, message: %s", m.statusCode, m.message)
}</span>

var _ common.ServiceError = &amp;MockServiceError{}
var _ error = &amp;MockServiceError{}

type RandomServiceErrorOpts func(*MockServiceError)

func NewRandomServiceError(opts ...RandomServiceErrorOpts) *MockServiceError <span class="cov8" title="1">{
        res := &amp;MockServiceError{
                statusCode:   rand.IntN(399) + 100,
                message:      faker.Sentence(),
                code:         faker.Word(),
                opcRequestID: faker.UUIDHyphenated(),
        }

        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(res)
        }</span>

        <span class="cov8" title="1">return res</span>
}

func RandomServiceErrorWithStatusCode(statusCode int) RandomServiceErrorOpts <span class="cov8" title="1">{
        return func(m *MockServiceError) </span><span class="cov8" title="1">{
                m.statusCode = statusCode
        }</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package ociapi

import (
        "context"
        "fmt"
        "log/slog"
        "time"

        "github.com/oracle/oci-go-sdk/v65/loadbalancer" // Assuming v65, adjust if needed
        "go.uber.org/dig"
)

// workRequestsClient defines the interface for OCI work requests client operations.
type workRequestsClient interface {
        // GetWorkRequest gets the details of a work request.
        GetWorkRequest(
                ctx context.Context,
                request loadbalancer.GetWorkRequestRequest,
        ) (loadbalancer.GetWorkRequestResponse, error)
}

// WorkRequestsWatcher defines the interface for watching OCI Work Requests.
type WorkRequestsWatcher struct {
        client          workRequestsClient
        logger          *slog.Logger
        pollInterval    time.Duration
        maxPollDuration time.Duration
}

// WaitFor waits for a work request to succeed.
func (w *WorkRequestsWatcher) WaitFor(ctx context.Context, workRequestID string) error <span class="cov6" title="4">{
        request := loadbalancer.GetWorkRequestRequest{
                WorkRequestId: &amp;workRequestID,
        }

        intervalTicker := time.NewTicker(w.pollInterval)
        defer intervalTicker.Stop()

        deadlineTicker := time.NewTimer(w.maxPollDuration)
        defer deadlineTicker.Stop()

        for </span><span class="cov10" title="10">{
                response, err := w.client.GetWorkRequest(ctx, request)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get work request %s: %w", workRequestID, err)
                }</span>

                <span class="cov10" title="10">if response.WorkRequest.LifecycleState == loadbalancer.WorkRequestLifecycleStateSucceeded </span><span class="cov1" title="1">{
                        return nil
                }</span>

                <span class="cov9" title="9">if response.WorkRequest.LifecycleState == loadbalancer.WorkRequestLifecycleStateFailed </span><span class="cov1" title="1">{
                        return fmt.Errorf("work request %s is in %s state", workRequestID, response.WorkRequest.LifecycleState)
                }</span>

                <span class="cov9" title="8">w.logger.DebugContext(
                        ctx, "work request is in progress",
                        slog.String("workRequestID", workRequestID),
                        slog.String("status", string(response.WorkRequest.LifecycleState)),
                )

                select </span>{
                case &lt;-intervalTicker.C:<span class="cov8" title="6"></span>
                case &lt;-deadlineTicker.C:<span class="cov1" title="1">
                        return fmt.Errorf("work request %s timed out: %w", workRequestID, context.DeadlineExceeded)</span>
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        return fmt.Errorf("work request %s timed out: %w", workRequestID, context.Canceled)</span>
                }
        }
}

type WorkRequestsWatcherDeps struct {
        dig.In `ignore-unexported:"true"`

        Client     workRequestsClient
        RootLogger *slog.Logger

        pollInterval    time.Duration
        maxPollDuration time.Duration
}

const defaultPollInterval = 2 * time.Second
const defaultMaxPollDuration = 20 * time.Minute

func NewWorkRequestsWatcher(deps WorkRequestsWatcherDeps) *WorkRequestsWatcher <span class="cov7" title="5">{
        if deps.pollInterval == 0 </span><span class="cov1" title="1">{
                deps.pollInterval = defaultPollInterval
        }</span>

        <span class="cov7" title="5">if deps.maxPollDuration == 0 </span><span class="cov6" title="4">{
                deps.maxPollDuration = defaultMaxPollDuration
        }</span>

        <span class="cov7" title="5">return &amp;WorkRequestsWatcher{
                client:          deps.Client,
                logger:          deps.RootLogger.WithGroup("oci-work-requests"),
                pollInterval:    deps.pollInterval,
                maxPollDuration: deps.maxPollDuration,
        }</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package services

import (
        "time"

        "github.com/gemyago/oke-gateway-api/internal/di"
        "go.uber.org/dig"
)

func Register(container *dig.Container) error <span class="cov10" title="2">{
        return di.ProvideAll(container,
                NewTimeProvider,
                di.ProvideValue(time.NewTicker),
                NewShutdownHooks,
        )
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">// ShutdownHooks are used to implement a graceful shutdown
// of the application. This may include closing database connections, flushing pending
// events to the queue, shutting down the http server, etc.

package services

import (
        "context"
        "fmt"
        "log/slog"
        "reflect"
        "time"

        "go.uber.org/dig"
        "golang.org/x/sync/errgroup"
)

type shutdownHook struct {
        name       string
        shutdownFn func(ctx context.Context) error
}

type ShutdownHooks struct {
        logger *slog.Logger
        hooks  []shutdownHook
        deps   ShutdownHooksRegistryDeps
}

// HasHook checks if a shutdown hook with the given name is registered.
// Typical usage is in tests and must be carefully considered for production scenarios.
func (h *ShutdownHooks) HasHook(name string, method any) bool <span class="cov6" title="4">{
        for _, hook := range h.hooks </span><span class="cov4" title="3">{
                if hook.name == name </span><span class="cov3" title="2">{
                        return reflect.ValueOf(hook.shutdownFn).Pointer() == reflect.ValueOf(method).Pointer()
                }</span>
        }
        <span class="cov3" title="2">return false</span>
}

func (h *ShutdownHooks) Register(name string, shutdown func(ctx context.Context) error) <span class="cov10" title="12">{
        h.hooks = append(h.hooks, shutdownHook{name: name, shutdownFn: shutdown})
}</span>

func (h *ShutdownHooks) RegisterNoCtx(name string, shutdown func() error) <span class="cov4" title="3">{
        h.Register(name, func(_ context.Context) error </span><span class="cov4" title="3">{
                return shutdown()
        }</span>)
}

func (h *ShutdownHooks) PerformShutdown(ctx context.Context) error <span class="cov6" title="5">{
        ctx, cancel := context.WithTimeout(ctx, h.deps.GracefulShutdownTimeout)
        defer cancel()

        errGrp := errgroup.Group{}
        for _, hook := range h.hooks </span><span class="cov9" title="10">{
                errGrp.Go(func() error </span><span class="cov9" title="10">{
                        hookName := hook.name
                        h.logger.InfoContext(ctx, fmt.Sprintf("Shutting down %s", hookName))
                        if err := hook.shutdownFn(ctx); err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to perform shutdown hook %s: %w", hookName, err)
                        }</span>
                        <span class="cov8" title="9">return nil</span>
                })
        }

        <span class="cov6" title="5">done := make(chan error)
        go func() </span><span class="cov6" title="5">{
                done &lt;- errGrp.Wait()
        }</span>()

        <span class="cov6" title="5">select </span>{
        case err := &lt;-done:<span class="cov6" title="5">
                return err</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        }
}

type ShutdownHooksRegistryDeps struct {
        dig.In

        RootLogger *slog.Logger

        // config
        GracefulShutdownTimeout time.Duration `name:"config.gracefulShutdownTimeout"`
}

func NewShutdownHooks(deps ShutdownHooksRegistryDeps) *ShutdownHooks <span class="cov8" title="7">{
        return &amp;ShutdownHooks{
                logger: deps.RootLogger.WithGroup("shutdown"),
                deps:   deps,
        }
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">//go:build !release

package services

import (
        "math"
        "strings"
        "time"

        "github.com/gemyago/oke-gateway-api/internal/diag"
        "github.com/go-faker/faker/v4"
)

type MockNow struct {
        value time.Time
}

var _ TimeProvider = &amp;MockNow{}

func (m *MockNow) SetValue(t time.Time) <span class="cov0" title="0">{
        m.value = t
}</span>

func (m *MockNow) Now() time.Time <span class="cov0" title="0">{
        return m.value
}</span>

func NewMockNow() *MockNow <span class="cov0" title="0">{
        return &amp;MockNow{
                value: time.UnixMilli(faker.RandomUnixTime()),
        }
}</span>

func MockNowValue(p TimeProvider) time.Time <span class="cov0" title="0">{
        mp, ok := p.(*MockNow)
        if !ok </span><span class="cov0" title="0">{
                panic("provided TimeProvider is not a MockNow")</span>
        }
        <span class="cov0" title="0">return mp.value</span>
}

const defaultTestShutdownTimeout = 30 * time.Second

func NewTestShutdownHooks() *ShutdownHooks <span class="cov1" title="1">{
        return NewShutdownHooks(ShutdownHooksRegistryDeps{
                RootLogger:              diag.RootTestLogger(),
                GracefulShutdownTimeout: defaultTestShutdownTimeout,
        })
}</span>

func RandomString(length int) string <span class="cov9" title="8">{
        segmentsCount := math.Ceil(float64(length) / 32)
        segments := make([]string, int(segmentsCount))
        for i := range segments </span><span class="cov10" title="10">{
                segments[i] = faker.UUIDDigit()
        }</span>
        <span class="cov9" title="8">return strings.Join(segments, "")[:length]</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package services

import "time"

type TimeProvider interface {
        Now() time.Time
}

type timeProviderFn func() time.Time

func (fn timeProviderFn) Now() time.Time <span class="cov8" title="1">{
        return fn()
}</span>

func NewTimeProvider() TimeProvider <span class="cov8" title="1">{
        return timeProviderFn(time.Now)
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package types

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

const (
        // GroupName is the group name used in this package.
        GroupName = "oke-gateway-api.gemyago.github.io"
        // Version is the API version.
        Version = "v1"
)

// Adds the list of known types to Scheme.
func AddKnownTypes(scheme *runtime.Scheme) error <span class="cov8" title="1">{
        groupVersion := schema.GroupVersion{Group: GroupName, Version: Version}
        scheme.AddKnownTypes(groupVersion,
                &amp;GatewayConfig{},
                &amp;GatewayConfigList{},
        )
        metav1.AddToGroupVersion(scheme, groupVersion)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">//go:build !ignore_autogenerated

/**/

// Code generated by controller-gen. DO NOT EDIT.

package types

import (
        "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GatewayConfig) DeepCopyInto(out *GatewayConfig) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        out.Spec = in.Spec
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GatewayConfig.
func (in *GatewayConfig) DeepCopy() *GatewayConfig <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(GatewayConfig)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *GatewayConfig) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GatewayConfigList) DeepCopyInto(out *GatewayConfigList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]GatewayConfig, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GatewayConfigList.
func (in *GatewayConfigList) DeepCopy() *GatewayConfigList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(GatewayConfigList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *GatewayConfigList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GatewayConfigSpec) DeepCopyInto(out *GatewayConfigSpec) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GatewayConfigSpec.
func (in *GatewayConfigSpec) DeepCopy() *GatewayConfigSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(GatewayConfigSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GatewayConfigStatus) DeepCopyInto(out *GatewayConfigStatus) <span class="cov0" title="0">{
        *out = *in
        if in.Conditions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make([]v1.Condition, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GatewayConfigStatus.
func (in *GatewayConfigStatus) DeepCopy() *GatewayConfigStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(GatewayConfigStatus)
        in.DeepCopyInto(out)
        return out</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
